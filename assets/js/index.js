import "https://player.vimeo.com/api/player.js"; const BREAKPOINTS = { SP: 768, TB: 992 }, SERVICE = [{ title: "Motion Design", descriptionEn: 'I design and create purposeful animations to effectively <br class="hidden lg:block"> convey messages in both video and websites. Specializing in motion graphics,<br class="md:hidden lg:block"> I focus on the flow and smoothness of movement,<br class="md:hidden"> balancing visual impact with intuitive usability.', descriptionJa: "映像やWebサイトにおいてメッセージを効果的に伝えるため、意図を持たせた設計・制作をします。主にモーショングラフィックスを得意とし、動きの流れや気持ちよさにこだわりながら視覚的なインパクトと直感的な操作感を両立させます。" }, { title: "Web Development", descriptionEn: 'I provide usability-focused development across various areas,<br class="hidden lg:block"> including markup, styling, CMS development, motion design,<br class="md:hidden"> and UI/UX optimization.<br class="hidden md:block"> I also prioritize performance improvements and accessibility to deliver a smooth and intuitive web experience.', descriptionJa: "マークアップ、スタイリング、CMS構築、モーションデザイン、UI/UX最適化など、幅広い分野に対応したユーザビリティ重視の開発を行います。サイト全体のパフォーマンス改善やアクセシビリティにも配慮し、スムーズで直感的なWeb体験を提供します。" }, { title: "Visual Design", descriptionEn: 'I create designs that visually embody a brand’s vision and concept,<br class="hidden lg:block"> especially in video content. By unifying elements such as layout, typography, color palettes, and icons,<br class="hidden md:block"> I build visuals that are both engaging and memorable for users.', descriptionJa: "主に映像におけるブランドのビジョンやコンセプトを視覚的に具現化するデザインを制作します。レイアウト、タイポグラフィ、カラーパレット、アイコンなどの要素を統一し、ユーザーにとって魅力的かつ記憶に残るビジュアルを構築します。" }, { title: "Art Direction", descriptionEn: 'I lead the creative strategy for projects,<br class="hidden lg:block"> ensuring the brand’s vision and values are reflected in the design. From concept to final output,<br class="hidden lg:block"> I manage each stage to deliver cohesive and impactful creative work.', descriptionJa: "プロジェクト全体のクリエイティブ戦略を指揮し、ブランドのビジョンや価値観がデザインに反映されるよう統括します。コンセプト立案から最終成果物までを管理し、統一感あるクリエイティブを実現します。" }]; function _assertThisInitialized(z) { if (z === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return z } function _inheritsLoose(z, F) { z.prototype = Object.create(F.prototype), z.prototype.constructor = z, z.__proto__ = F }/*!
 * GSAP 3.12.7
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/var _config$1 = { autoSleep: 120, force3D: "auto", nullTargetWarn: 1, units: { lineHeight: "" } }, _defaults$1 = { duration: .5, overwrite: !1, delay: 0 }, _suppressOverwrites$1, _reverting$2, _context$3, _bigNum$2 = 1e8, _tinyNum = 1 / _bigNum$2, _2PI = Math.PI * 2, _HALF_PI = _2PI / 4, _gsID = 0, _sqrt$2 = Math.sqrt, _cos$1 = Math.cos, _sin$1 = Math.sin, _isString$2 = function (F) { return typeof F == "string" }, _isFunction$2 = function (F) { return typeof F == "function" }, _isNumber$2 = function (F) { return typeof F == "number" }, _isUndefined = function (F) { return typeof F > "u" }, _isObject$1 = function (F) { return typeof F == "object" }, _isNotFalse = function (F) { return F !== !1 }, _windowExists$4 = function () { return typeof window < "u" }, _isFuncOrString = function (F) { return _isFunction$2(F) || _isString$2(F) }, _isTypedArray = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function () { }, _isArray = Array.isArray, _strictNumExp = /(?:-?\.?\d|\.)+/gi, _numExp$2 = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, _numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, _relExp = /[+-]=-?[.\d]+/, _delimitedValueExp = /[^,'"\[\]\s]+/gi, _unitExp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, _globalTimeline, _win$5, _coreInitted$7, _doc$4, _globals = {}, _installScope = {}, _coreReady, _install = function (F) { return (_installScope = _merge(F, _globals)) && gsap$8 }, _missingPlugin = function (F, G) { return console.warn("Invalid property", F, "set to", G, "Missing plugin? gsap.registerPlugin()") }, _warn$1 = function (F, G) { return !G && console.warn(F) }, _addGlobal = function (F, G) { return F && (_globals[F] = G) && _installScope && (_installScope[F] = G) || _globals }, _emptyFunc = function () { return 0 }, _startAtRevertConfig = { suppressEvents: !0, isStart: !0, kill: !1 }, _revertConfigNoKill = { suppressEvents: !0, kill: !1 }, _revertConfig = { suppressEvents: !0 }, _reservedProps = {}, _lazyTweens = [], _lazyLookup = {}, _lastRenderedFrame, _plugins = {}, _effects = {}, _nextGCFrame = 30, _harnessPlugins = [], _callbackNames = "", _harness = function (F) { var G = F[0], Y, X; if (_isObject$1(G) || _isFunction$2(G) || (F = [F]), !(Y = (G._gsap || {}).harness)) { for (X = _harnessPlugins.length; X-- && !_harnessPlugins[X].targetTest(G);); Y = _harnessPlugins[X] } for (X = F.length; X--;)F[X] && (F[X]._gsap || (F[X]._gsap = new GSCache(F[X], Y))) || F.splice(X, 1); return F }, _getCache = function (F) { return F._gsap || _harness(toArray(F))[0]._gsap }, _getProperty = function (F, G, Y) { return (Y = F[G]) && _isFunction$2(Y) ? F[G]() : _isUndefined(Y) && F.getAttribute && F.getAttribute(G) || Y }, _forEachName = function (F, G) { return (F = F.split(",")).forEach(G) || F }, _round$4 = function (F) { return Math.round(F * 1e5) / 1e5 || 0 }, _roundPrecise = function (F) { return Math.round(F * 1e7) / 1e7 || 0 }, _parseRelative = function (F, G) { var Y = G.charAt(0), X = parseFloat(G.substr(2)); return F = parseFloat(F), Y === "+" ? F + X : Y === "-" ? F - X : Y === "*" ? F * X : F / X }, _arrayContainsAny = function (F, G) { for (var Y = G.length, X = 0; F.indexOf(G[X]) < 0 && ++X < Y;); return X < Y }, _lazyRender = function () { var F = _lazyTweens.length, G = _lazyTweens.slice(0), Y, X; for (_lazyLookup = {}, _lazyTweens.length = 0, Y = 0; Y < F; Y++)X = G[Y], X && X._lazy && (X.render(X._lazy[0], X._lazy[1], !0)._lazy = 0) }, _lazySafeRender = function (F, G, Y, X) { _lazyTweens.length && !_reverting$2 && _lazyRender(), F.render(G, Y, _reverting$2 && G < 0 && (F._initted || F._startAt)), _lazyTweens.length && !_reverting$2 && _lazyRender() }, _numericIfPossible = function (F) { var G = parseFloat(F); return (G || G === 0) && (F + "").match(_delimitedValueExp).length < 2 ? G : _isString$2(F) ? F.trim() : F }, _passThrough$1 = function (F) { return F }, _setDefaults$1 = function (F, G) { for (var Y in G) Y in F || (F[Y] = G[Y]); return F }, _setKeyframeDefaults = function (F) { return function (G, Y) { for (var X in Y) X in G || X === "duration" && F || X === "ease" || (G[X] = Y[X]) } }, _merge = function (F, G) { for (var Y in G) F[Y] = G[Y]; return F }, _mergeDeep = function z(F, G) { for (var Y in G) Y !== "__proto__" && Y !== "constructor" && Y !== "prototype" && (F[Y] = _isObject$1(G[Y]) ? z(F[Y] || (F[Y] = {}), G[Y]) : G[Y]); return F }, _copyExcluding = function (F, G) { var Y = {}, X; for (X in F) X in G || (Y[X] = F[X]); return Y }, _inheritDefaults = function (F) { var G = F.parent || _globalTimeline, Y = F.keyframes ? _setKeyframeDefaults(_isArray(F.keyframes)) : _setDefaults$1; if (_isNotFalse(F.inherit)) for (; G;)Y(F, G.vars.defaults), G = G.parent || G._dp; return F }, _arraysMatch = function (F, G) { for (var Y = F.length, X = Y === G.length; X && Y-- && F[Y] === G[Y];); return Y < 0 }, _addLinkedListItem = function (F, G, Y, X, K) { var J = F[X], Z; if (K) for (Z = G[K]; J && J[K] > Z;)J = J._prev; return J ? (G._next = J._next, J._next = G) : (G._next = F[Y], F[Y] = G), G._next ? G._next._prev = G : F[X] = G, G._prev = J, G.parent = G._dp = F, G }, _removeLinkedListItem = function (F, G, Y, X) { Y === void 0 && (Y = "_first"), X === void 0 && (X = "_last"); var K = G._prev, J = G._next; K ? K._next = J : F[Y] === G && (F[Y] = J), J ? J._prev = K : F[X] === G && (F[X] = K), G._next = G._prev = G.parent = null }, _removeFromParent = function (F, G) { F.parent && (!G || F.parent.autoRemoveChildren) && F.parent.remove && F.parent.remove(F), F._act = 0 }, _uncache = function (F, G) { if (F && (!G || G._end > F._dur || G._start < 0)) for (var Y = F; Y;)Y._dirty = 1, Y = Y.parent; return F }, _recacheAncestors = function (F) { for (var G = F.parent; G && G.parent;)G._dirty = 1, G.totalDuration(), G = G.parent; return F }, _rewindStartAt = function (F, G, Y, X) { return F._startAt && (_reverting$2 ? F._startAt.revert(_revertConfigNoKill) : F.vars.immediateRender && !F.vars.autoRevert || F._startAt.render(G, !0, X)) }, _hasNoPausedAncestors = function z(F) { return !F || F._ts && z(F.parent) }, _elapsedCycleDuration = function (F) { return F._repeat ? _animationCycle(F._tTime, F = F.duration() + F._rDelay) * F : 0 }, _animationCycle = function (F, G) { var Y = Math.floor(F = _roundPrecise(F / G)); return F && Y === F ? Y - 1 : Y }, _parentToChildTotalTime = function (F, G) { return (F - G._start) * G._ts + (G._ts >= 0 ? 0 : G._dirty ? G.totalDuration() : G._tDur) }, _setEnd = function (F) { return F._end = _roundPrecise(F._start + (F._tDur / Math.abs(F._ts || F._rts || _tinyNum) || 0)) }, _alignPlayhead = function (F, G) { var Y = F._dp; return Y && Y.smoothChildTiming && F._ts && (F._start = _roundPrecise(Y._time - (F._ts > 0 ? G / F._ts : ((F._dirty ? F.totalDuration() : F._tDur) - G) / -F._ts)), _setEnd(F), Y._dirty || _uncache(Y, F)), F }, _postAddChecks = function (F, G) { var Y; if ((G._time || !G._dur && G._initted || G._start < F._time && (G._dur || !G.add)) && (Y = _parentToChildTotalTime(F.rawTime(), G), (!G._dur || _clamp$1(0, G.totalDuration(), Y) - G._tTime > _tinyNum) && G.render(Y, !0)), _uncache(F, G)._dp && F._initted && F._time >= F._dur && F._ts) { if (F._dur < F.duration()) for (Y = F; Y._dp;)Y.rawTime() >= 0 && Y.totalTime(Y._tTime), Y = Y._dp; F._zTime = -1e-8 } }, _addToTimeline = function (F, G, Y, X) { return G.parent && _removeFromParent(G), G._start = _roundPrecise((_isNumber$2(Y) ? Y : Y || F !== _globalTimeline ? _parsePosition$1(F, Y, G) : F._time) + G._delay), G._end = _roundPrecise(G._start + (G.totalDuration() / Math.abs(G.timeScale()) || 0)), _addLinkedListItem(F, G, "_first", "_last", F._sort ? "_start" : 0), _isFromOrFromStart(G) || (F._recent = G), X || _postAddChecks(F, G), F._ts < 0 && _alignPlayhead(F, F._tTime), F }, _scrollTrigger = function (F, G) { return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", G)) && _globals.ScrollTrigger.create(G, F) }, _attemptInitTween = function (F, G, Y, X, K) { if (_initTween(F, G, K), !F._initted) return 1; if (!Y && F._pt && !_reverting$2 && (F._dur && F.vars.lazy !== !1 || !F._dur && F.vars.lazy) && _lastRenderedFrame !== _ticker.frame) return _lazyTweens.push(F), F._lazy = [K, X], 1 }, _parentPlayheadIsBeforeStart = function z(F) { var G = F.parent; return G && G._ts && G._initted && !G._lock && (G.rawTime() < 0 || z(G)) }, _isFromOrFromStart = function (F) { var G = F.data; return G === "isFromStart" || G === "isStart" }, _renderZeroDurationTween = function (F, G, Y, X) { var K = F.ratio, J = G < 0 || !G && (!F._start && _parentPlayheadIsBeforeStart(F) && !(!F._initted && _isFromOrFromStart(F)) || (F._ts < 0 || F._dp._ts < 0) && !_isFromOrFromStart(F)) ? 0 : 1, Z = F._rDelay, Q = 0, ee, te, oe; if (Z && F._repeat && (Q = _clamp$1(0, F._tDur, G), te = _animationCycle(Q, Z), F._yoyo && te & 1 && (J = 1 - J), te !== _animationCycle(F._tTime, Z) && (K = 1 - J, F.vars.repeatRefresh && F._initted && F.invalidate())), J !== K || _reverting$2 || X || F._zTime === _tinyNum || !G && F._zTime) { if (!F._initted && _attemptInitTween(F, G, X, Y, Q)) return; for (oe = F._zTime, F._zTime = G || (Y ? _tinyNum : 0), Y || (Y = G && !oe), F.ratio = J, F._from && (J = 1 - J), F._time = 0, F._tTime = Q, ee = F._pt; ee;)ee.r(J, ee.d), ee = ee._next; G < 0 && _rewindStartAt(F, G, Y, !0), F._onUpdate && !Y && _callback$1(F, "onUpdate"), Q && F._repeat && !Y && F.parent && _callback$1(F, "onRepeat"), (G >= F._tDur || G < 0) && F.ratio === J && (J && _removeFromParent(F, 1), !Y && !_reverting$2 && (_callback$1(F, J ? "onComplete" : "onReverseComplete", !0), F._prom && F._prom())) } else F._zTime || (F._zTime = G) }, _findNextPauseTween = function (F, G, Y) { var X; if (Y > G) for (X = F._first; X && X._start <= Y;) { if (X.data === "isPause" && X._start > G) return X; X = X._next } else for (X = F._last; X && X._start >= Y;) { if (X.data === "isPause" && X._start < G) return X; X = X._prev } }, _setDuration = function (F, G, Y, X) { var K = F._repeat, J = _roundPrecise(G) || 0, Z = F._tTime / F._tDur; return Z && !X && (F._time *= J / F._dur), F._dur = J, F._tDur = K ? K < 0 ? 1e10 : _roundPrecise(J * (K + 1) + F._rDelay * K) : J, Z > 0 && !X && _alignPlayhead(F, F._tTime = F._tDur * Z), F.parent && _setEnd(F), Y || _uncache(F.parent, F), F }, _onUpdateTotalDuration = function (F) { return F instanceof Timeline ? _uncache(F) : _setDuration(F, F._dur) }, _zeroPosition = { _start: 0, endTime: _emptyFunc, totalDuration: _emptyFunc }, _parsePosition$1 = function z(F, G, Y) { var X = F.labels, K = F._recent || _zeroPosition, J = F.duration() >= _bigNum$2 ? K.endTime(!1) : F._dur, Z, Q, ee; return _isString$2(G) && (isNaN(G) || G in X) ? (Q = G.charAt(0), ee = G.substr(-1) === "%", Z = G.indexOf("="), Q === "<" || Q === ">" ? (Z >= 0 && (G = G.replace(/=/, "")), (Q === "<" ? K._start : K.endTime(K._repeat >= 0)) + (parseFloat(G.substr(1)) || 0) * (ee ? (Z < 0 ? K : Y).totalDuration() / 100 : 1)) : Z < 0 ? (G in X || (X[G] = J), X[G]) : (Q = parseFloat(G.charAt(Z - 1) + G.substr(Z + 1)), ee && Y && (Q = Q / 100 * (_isArray(Y) ? Y[0] : Y).totalDuration()), Z > 1 ? z(F, G.substr(0, Z - 1), Y) + Q : J + Q)) : G == null ? J : +G }, _createTweenType = function (F, G, Y) { var X = _isNumber$2(G[1]), K = (X ? 2 : 1) + (F < 2 ? 0 : 1), J = G[K], Z, Q; if (X && (J.duration = G[1]), J.parent = Y, F) { for (Z = J, Q = Y; Q && !("immediateRender" in Z);)Z = Q.vars.defaults || {}, Q = _isNotFalse(Q.vars.inherit) && Q.parent; J.immediateRender = _isNotFalse(Z.immediateRender), F < 2 ? J.runBackwards = 1 : J.startAt = G[K - 1] } return new Tween(G[0], J, G[K + 1]) }, _conditionalReturn = function (F, G) { return F || F === 0 ? G(F) : G }, _clamp$1 = function (F, G, Y) { return Y < F ? F : Y > G ? G : Y }, getUnit = function (F, G) { return !_isString$2(F) || !(G = _unitExp.exec(F)) ? "" : G[1] }, clamp$1 = function (F, G, Y) { return _conditionalReturn(Y, function (X) { return _clamp$1(F, G, X) }) }, _slice = [].slice, _isArrayLike = function (F, G) { return F && _isObject$1(F) && "length" in F && (!G && !F.length || F.length - 1 in F && _isObject$1(F[0])) && !F.nodeType && F !== _win$5 }, _flatten = function (F, G, Y) { return Y === void 0 && (Y = []), F.forEach(function (X) { var K; return _isString$2(X) && !G || _isArrayLike(X, 1) ? (K = Y).push.apply(K, toArray(X)) : Y.push(X) }) || Y }, toArray = function (F, G, Y) { return _context$3 && !G && _context$3.selector ? _context$3.selector(F) : _isString$2(F) && !Y && (_coreInitted$7 || !_wake()) ? _slice.call((G || _doc$4).querySelectorAll(F), 0) : _isArray(F) ? _flatten(F, Y) : _isArrayLike(F) ? _slice.call(F, 0) : F ? [F] : [] }, selector = function (F) { return F = toArray(F)[0] || _warn$1("Invalid scope") || {}, function (G) { var Y = F.current || F.nativeElement || F; return toArray(G, Y.querySelectorAll ? Y : Y === F ? _warn$1("Invalid scope") || _doc$4.createElement("div") : F) } }, shuffle = function (F) { return F.sort(function () { return .5 - Math.random() }) }, distribute = function (F) { if (_isFunction$2(F)) return F; var G = _isObject$1(F) ? F : { each: F }, Y = _parseEase(G.ease), X = G.from || 0, K = parseFloat(G.base) || 0, J = {}, Z = X > 0 && X < 1, Q = isNaN(X) || Z, ee = G.axis, te = X, oe = X; return _isString$2(X) ? te = oe = { center: .5, edges: .5, end: 1 }[X] || 0 : !Z && Q && (te = X[0], oe = X[1]), function (ie, se, ne) { var re = (ne || G).length, fe = J[re], ae, he, le, ce, ue, me, ge, ve, Se; if (!fe) { if (Se = G.grid === "auto" ? 0 : (G.grid || [1, _bigNum$2])[1], !Se) { for (ge = -1e8; ge < (ge = ne[Se++].getBoundingClientRect().left) && Se < re;); Se < re && Se-- } for (fe = J[re] = [], ae = Q ? Math.min(Se, re) * te - .5 : X % Se, he = Se === _bigNum$2 ? 0 : Q ? re * oe / Se - .5 : X / Se | 0, ge = 0, ve = _bigNum$2, me = 0; me < re; me++)le = me % Se - ae, ce = he - (me / Se | 0), fe[me] = ue = ee ? Math.abs(ee === "y" ? ce : le) : _sqrt$2(le * le + ce * ce), ue > ge && (ge = ue), ue < ve && (ve = ue); X === "random" && shuffle(fe), fe.max = ge - ve, fe.min = ve, fe.v = re = (parseFloat(G.amount) || parseFloat(G.each) * (Se > re ? re - 1 : ee ? ee === "y" ? re / Se : Se : Math.max(Se, re / Se)) || 0) * (X === "edges" ? -1 : 1), fe.b = re < 0 ? K - re : K, fe.u = getUnit(G.amount || G.each) || 0, Y = Y && re < 0 ? _invertEase(Y) : Y } return re = (fe[ie] - fe.min) / fe.max || 0, _roundPrecise(fe.b + (Y ? Y(re) : re) * fe.v) + fe.u } }, _roundModifier = function (F) { var G = Math.pow(10, ((F + "").split(".")[1] || "").length); return function (Y) { var X = _roundPrecise(Math.round(parseFloat(Y) / F) * F * G); return (X - X % 1) / G + (_isNumber$2(Y) ? 0 : getUnit(Y)) } }, snap = function (F, G) { var Y = _isArray(F), X, K; return !Y && _isObject$1(F) && (X = Y = F.radius || _bigNum$2, F.values ? (F = toArray(F.values), (K = !_isNumber$2(F[0])) && (X *= X)) : F = _roundModifier(F.increment)), _conditionalReturn(G, Y ? _isFunction$2(F) ? function (J) { return K = F(J), Math.abs(K - J) <= X ? K : J } : function (J) { for (var Z = parseFloat(K ? J.x : J), Q = parseFloat(K ? J.y : 0), ee = _bigNum$2, te = 0, oe = F.length, ie, se; oe--;)K ? (ie = F[oe].x - Z, se = F[oe].y - Q, ie = ie * ie + se * se) : ie = Math.abs(F[oe] - Z), ie < ee && (ee = ie, te = oe); return te = !X || ee <= X ? F[te] : J, K || te === J || _isNumber$2(J) ? te : te + getUnit(J) } : _roundModifier(F)) }, random = function (F, G, Y, X) { return _conditionalReturn(_isArray(F) ? !G : Y === !0 ? !!(Y = 0) : !X, function () { return _isArray(F) ? F[~~(Math.random() * F.length)] : (Y = Y || 1e-5) && (X = Y < 1 ? Math.pow(10, (Y + "").length - 2) : 1) && Math.floor(Math.round((F - Y / 2 + Math.random() * (G - F + Y * .99)) / Y) * Y * X) / X }) }, pipe = function () { for (var F = arguments.length, G = new Array(F), Y = 0; Y < F; Y++)G[Y] = arguments[Y]; return function (X) { return G.reduce(function (K, J) { return J(K) }, X) } }, unitize = function (F, G) { return function (Y) { return F(parseFloat(Y)) + (G || getUnit(Y)) } }, normalize = function (F, G, Y) { return mapRange(F, G, 0, 1, Y) }, _wrapArray = function (F, G, Y) { return _conditionalReturn(Y, function (X) { return F[~~G(X)] }) }, wrap = function z(F, G, Y) { var X = G - F; return _isArray(F) ? _wrapArray(F, z(0, F.length), G) : _conditionalReturn(Y, function (K) { return (X + (K - F) % X) % X + F }) }, wrapYoyo = function z(F, G, Y) { var X = G - F, K = X * 2; return _isArray(F) ? _wrapArray(F, z(0, F.length - 1), G) : _conditionalReturn(Y, function (J) { return J = (K + (J - F) % K) % K || 0, F + (J > X ? K - J : J) }) }, _replaceRandom = function (F) { for (var G = 0, Y = "", X, K, J, Z; ~(X = F.indexOf("random(", G));)J = F.indexOf(")", X), Z = F.charAt(X + 7) === "[", K = F.substr(X + 7, J - X - 7).match(Z ? _delimitedValueExp : _strictNumExp), Y += F.substr(G, X - G) + random(Z ? K : +K[0], Z ? 0 : +K[1], +K[2] || 1e-5), G = J + 1; return Y + F.substr(G, F.length - G) }, mapRange = function (F, G, Y, X, K) { var J = G - F, Z = X - Y; return _conditionalReturn(K, function (Q) { return Y + ((Q - F) / J * Z || 0) }) }, interpolate = function z(F, G, Y, X) { var K = isNaN(F + G) ? 0 : function (se) { return (1 - se) * F + se * G }; if (!K) { var J = _isString$2(F), Z = {}, Q, ee, te, oe, ie; if (Y === !0 && (X = 1) && (Y = null), J) F = { p: F }, G = { p: G }; else if (_isArray(F) && !_isArray(G)) { for (te = [], oe = F.length, ie = oe - 2, ee = 1; ee < oe; ee++)te.push(z(F[ee - 1], F[ee])); oe--, K = function (ne) { ne *= oe; var re = Math.min(ie, ~~ne); return te[re](ne - re) }, Y = G } else X || (F = _merge(_isArray(F) ? [] : {}, F)); if (!te) { for (Q in G) _addPropTween.call(Z, F, Q, "get", G[Q]); K = function (ne) { return _renderPropTweens(ne, Z) || (J ? F.p : F) } } } return _conditionalReturn(Y, K) }, _getLabelInDirection = function (F, G, Y) { var X = F.labels, K = _bigNum$2, J, Z, Q; for (J in X) Z = X[J] - G, Z < 0 == !!Y && Z && K > (Z = Math.abs(Z)) && (Q = J, K = Z); return Q }, _callback$1 = function (F, G, Y) { var X = F.vars, K = X[G], J = _context$3, Z = F._ctx, Q, ee, te; if (K) return Q = X[G + "Params"], ee = X.callbackScope || F, Y && _lazyTweens.length && _lazyRender(), Z && (_context$3 = Z), te = Q ? K.apply(ee, Q) : K.call(ee), _context$3 = J, te }, _interrupt = function (F) { return _removeFromParent(F), F.scrollTrigger && F.scrollTrigger.kill(!!_reverting$2), F.progress() < 1 && _callback$1(F, "onInterrupt"), F }, _quickTween, _registerPluginQueue = [], _createPlugin = function (F) { if (F) if (F = !F.name && F.default || F, _windowExists$4() || F.headless) { var G = F.name, Y = _isFunction$2(F), X = G && !Y && F.init ? function () { this._props = [] } : F, K = { init: _emptyFunc, render: _renderPropTweens, add: _addPropTween, kill: _killPropTweensOf, modifier: _addPluginModifier, rawVars: 0 }, J = { targetTest: 0, get: 0, getSetter: _getSetter, aliases: {}, register: 0 }; if (_wake(), F !== X) { if (_plugins[G]) return; _setDefaults$1(X, _setDefaults$1(_copyExcluding(F, K), J)), _merge(X.prototype, _merge(K, _copyExcluding(F, J))), _plugins[X.prop = G] = X, F.targetTest && (_harnessPlugins.push(X), _reservedProps[G] = 1), G = (G === "css" ? "CSS" : G.charAt(0).toUpperCase() + G.substr(1)) + "Plugin" } _addGlobal(G, X), F.register && F.register(gsap$8, X, PropTween) } else _registerPluginQueue.push(F) }, _255 = 255, _colorLookup = { aqua: [0, _255, _255], lime: [0, _255, 0], silver: [192, 192, 192], black: [0, 0, 0], maroon: [128, 0, 0], teal: [0, 128, 128], blue: [0, 0, _255], navy: [0, 0, 128], white: [_255, _255, _255], olive: [128, 128, 0], yellow: [_255, _255, 0], orange: [_255, 165, 0], gray: [128, 128, 128], purple: [128, 0, 128], green: [0, 128, 0], red: [_255, 0, 0], pink: [_255, 192, 203], cyan: [0, _255, _255], transparent: [_255, _255, _255, 0] }, _hue = function (F, G, Y) { return F += F < 0 ? 1 : F > 1 ? -1 : 0, (F * 6 < 1 ? G + (Y - G) * F * 6 : F < .5 ? Y : F * 3 < 2 ? G + (Y - G) * (2 / 3 - F) * 6 : G) * _255 + .5 | 0 }, splitColor = function (F, G, Y) { var X = F ? _isNumber$2(F) ? [F >> 16, F >> 8 & _255, F & _255] : 0 : _colorLookup.black, K, J, Z, Q, ee, te, oe, ie, se, ne; if (!X) { if (F.substr(-1) === "," && (F = F.substr(0, F.length - 1)), _colorLookup[F]) X = _colorLookup[F]; else if (F.charAt(0) === "#") { if (F.length < 6 && (K = F.charAt(1), J = F.charAt(2), Z = F.charAt(3), F = "#" + K + K + J + J + Z + Z + (F.length === 5 ? F.charAt(4) + F.charAt(4) : "")), F.length === 9) return X = parseInt(F.substr(1, 6), 16), [X >> 16, X >> 8 & _255, X & _255, parseInt(F.substr(7), 16) / 255]; F = parseInt(F.substr(1), 16), X = [F >> 16, F >> 8 & _255, F & _255] } else if (F.substr(0, 3) === "hsl") { if (X = ne = F.match(_strictNumExp), !G) Q = +X[0] % 360 / 360, ee = +X[1] / 100, te = +X[2] / 100, J = te <= .5 ? te * (ee + 1) : te + ee - te * ee, K = te * 2 - J, X.length > 3 && (X[3] *= 1), X[0] = _hue(Q + 1 / 3, K, J), X[1] = _hue(Q, K, J), X[2] = _hue(Q - 1 / 3, K, J); else if (~F.indexOf("=")) return X = F.match(_numExp$2), Y && X.length < 4 && (X[3] = 1), X } else X = F.match(_strictNumExp) || _colorLookup.transparent; X = X.map(Number) } return G && !ne && (K = X[0] / _255, J = X[1] / _255, Z = X[2] / _255, oe = Math.max(K, J, Z), ie = Math.min(K, J, Z), te = (oe + ie) / 2, oe === ie ? Q = ee = 0 : (se = oe - ie, ee = te > .5 ? se / (2 - oe - ie) : se / (oe + ie), Q = oe === K ? (J - Z) / se + (J < Z ? 6 : 0) : oe === J ? (Z - K) / se + 2 : (K - J) / se + 4, Q *= 60), X[0] = ~~(Q + .5), X[1] = ~~(ee * 100 + .5), X[2] = ~~(te * 100 + .5)), Y && X.length < 4 && (X[3] = 1), X }, _colorOrderData = function (F) { var G = [], Y = [], X = -1; return F.split(_colorExp).forEach(function (K) { var J = K.match(_numWithUnitExp) || []; G.push.apply(G, J), Y.push(X += J.length + 1) }), G.c = Y, G }, _formatColors = function (F, G, Y) { var X = "", K = (F + X).match(_colorExp), J = G ? "hsla(" : "rgba(", Z = 0, Q, ee, te, oe; if (!K) return F; if (K = K.map(function (ie) { return (ie = splitColor(ie, G, 1)) && J + (G ? ie[0] + "," + ie[1] + "%," + ie[2] + "%," + ie[3] : ie.join(",")) + ")" }), Y && (te = _colorOrderData(F), Q = Y.c, Q.join(X) !== te.c.join(X))) for (ee = F.replace(_colorExp, "1").split(_numWithUnitExp), oe = ee.length - 1; Z < oe; Z++)X += ee[Z] + (~Q.indexOf(Z) ? K.shift() || J + "0,0,0,0)" : (te.length ? te : K.length ? K : Y).shift()); if (!ee) for (ee = F.split(_colorExp), oe = ee.length - 1; Z < oe; Z++)X += ee[Z] + K[Z]; return X + ee[oe] }, _colorExp = function () { var z = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", F; for (F in _colorLookup) z += "|" + F + "\\b"; return new RegExp(z + ")", "gi") }(), _hslExp = /hsl[a]?\(/, _colorStringFilter = function (F) { var G = F.join(" "), Y; if (_colorExp.lastIndex = 0, _colorExp.test(G)) return Y = _hslExp.test(G), F[1] = _formatColors(F[1], Y), F[0] = _formatColors(F[0], Y, _colorOrderData(F[1])), !0 }, _tickerActive, _ticker = function () { var z = Date.now, F = 500, G = 33, Y = z(), X = Y, K = 1e3 / 240, J = K, Z = [], Q, ee, te, oe, ie, se, ne = function re(fe) { var ae = z() - X, he = fe === !0, le, ce, ue, me; if ((ae > F || ae < 0) && (Y += ae - G), X += ae, ue = X - Y, le = ue - J, (le > 0 || he) && (me = ++oe.frame, ie = ue - oe.time * 1e3, oe.time = ue = ue / 1e3, J += le + (le >= K ? 4 : K - le), ce = 1), he || (Q = ee(re)), ce) for (se = 0; se < Z.length; se++)Z[se](ue, ie, me, fe) }; return oe = { time: 0, frame: 0, tick: function () { ne(!0) }, deltaRatio: function (fe) { return ie / (1e3 / (fe || 60)) }, wake: function () { _coreReady && (!_coreInitted$7 && _windowExists$4() && (_win$5 = _coreInitted$7 = window, _doc$4 = _win$5.document || {}, _globals.gsap = gsap$8, (_win$5.gsapVersions || (_win$5.gsapVersions = [])).push(gsap$8.version), _install(_installScope || _win$5.GreenSockGlobals || !_win$5.gsap && _win$5 || {}), _registerPluginQueue.forEach(_createPlugin)), te = typeof requestAnimationFrame < "u" && requestAnimationFrame, Q && oe.sleep(), ee = te || function (fe) { return setTimeout(fe, J - oe.time * 1e3 + 1 | 0) }, _tickerActive = 1, ne(2)) }, sleep: function () { (te ? cancelAnimationFrame : clearTimeout)(Q), _tickerActive = 0, ee = _emptyFunc }, lagSmoothing: function (fe, ae) { F = fe || 1 / 0, G = Math.min(ae || 33, F) }, fps: function (fe) { K = 1e3 / (fe || 240), J = oe.time * 1e3 + K }, add: function (fe, ae, he) { var le = ae ? function (ce, ue, me, ge) { fe(ce, ue, me, ge), oe.remove(le) } : fe; return oe.remove(fe), Z[he ? "unshift" : "push"](le), _wake(), le }, remove: function (fe, ae) { ~(ae = Z.indexOf(fe)) && Z.splice(ae, 1) && se >= ae && se-- }, _listeners: Z }, oe }(), _wake = function () { return !_tickerActive && _ticker.wake() }, _easeMap = {}, _customEaseExp = /^[\d.\-M][\d.\-,\s]/, _quotesExp = /["']/g, _parseObjectInString = function (F) { for (var G = {}, Y = F.substr(1, F.length - 3).split(":"), X = Y[0], K = 1, J = Y.length, Z, Q, ee; K < J; K++)Q = Y[K], Z = K !== J - 1 ? Q.lastIndexOf(",") : Q.length, ee = Q.substr(0, Z), G[X] = isNaN(ee) ? ee.replace(_quotesExp, "").trim() : +ee, X = Q.substr(Z + 1).trim(); return G }, _valueInParentheses = function (F) { var G = F.indexOf("(") + 1, Y = F.indexOf(")"), X = F.indexOf("(", G); return F.substring(G, ~X && X < Y ? F.indexOf(")", Y + 1) : Y) }, _configEaseFromString = function (F) { var G = (F + "").split("("), Y = _easeMap[G[0]]; return Y && G.length > 1 && Y.config ? Y.config.apply(null, ~F.indexOf("{") ? [_parseObjectInString(G[1])] : _valueInParentheses(F).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(F) ? _easeMap._CE("", F) : Y }, _invertEase = function (F) { return function (G) { return 1 - F(1 - G) } }, _propagateYoyoEase = function z(F, G) { for (var Y = F._first, X; Y;)Y instanceof Timeline ? z(Y, G) : Y.vars.yoyoEase && (!Y._yoyo || !Y._repeat) && Y._yoyo !== G && (Y.timeline ? z(Y.timeline, G) : (X = Y._ease, Y._ease = Y._yEase, Y._yEase = X, Y._yoyo = G)), Y = Y._next }, _parseEase = function (F, G) { return F && (_isFunction$2(F) ? F : _easeMap[F] || _configEaseFromString(F)) || G }, _insertEase = function (F, G, Y, X) { Y === void 0 && (Y = function (Q) { return 1 - G(1 - Q) }), X === void 0 && (X = function (Q) { return Q < .5 ? G(Q * 2) / 2 : 1 - G((1 - Q) * 2) / 2 }); var K = { easeIn: G, easeOut: Y, easeInOut: X }, J; return _forEachName(F, function (Z) { _easeMap[Z] = _globals[Z] = K, _easeMap[J = Z.toLowerCase()] = Y; for (var Q in K) _easeMap[J + (Q === "easeIn" ? ".in" : Q === "easeOut" ? ".out" : ".inOut")] = _easeMap[Z + "." + Q] = K[Q] }), K }, _easeInOutFromOut = function (F) { return function (G) { return G < .5 ? (1 - F(1 - G * 2)) / 2 : .5 + F((G - .5) * 2) / 2 } }, _configElastic = function z(F, G, Y) { var X = G >= 1 ? G : 1, K = (Y || (F ? .3 : .45)) / (G < 1 ? G : 1), J = K / _2PI * (Math.asin(1 / X) || 0), Z = function (te) { return te === 1 ? 1 : X * Math.pow(2, -10 * te) * _sin$1((te - J) * K) + 1 }, Q = F === "out" ? Z : F === "in" ? function (ee) { return 1 - Z(1 - ee) } : _easeInOutFromOut(Z); return K = _2PI / K, Q.config = function (ee, te) { return z(F, ee, te) }, Q }, _configBack = function z(F, G) { G === void 0 && (G = 1.70158); var Y = function (J) { return J ? --J * J * ((G + 1) * J + G) + 1 : 0 }, X = F === "out" ? Y : F === "in" ? function (K) { return 1 - Y(1 - K) } : _easeInOutFromOut(Y); return X.config = function (K) { return z(F, K) }, X }; _forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function (z, F) { var G = F < 5 ? F + 1 : F; _insertEase(z + ",Power" + (G - 1), F ? function (Y) { return Math.pow(Y, G) } : function (Y) { return Y }, function (Y) { return 1 - Math.pow(1 - Y, G) }, function (Y) { return Y < .5 ? Math.pow(Y * 2, G) / 2 : 1 - Math.pow((1 - Y) * 2, G) / 2 }) }); _easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn; _insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic()); (function (z, F) { var G = 1 / F, Y = 2 * G, X = 2.5 * G, K = function (Z) { return Z < G ? z * Z * Z : Z < Y ? z * Math.pow(Z - 1.5 / F, 2) + .75 : Z < X ? z * (Z -= 2.25 / F) * Z + .9375 : z * Math.pow(Z - 2.625 / F, 2) + .984375 }; _insertEase("Bounce", function (J) { return 1 - K(1 - J) }, K) })(7.5625, 2.75); _insertEase("Expo", function (z) { return Math.pow(2, 10 * (z - 1)) * z + z * z * z * z * z * z * (1 - z) }); _insertEase("Circ", function (z) { return -(_sqrt$2(1 - z * z) - 1) }); _insertEase("Sine", function (z) { return z === 1 ? 1 : -_cos$1(z * _HALF_PI) + 1 }); _insertEase("Back", _configBack("in"), _configBack("out"), _configBack()); _easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = { config: function (F, G) { F === void 0 && (F = 1); var Y = 1 / F, X = F + (G ? 0 : 1), K = G ? 1 : 0, J = 1 - _tinyNum; return function (Z) { return ((X * _clamp$1(0, J, Z) | 0) + K) * Y } } }; _defaults$1.ease = _easeMap["quad.out"]; _forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function (z) { return _callbackNames += z + "," + z + "Params," }); var GSCache = function (F, G) { this.id = _gsID++, F._gsap = this, this.target = F, this.harness = G, this.get = G ? G.get : _getProperty, this.set = G ? G.getSetter : _getSetter }, Animation = function () { function z(G) { this.vars = G, this._delay = +G.delay || 0, (this._repeat = G.repeat === 1 / 0 ? -2 : G.repeat || 0) && (this._rDelay = G.repeatDelay || 0, this._yoyo = !!G.yoyo || !!G.yoyoEase), this._ts = 1, _setDuration(this, +G.duration, 1, 1), this.data = G.data, _context$3 && (this._ctx = _context$3, _context$3.data.push(this)), _tickerActive || _ticker.wake() } var F = z.prototype; return F.delay = function (Y) { return Y || Y === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + Y - this._delay), this._delay = Y, this) : this._delay }, F.duration = function (Y) { return arguments.length ? this.totalDuration(this._repeat > 0 ? Y + (Y + this._rDelay) * this._repeat : Y) : this.totalDuration() && this._dur }, F.totalDuration = function (Y) { return arguments.length ? (this._dirty = 0, _setDuration(this, this._repeat < 0 ? Y : (Y - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur }, F.totalTime = function (Y, X) { if (_wake(), !arguments.length) return this._tTime; var K = this._dp; if (K && K.smoothChildTiming && this._ts) { for (_alignPlayhead(this, Y), !K._dp || K.parent || _postAddChecks(K, this); K && K.parent;)K.parent._time !== K._start + (K._ts >= 0 ? K._tTime / K._ts : (K.totalDuration() - K._tTime) / -K._ts) && K.totalTime(K._tTime, !0), K = K.parent; !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && Y < this._tDur || this._ts < 0 && Y > 0 || !this._tDur && !Y) && _addToTimeline(this._dp, this, this._start - this._delay) } return (this._tTime !== Y || !this._dur && !X || this._initted && Math.abs(this._zTime) === _tinyNum || !Y && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = Y), _lazySafeRender(this, Y, X)), this }, F.time = function (Y, X) { return arguments.length ? this.totalTime(Math.min(this.totalDuration(), Y + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (Y ? this._dur : 0), X) : this._time }, F.totalProgress = function (Y, X) { return arguments.length ? this.totalTime(this.totalDuration() * Y, X) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() >= 0 && this._initted ? 1 : 0 }, F.progress = function (Y, X) { return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - Y : Y) + _elapsedCycleDuration(this), X) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0 }, F.iteration = function (Y, X) { var K = this.duration() + this._rDelay; return arguments.length ? this.totalTime(this._time + (Y - 1) * K, X) : this._repeat ? _animationCycle(this._tTime, K) + 1 : 1 }, F.timeScale = function (Y, X) { if (!arguments.length) return this._rts === -1e-8 ? 0 : this._rts; if (this._rts === Y) return this; var K = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime; return this._rts = +Y || 0, this._ts = this._ps || Y === -1e-8 ? 0 : this._rts, this.totalTime(_clamp$1(-Math.abs(this._delay), this._tDur, K), X !== !1), _setEnd(this), _recacheAncestors(this) }, F.paused = function (Y) { return arguments.length ? (this._ps !== Y && (this._ps = Y, Y ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (_wake(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum)))), this) : this._ps }, F.startTime = function (Y) { if (arguments.length) { this._start = Y; var X = this.parent || this._dp; return X && (X._sort || !this.parent) && _addToTimeline(X, this, Y - this._delay), this } return this._start }, F.endTime = function (Y) { return this._start + (_isNotFalse(Y) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1) }, F.rawTime = function (Y) { var X = this.parent || this._dp; return X ? Y && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? _parentToChildTotalTime(X.rawTime(Y), this) : this._tTime : this._tTime }, F.revert = function (Y) { Y === void 0 && (Y = _revertConfig); var X = _reverting$2; return _reverting$2 = Y, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(Y), this.totalTime(-.01, Y.suppressEvents)), this.data !== "nested" && Y.kill !== !1 && this.kill(), _reverting$2 = X, this }, F.globalTime = function (Y) { for (var X = this, K = arguments.length ? Y : X.rawTime(); X;)K = X._start + K / (Math.abs(X._ts) || 1), X = X._dp; return !this.parent && this._sat ? this._sat.globalTime(Y) : K }, F.repeat = function (Y) { return arguments.length ? (this._repeat = Y === 1 / 0 ? -2 : Y, _onUpdateTotalDuration(this)) : this._repeat === -2 ? 1 / 0 : this._repeat }, F.repeatDelay = function (Y) { if (arguments.length) { var X = this._time; return this._rDelay = Y, _onUpdateTotalDuration(this), X ? this.time(X) : this } return this._rDelay }, F.yoyo = function (Y) { return arguments.length ? (this._yoyo = Y, this) : this._yoyo }, F.seek = function (Y, X) { return this.totalTime(_parsePosition$1(this, Y), _isNotFalse(X)) }, F.restart = function (Y, X) { return this.play().totalTime(Y ? -this._delay : 0, _isNotFalse(X)), this._dur || (this._zTime = -1e-8), this }, F.play = function (Y, X) { return Y != null && this.seek(Y, X), this.reversed(!1).paused(!1) }, F.reverse = function (Y, X) { return Y != null && this.seek(Y || this.totalDuration(), X), this.reversed(!0).paused(!1) }, F.pause = function (Y, X) { return Y != null && this.seek(Y, X), this.paused(!0) }, F.resume = function () { return this.paused(!1) }, F.reversed = function (Y) { return arguments.length ? (!!Y !== this.reversed() && this.timeScale(-this._rts || (Y ? -1e-8 : 0)), this) : this._rts < 0 }, F.invalidate = function () { return this._initted = this._act = 0, this._zTime = -1e-8, this }, F.isActive = function () { var Y = this.parent || this._dp, X = this._start, K; return !!(!Y || this._ts && this._initted && Y.isActive() && (K = Y.rawTime(!0)) >= X && K < this.endTime(!0) - _tinyNum) }, F.eventCallback = function (Y, X, K) { var J = this.vars; return arguments.length > 1 ? (X ? (J[Y] = X, K && (J[Y + "Params"] = K), Y === "onUpdate" && (this._onUpdate = X)) : delete J[Y], this) : J[Y] }, F.then = function (Y) { var X = this; return new Promise(function (K) { var J = _isFunction$2(Y) ? Y : _passThrough$1, Z = function () { var ee = X.then; X.then = null, _isFunction$2(J) && (J = J(X)) && (J.then || J === X) && (X.then = ee), K(J), X.then = ee }; X._initted && X.totalProgress() === 1 && X._ts >= 0 || !X._tTime && X._ts < 0 ? Z() : X._prom = Z }) }, F.kill = function () { _interrupt(this) }, z }(); _setDefaults$1(Animation.prototype, { _time: 0, _start: 0, _end: 0, _tTime: 0, _tDur: 0, _dirty: 0, _repeat: 0, _yoyo: !1, parent: null, _initted: !1, _rDelay: 0, _ts: 1, _dp: 0, ratio: 0, _zTime: -1e-8, _prom: 0, _ps: !1, _rts: 1 }); var Timeline = function (z) { _inheritsLoose(F, z); function F(Y, X) { var K; return Y === void 0 && (Y = {}), K = z.call(this, Y) || this, K.labels = {}, K.smoothChildTiming = !!Y.smoothChildTiming, K.autoRemoveChildren = !!Y.autoRemoveChildren, K._sort = _isNotFalse(Y.sortChildren), _globalTimeline && _addToTimeline(Y.parent || _globalTimeline, _assertThisInitialized(K), X), Y.reversed && K.reverse(), Y.paused && K.paused(!0), Y.scrollTrigger && _scrollTrigger(_assertThisInitialized(K), Y.scrollTrigger), K } var G = F.prototype; return G.to = function (X, K, J) { return _createTweenType(0, arguments, this), this }, G.from = function (X, K, J) { return _createTweenType(1, arguments, this), this }, G.fromTo = function (X, K, J, Z) { return _createTweenType(2, arguments, this), this }, G.set = function (X, K, J) { return K.duration = 0, K.parent = this, _inheritDefaults(K).repeatDelay || (K.repeat = 0), K.immediateRender = !!K.immediateRender, new Tween(X, K, _parsePosition$1(this, J), 1), this }, G.call = function (X, K, J) { return _addToTimeline(this, Tween.delayedCall(0, X, K), J) }, G.staggerTo = function (X, K, J, Z, Q, ee, te) { return J.duration = K, J.stagger = J.stagger || Z, J.onComplete = ee, J.onCompleteParams = te, J.parent = this, new Tween(X, J, _parsePosition$1(this, Q)), this }, G.staggerFrom = function (X, K, J, Z, Q, ee, te) { return J.runBackwards = 1, _inheritDefaults(J).immediateRender = _isNotFalse(J.immediateRender), this.staggerTo(X, K, J, Z, Q, ee, te) }, G.staggerFromTo = function (X, K, J, Z, Q, ee, te, oe) { return Z.startAt = J, _inheritDefaults(Z).immediateRender = _isNotFalse(Z.immediateRender), this.staggerTo(X, K, Z, Q, ee, te, oe) }, G.render = function (X, K, J) { var Z = this._time, Q = this._dirty ? this.totalDuration() : this._tDur, ee = this._dur, te = X <= 0 ? 0 : _roundPrecise(X), oe = this._zTime < 0 != X < 0 && (this._initted || !ee), ie, se, ne, re, fe, ae, he, le, ce, ue, me, ge; if (this !== _globalTimeline && te > Q && X >= 0 && (te = Q), te !== this._tTime || J || oe) { if (Z !== this._time && ee && (te += this._time - Z, X += this._time - Z), ie = te, ce = this._start, le = this._ts, ae = !le, oe && (ee || (Z = this._zTime), (X || !K) && (this._zTime = X)), this._repeat) { if (me = this._yoyo, fe = ee + this._rDelay, this._repeat < -1 && X < 0) return this.totalTime(fe * 100 + X, K, J); if (ie = _roundPrecise(te % fe), te === Q ? (re = this._repeat, ie = ee) : (ue = _roundPrecise(te / fe), re = ~~ue, re && re === ue && (ie = ee, re--), ie > ee && (ie = ee)), ue = _animationCycle(this._tTime, fe), !Z && this._tTime && ue !== re && this._tTime - ue * fe - this._dur <= 0 && (ue = re), me && re & 1 && (ie = ee - ie, ge = 1), re !== ue && !this._lock) { var ve = me && ue & 1, Se = ve === (me && re & 1); if (re < ue && (ve = !ve), Z = ve ? 0 : te % ee ? ee : te, this._lock = 1, this.render(Z || (ge ? 0 : _roundPrecise(re * fe)), K, !ee)._lock = 0, this._tTime = te, !K && this.parent && _callback$1(this, "onRepeat"), this.vars.repeatRefresh && !ge && (this.invalidate()._lock = 1), Z && Z !== this._time || ae !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this; if (ee = this._dur, Q = this._tDur, Se && (this._lock = 2, Z = ve ? ee : -1e-4, this.render(Z, !0), this.vars.repeatRefresh && !ge && this.invalidate()), this._lock = 0, !this._ts && !ae) return this; _propagateYoyoEase(this, ge) } } if (this._hasPause && !this._forcing && this._lock < 2 && (he = _findNextPauseTween(this, _roundPrecise(Z), _roundPrecise(ie)), he && (te -= ie - (ie = he._start))), this._tTime = te, this._time = ie, this._act = !le, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = X, Z = 0), !Z && ie && !K && !re && (_callback$1(this, "onStart"), this._tTime !== te)) return this; if (ie >= Z && X >= 0) for (se = this._first; se;) { if (ne = se._next, (se._act || ie >= se._start) && se._ts && he !== se) { if (se.parent !== this) return this.render(X, K, J); if (se.render(se._ts > 0 ? (ie - se._start) * se._ts : (se._dirty ? se.totalDuration() : se._tDur) + (ie - se._start) * se._ts, K, J), ie !== this._time || !this._ts && !ae) { he = 0, ne && (te += this._zTime = -1e-8); break } } se = ne } else { se = this._last; for (var ke = X < 0 ? X : ie; se;) { if (ne = se._prev, (se._act || ke <= se._end) && se._ts && he !== se) { if (se.parent !== this) return this.render(X, K, J); if (se.render(se._ts > 0 ? (ke - se._start) * se._ts : (se._dirty ? se.totalDuration() : se._tDur) + (ke - se._start) * se._ts, K, J || _reverting$2 && (se._initted || se._startAt)), ie !== this._time || !this._ts && !ae) { he = 0, ne && (te += this._zTime = ke ? -1e-8 : _tinyNum); break } } se = ne } } if (he && !K && (this.pause(), he.render(ie >= Z ? 0 : -1e-8)._zTime = ie >= Z ? 1 : -1, this._ts)) return this._start = ce, _setEnd(this), this.render(X, K, J); this._onUpdate && !K && _callback$1(this, "onUpdate", !0), (te === Q && this._tTime >= this.totalDuration() || !te && Z) && (ce === this._start || Math.abs(le) !== Math.abs(this._ts)) && (this._lock || ((X || !ee) && (te === Q && this._ts > 0 || !te && this._ts < 0) && _removeFromParent(this, 1), !K && !(X < 0 && !Z) && (te || Z || !Q) && (_callback$1(this, te === Q && X >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(te < Q && this.timeScale() > 0) && this._prom()))) } return this }, G.add = function (X, K) { var J = this; if (_isNumber$2(K) || (K = _parsePosition$1(this, K, X)), !(X instanceof Animation)) { if (_isArray(X)) return X.forEach(function (Z) { return J.add(Z, K) }), this; if (_isString$2(X)) return this.addLabel(X, K); if (_isFunction$2(X)) X = Tween.delayedCall(0, X); else return this } return this !== X ? _addToTimeline(this, X, K) : this }, G.getChildren = function (X, K, J, Z) { X === void 0 && (X = !0), K === void 0 && (K = !0), J === void 0 && (J = !0), Z === void 0 && (Z = -1e8); for (var Q = [], ee = this._first; ee;)ee._start >= Z && (ee instanceof Tween ? K && Q.push(ee) : (J && Q.push(ee), X && Q.push.apply(Q, ee.getChildren(!0, K, J)))), ee = ee._next; return Q }, G.getById = function (X) { for (var K = this.getChildren(1, 1, 1), J = K.length; J--;)if (K[J].vars.id === X) return K[J] }, G.remove = function (X) { return _isString$2(X) ? this.removeLabel(X) : _isFunction$2(X) ? this.killTweensOf(X) : (X.parent === this && _removeLinkedListItem(this, X), X === this._recent && (this._recent = this._last), _uncache(this)) }, G.totalTime = function (X, K) { return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? X / this._ts : (this.totalDuration() - X) / -this._ts))), z.prototype.totalTime.call(this, X, K), this._forcing = 0, this) : this._tTime }, G.addLabel = function (X, K) { return this.labels[X] = _parsePosition$1(this, K), this }, G.removeLabel = function (X) { return delete this.labels[X], this }, G.addPause = function (X, K, J) { var Z = Tween.delayedCall(0, K || _emptyFunc, J); return Z.data = "isPause", this._hasPause = 1, _addToTimeline(this, Z, _parsePosition$1(this, X)) }, G.removePause = function (X) { var K = this._first; for (X = _parsePosition$1(this, X); K;)K._start === X && K.data === "isPause" && _removeFromParent(K), K = K._next }, G.killTweensOf = function (X, K, J) { for (var Z = this.getTweensOf(X, J), Q = Z.length; Q--;)_overwritingTween !== Z[Q] && Z[Q].kill(X, K); return this }, G.getTweensOf = function (X, K) { for (var J = [], Z = toArray(X), Q = this._first, ee = _isNumber$2(K), te; Q;)Q instanceof Tween ? _arrayContainsAny(Q._targets, Z) && (ee ? (!_overwritingTween || Q._initted && Q._ts) && Q.globalTime(0) <= K && Q.globalTime(Q.totalDuration()) > K : !K || Q.isActive()) && J.push(Q) : (te = Q.getTweensOf(Z, K)).length && J.push.apply(J, te), Q = Q._next; return J }, G.tweenTo = function (X, K) { K = K || {}; var J = this, Z = _parsePosition$1(J, X), Q = K, ee = Q.startAt, te = Q.onStart, oe = Q.onStartParams, ie = Q.immediateRender, se, ne = Tween.to(J, _setDefaults$1({ ease: K.ease || "none", lazy: !1, immediateRender: !1, time: Z, overwrite: "auto", duration: K.duration || Math.abs((Z - (ee && "time" in ee ? ee.time : J._time)) / J.timeScale()) || _tinyNum, onStart: function () { if (J.pause(), !se) { var fe = K.duration || Math.abs((Z - (ee && "time" in ee ? ee.time : J._time)) / J.timeScale()); ne._dur !== fe && _setDuration(ne, fe, 0, 1).render(ne._time, !0, !0), se = 1 } te && te.apply(ne, oe || []) } }, K)); return ie ? ne.render(0) : ne }, G.tweenFromTo = function (X, K, J) { return this.tweenTo(K, _setDefaults$1({ startAt: { time: _parsePosition$1(this, X) } }, J)) }, G.recent = function () { return this._recent }, G.nextLabel = function (X) { return X === void 0 && (X = this._time), _getLabelInDirection(this, _parsePosition$1(this, X)) }, G.previousLabel = function (X) { return X === void 0 && (X = this._time), _getLabelInDirection(this, _parsePosition$1(this, X), 1) }, G.currentLabel = function (X) { return arguments.length ? this.seek(X, !0) : this.previousLabel(this._time + _tinyNum) }, G.shiftChildren = function (X, K, J) { J === void 0 && (J = 0); for (var Z = this._first, Q = this.labels, ee; Z;)Z._start >= J && (Z._start += X, Z._end += X), Z = Z._next; if (K) for (ee in Q) Q[ee] >= J && (Q[ee] += X); return _uncache(this) }, G.invalidate = function (X) { var K = this._first; for (this._lock = 0; K;)K.invalidate(X), K = K._next; return z.prototype.invalidate.call(this, X) }, G.clear = function (X) { X === void 0 && (X = !0); for (var K = this._first, J; K;)J = K._next, this.remove(K), K = J; return this._dp && (this._time = this._tTime = this._pTime = 0), X && (this.labels = {}), _uncache(this) }, G.totalDuration = function (X) { var K = 0, J = this, Z = J._last, Q = _bigNum$2, ee, te, oe; if (arguments.length) return J.timeScale((J._repeat < 0 ? J.duration() : J.totalDuration()) / (J.reversed() ? -X : X)); if (J._dirty) { for (oe = J.parent; Z;)ee = Z._prev, Z._dirty && Z.totalDuration(), te = Z._start, te > Q && J._sort && Z._ts && !J._lock ? (J._lock = 1, _addToTimeline(J, Z, te - Z._delay, 1)._lock = 0) : Q = te, te < 0 && Z._ts && (K -= te, (!oe && !J._dp || oe && oe.smoothChildTiming) && (J._start += te / J._ts, J._time -= te, J._tTime -= te), J.shiftChildren(-te, !1, -1 / 0), Q = 0), Z._end > K && Z._ts && (K = Z._end), Z = ee; _setDuration(J, J === _globalTimeline && J._time > K ? J._time : K, 1, 1), J._dirty = 0 } return J._tDur }, F.updateRoot = function (X) { if (_globalTimeline._ts && (_lazySafeRender(_globalTimeline, _parentToChildTotalTime(X, _globalTimeline)), _lastRenderedFrame = _ticker.frame), _ticker.frame >= _nextGCFrame) { _nextGCFrame += _config$1.autoSleep || 120; var K = _globalTimeline._first; if ((!K || !K._ts) && _config$1.autoSleep && _ticker._listeners.length < 2) { for (; K && !K._ts;)K = K._next; K || _ticker.sleep() } } }, F }(Animation); _setDefaults$1(Timeline.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 }); var _addComplexStringPropTween = function (F, G, Y, X, K, J, Z) { var Q = new PropTween(this._pt, F, G, 0, 1, _renderComplexString, null, K), ee = 0, te = 0, oe, ie, se, ne, re, fe, ae, he; for (Q.b = Y, Q.e = X, Y += "", X += "", (ae = ~X.indexOf("random(")) && (X = _replaceRandom(X)), J && (he = [Y, X], J(he, F, G), Y = he[0], X = he[1]), ie = Y.match(_complexStringNumExp) || []; oe = _complexStringNumExp.exec(X);)ne = oe[0], re = X.substring(ee, oe.index), se ? se = (se + 1) % 5 : re.substr(-5) === "rgba(" && (se = 1), ne !== ie[te++] && (fe = parseFloat(ie[te - 1]) || 0, Q._pt = { _next: Q._pt, p: re || te === 1 ? re : ",", s: fe, c: ne.charAt(1) === "=" ? _parseRelative(fe, ne) - fe : parseFloat(ne) - fe, m: se && se < 4 ? Math.round : 0 }, ee = _complexStringNumExp.lastIndex); return Q.c = ee < X.length ? X.substring(ee, X.length) : "", Q.fp = Z, (_relExp.test(X) || ae) && (Q.e = 0), this._pt = Q, Q }, _addPropTween = function (F, G, Y, X, K, J, Z, Q, ee, te) { _isFunction$2(X) && (X = X(K || 0, F, J)); var oe = F[G], ie = Y !== "get" ? Y : _isFunction$2(oe) ? ee ? F[G.indexOf("set") || !_isFunction$2(F["get" + G.substr(3)]) ? G : "get" + G.substr(3)](ee) : F[G]() : oe, se = _isFunction$2(oe) ? ee ? _setterFuncWithParam : _setterFunc : _setterPlain, ne; if (_isString$2(X) && (~X.indexOf("random(") && (X = _replaceRandom(X)), X.charAt(1) === "=" && (ne = _parseRelative(ie, X) + (getUnit(ie) || 0), (ne || ne === 0) && (X = ne))), !te || ie !== X || _forceAllPropTweens) return !isNaN(ie * X) && X !== "" ? (ne = new PropTween(this._pt, F, G, +ie || 0, X - (ie || 0), typeof oe == "boolean" ? _renderBoolean : _renderPlain, 0, se), ee && (ne.fp = ee), Z && ne.modifier(Z, this, F), this._pt = ne) : (!oe && !(G in F) && _missingPlugin(G, X), _addComplexStringPropTween.call(this, F, G, ie, X, se, Q || _config$1.stringFilter, ee)) }, _processVars = function (F, G, Y, X, K) { if (_isFunction$2(F) && (F = _parseFuncOrString(F, K, G, Y, X)), !_isObject$1(F) || F.style && F.nodeType || _isArray(F) || _isTypedArray(F)) return _isString$2(F) ? _parseFuncOrString(F, K, G, Y, X) : F; var J = {}, Z; for (Z in F) J[Z] = _parseFuncOrString(F[Z], K, G, Y, X); return J }, _checkPlugin = function (F, G, Y, X, K, J) { var Z, Q, ee, te; if (_plugins[F] && (Z = new _plugins[F]).init(K, Z.rawVars ? G[F] : _processVars(G[F], X, K, J, Y), Y, X, J) !== !1 && (Y._pt = Q = new PropTween(Y._pt, K, F, 0, 1, Z.render, Z, 0, Z.priority), Y !== _quickTween)) for (ee = Y._ptLookup[Y._targets.indexOf(K)], te = Z._props.length; te--;)ee[Z._props[te]] = Q; return Z }, _overwritingTween, _forceAllPropTweens, _initTween = function z(F, G, Y) { var X = F.vars, K = X.ease, J = X.startAt, Z = X.immediateRender, Q = X.lazy, ee = X.onUpdate, te = X.runBackwards, oe = X.yoyoEase, ie = X.keyframes, se = X.autoRevert, ne = F._dur, re = F._startAt, fe = F._targets, ae = F.parent, he = ae && ae.data === "nested" ? ae.vars.targets : fe, le = F._overwrite === "auto" && !_suppressOverwrites$1, ce = F.timeline, ue, me, ge, ve, Se, ke, Ce, Ee, De, Pe, Te, ye, xe; if (ce && (!ie || !K) && (K = "none"), F._ease = _parseEase(K, _defaults$1.ease), F._yEase = oe ? _invertEase(_parseEase(oe === !0 ? K : oe, _defaults$1.ease)) : 0, oe && F._yoyo && !F._repeat && (oe = F._yEase, F._yEase = F._ease, F._ease = oe), F._from = !ce && !!X.runBackwards, !ce || ie && !X.stagger) { if (Ee = fe[0] ? _getCache(fe[0]).harness : 0, ye = Ee && X[Ee.prop], ue = _copyExcluding(X, _reservedProps), re && (re._zTime < 0 && re.progress(1), G < 0 && te && Z && !se ? re.render(-1, !0) : re.revert(te && ne ? _revertConfigNoKill : _startAtRevertConfig), re._lazy = 0), J) { if (_removeFromParent(F._startAt = Tween.set(fe, _setDefaults$1({ data: "isStart", overwrite: !1, parent: ae, immediateRender: !0, lazy: !re && _isNotFalse(Q), startAt: null, delay: 0, onUpdate: ee && function () { return _callback$1(F, "onUpdate") }, stagger: 0 }, J))), F._startAt._dp = 0, F._startAt._sat = F, G < 0 && (_reverting$2 || !Z && !se) && F._startAt.revert(_revertConfigNoKill), Z && ne && G <= 0 && Y <= 0) { G && (F._zTime = G); return } } else if (te && ne && !re) { if (G && (Z = !1), ge = _setDefaults$1({ overwrite: !1, data: "isFromStart", lazy: Z && !re && _isNotFalse(Q), immediateRender: Z, stagger: 0, parent: ae }, ue), ye && (ge[Ee.prop] = ye), _removeFromParent(F._startAt = Tween.set(fe, ge)), F._startAt._dp = 0, F._startAt._sat = F, G < 0 && (_reverting$2 ? F._startAt.revert(_revertConfigNoKill) : F._startAt.render(-1, !0)), F._zTime = G, !Z) z(F._startAt, _tinyNum, _tinyNum); else if (!G) return } for (F._pt = F._ptCache = 0, Q = ne && _isNotFalse(Q) || Q && !ne, me = 0; me < fe.length; me++) { if (Se = fe[me], Ce = Se._gsap || _harness(fe)[me]._gsap, F._ptLookup[me] = Pe = {}, _lazyLookup[Ce.id] && _lazyTweens.length && _lazyRender(), Te = he === fe ? me : he.indexOf(Se), Ee && (De = new Ee).init(Se, ye || ue, F, Te, he) !== !1 && (F._pt = ve = new PropTween(F._pt, Se, De.name, 0, 1, De.render, De, 0, De.priority), De._props.forEach(function (pe) { Pe[pe] = ve }), De.priority && (ke = 1)), !Ee || ye) for (ge in ue) _plugins[ge] && (De = _checkPlugin(ge, ue, F, Te, Se, he)) ? De.priority && (ke = 1) : Pe[ge] = ve = _addPropTween.call(F, Se, ge, "get", ue[ge], Te, he, 0, X.stringFilter); F._op && F._op[me] && F.kill(Se, F._op[me]), le && F._pt && (_overwritingTween = F, _globalTimeline.killTweensOf(Se, Pe, F.globalTime(G)), xe = !F.parent, _overwritingTween = 0), F._pt && Q && (_lazyLookup[Ce.id] = 1) } ke && _sortPropTweensByPriority(F), F._onInit && F._onInit(F) } F._onUpdate = ee, F._initted = (!F._op || F._pt) && !xe, ie && G <= 0 && ce.render(_bigNum$2, !0, !0) }, _updatePropTweens = function (F, G, Y, X, K, J, Z, Q) { var ee = (F._pt && F._ptCache || (F._ptCache = {}))[G], te, oe, ie, se; if (!ee) for (ee = F._ptCache[G] = [], ie = F._ptLookup, se = F._targets.length; se--;) { if (te = ie[se][G], te && te.d && te.d._pt) for (te = te.d._pt; te && te.p !== G && te.fp !== G;)te = te._next; if (!te) return _forceAllPropTweens = 1, F.vars[G] = "+=0", _initTween(F, Z), _forceAllPropTweens = 0, Q ? _warn$1(G + " not eligible for reset") : 1; ee.push(te) } for (se = ee.length; se--;)oe = ee[se], te = oe._pt || oe, te.s = (X || X === 0) && !K ? X : te.s + (X || 0) + J * te.c, te.c = Y - te.s, oe.e && (oe.e = _round$4(Y) + getUnit(oe.e)), oe.b && (oe.b = te.s + getUnit(oe.b)) }, _addAliasesToVars = function (F, G) { var Y = F[0] ? _getCache(F[0]).harness : 0, X = Y && Y.aliases, K, J, Z, Q; if (!X) return G; K = _merge({}, G); for (J in X) if (J in K) for (Q = X[J].split(","), Z = Q.length; Z--;)K[Q[Z]] = K[J]; return K }, _parseKeyframe = function (F, G, Y, X) { var K = G.ease || X || "power1.inOut", J, Z; if (_isArray(G)) Z = Y[F] || (Y[F] = []), G.forEach(function (Q, ee) { return Z.push({ t: ee / (G.length - 1) * 100, v: Q, e: K }) }); else for (J in G) Z = Y[J] || (Y[J] = []), J === "ease" || Z.push({ t: parseFloat(F), v: G[J], e: K }) }, _parseFuncOrString = function (F, G, Y, X, K) { return _isFunction$2(F) ? F.call(G, Y, X, K) : _isString$2(F) && ~F.indexOf("random(") ? _replaceRandom(F) : F }, _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", _staggerPropsToSkip = {}; _forEachName(_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger", function (z) { return _staggerPropsToSkip[z] = 1 }); var Tween = function (z) { _inheritsLoose(F, z); function F(Y, X, K, J) { var Z; typeof X == "number" && (K.duration = X, X = K, K = null), Z = z.call(this, J ? X : _inheritDefaults(X)) || this; var Q = Z.vars, ee = Q.duration, te = Q.delay, oe = Q.immediateRender, ie = Q.stagger, se = Q.overwrite, ne = Q.keyframes, re = Q.defaults, fe = Q.scrollTrigger, ae = Q.yoyoEase, he = X.parent || _globalTimeline, le = (_isArray(Y) || _isTypedArray(Y) ? _isNumber$2(Y[0]) : "length" in X) ? [Y] : toArray(Y), ce, ue, me, ge, ve, Se, ke, Ce; if (Z._targets = le.length ? _harness(le) : _warn$1("GSAP target " + Y + " not found. https://gsap.com", !_config$1.nullTargetWarn) || [], Z._ptLookup = [], Z._overwrite = se, ne || ie || _isFuncOrString(ee) || _isFuncOrString(te)) { if (X = Z.vars, ce = Z.timeline = new Timeline({ data: "nested", defaults: re || {}, targets: he && he.data === "nested" ? he.vars.targets : le }), ce.kill(), ce.parent = ce._dp = _assertThisInitialized(Z), ce._start = 0, ie || _isFuncOrString(ee) || _isFuncOrString(te)) { if (ge = le.length, ke = ie && distribute(ie), _isObject$1(ie)) for (ve in ie) ~_staggerTweenProps.indexOf(ve) && (Ce || (Ce = {}), Ce[ve] = ie[ve]); for (ue = 0; ue < ge; ue++)me = _copyExcluding(X, _staggerPropsToSkip), me.stagger = 0, ae && (me.yoyoEase = ae), Ce && _merge(me, Ce), Se = le[ue], me.duration = +_parseFuncOrString(ee, _assertThisInitialized(Z), ue, Se, le), me.delay = (+_parseFuncOrString(te, _assertThisInitialized(Z), ue, Se, le) || 0) - Z._delay, !ie && ge === 1 && me.delay && (Z._delay = te = me.delay, Z._start += te, me.delay = 0), ce.to(Se, me, ke ? ke(ue, Se, le) : 0), ce._ease = _easeMap.none; ce.duration() ? ee = te = 0 : Z.timeline = 0 } else if (ne) { _inheritDefaults(_setDefaults$1(ce.vars.defaults, { ease: "none" })), ce._ease = _parseEase(ne.ease || X.ease || "none"); var Ee = 0, De, Pe, Te; if (_isArray(ne)) ne.forEach(function (ye) { return ce.to(le, ye, ">") }), ce.duration(); else { me = {}; for (ve in ne) ve === "ease" || ve === "easeEach" || _parseKeyframe(ve, ne[ve], me, ne.easeEach); for (ve in me) for (De = me[ve].sort(function (ye, xe) { return ye.t - xe.t }), Ee = 0, ue = 0; ue < De.length; ue++)Pe = De[ue], Te = { ease: Pe.e, duration: (Pe.t - (ue ? De[ue - 1].t : 0)) / 100 * ee }, Te[ve] = Pe.v, ce.to(le, Te, Ee), Ee += Te.duration; ce.duration() < ee && ce.to({}, { duration: ee - ce.duration() }) } } ee || Z.duration(ee = ce.duration()) } else Z.timeline = 0; return se === !0 && !_suppressOverwrites$1 && (_overwritingTween = _assertThisInitialized(Z), _globalTimeline.killTweensOf(le), _overwritingTween = 0), _addToTimeline(he, _assertThisInitialized(Z), K), X.reversed && Z.reverse(), X.paused && Z.paused(!0), (oe || !ee && !ne && Z._start === _roundPrecise(he._time) && _isNotFalse(oe) && _hasNoPausedAncestors(_assertThisInitialized(Z)) && he.data !== "nested") && (Z._tTime = -1e-8, Z.render(Math.max(0, -te) || 0)), fe && _scrollTrigger(_assertThisInitialized(Z), fe), Z } var G = F.prototype; return G.render = function (X, K, J) { var Z = this._time, Q = this._tDur, ee = this._dur, te = X < 0, oe = X > Q - _tinyNum && !te ? Q : X < _tinyNum ? 0 : X, ie, se, ne, re, fe, ae, he, le, ce; if (!ee) _renderZeroDurationTween(this, X, K, J); else if (oe !== this._tTime || !X || J || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== te || this._lazy) { if (ie = oe, le = this.timeline, this._repeat) { if (re = ee + this._rDelay, this._repeat < -1 && te) return this.totalTime(re * 100 + X, K, J); if (ie = _roundPrecise(oe % re), oe === Q ? (ne = this._repeat, ie = ee) : (fe = _roundPrecise(oe / re), ne = ~~fe, ne && ne === fe ? (ie = ee, ne--) : ie > ee && (ie = ee)), ae = this._yoyo && ne & 1, ae && (ce = this._yEase, ie = ee - ie), fe = _animationCycle(this._tTime, re), ie === Z && !J && this._initted && ne === fe) return this._tTime = oe, this; ne !== fe && (le && this._yEase && _propagateYoyoEase(le, ae), this.vars.repeatRefresh && !ae && !this._lock && ie !== re && this._initted && (this._lock = J = 1, this.render(_roundPrecise(re * ne), !0).invalidate()._lock = 0)) } if (!this._initted) { if (_attemptInitTween(this, te ? X : ie, J, K, oe)) return this._tTime = 0, this; if (Z !== this._time && !(J && this.vars.repeatRefresh && ne !== fe)) return this; if (ee !== this._dur) return this.render(X, K, J) } if (this._tTime = oe, this._time = ie, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = he = (ce || this._ease)(ie / ee), this._from && (this.ratio = he = 1 - he), ie && !Z && !K && !ne && (_callback$1(this, "onStart"), this._tTime !== oe)) return this; for (se = this._pt; se;)se.r(he, se.d), se = se._next; le && le.render(X < 0 ? X : le._dur * le._ease(ie / this._dur), K, J) || this._startAt && (this._zTime = X), this._onUpdate && !K && (te && _rewindStartAt(this, X, K, J), _callback$1(this, "onUpdate")), this._repeat && ne !== fe && this.vars.onRepeat && !K && this.parent && _callback$1(this, "onRepeat"), (oe === this._tDur || !oe) && this._tTime === oe && (te && !this._onUpdate && _rewindStartAt(this, X, !0, !0), (X || !ee) && (oe === this._tDur && this._ts > 0 || !oe && this._ts < 0) && _removeFromParent(this, 1), !K && !(te && !Z) && (oe || Z || ae) && (_callback$1(this, oe === Q ? "onComplete" : "onReverseComplete", !0), this._prom && !(oe < Q && this.timeScale() > 0) && this._prom())) } return this }, G.targets = function () { return this._targets }, G.invalidate = function (X) { return (!X || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(X), z.prototype.invalidate.call(this, X) }, G.resetTo = function (X, K, J, Z, Q) { _tickerActive || _ticker.wake(), this._ts || this.play(); var ee = Math.min(this._dur, (this._dp._time - this._start) * this._ts), te; return this._initted || _initTween(this, ee), te = this._ease(ee / this._dur), _updatePropTweens(this, X, K, J, Z, te, ee, Q) ? this.resetTo(X, K, J, Z, 1) : (_alignPlayhead(this, 0), this.parent || _addLinkedListItem(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0)) }, G.kill = function (X, K) { if (K === void 0 && (K = "all"), !X && (!K || K === "all")) return this._lazy = this._pt = 0, this.parent ? _interrupt(this) : this.scrollTrigger && this.scrollTrigger.kill(!!_reverting$2), this; if (this.timeline) { var J = this.timeline.totalDuration(); return this.timeline.killTweensOf(X, K, _overwritingTween && _overwritingTween.vars.overwrite !== !0)._first || _interrupt(this), this.parent && J !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / J, 0, 1), this } var Z = this._targets, Q = X ? toArray(X) : Z, ee = this._ptLookup, te = this._pt, oe, ie, se, ne, re, fe, ae; if ((!K || K === "all") && _arraysMatch(Z, Q)) return K === "all" && (this._pt = 0), _interrupt(this); for (oe = this._op = this._op || [], K !== "all" && (_isString$2(K) && (re = {}, _forEachName(K, function (he) { return re[he] = 1 }), K = re), K = _addAliasesToVars(Z, K)), ae = Z.length; ae--;)if (~Q.indexOf(Z[ae])) { ie = ee[ae], K === "all" ? (oe[ae] = K, ne = ie, se = {}) : (se = oe[ae] = oe[ae] || {}, ne = K); for (re in ne) fe = ie && ie[re], fe && ((!("kill" in fe.d) || fe.d.kill(re) === !0) && _removeLinkedListItem(this, fe, "_pt"), delete ie[re]), se !== "all" && (se[re] = 1) } return this._initted && !this._pt && te && _interrupt(this), this }, F.to = function (X, K) { return new F(X, K, arguments[2]) }, F.from = function (X, K) { return _createTweenType(1, arguments) }, F.delayedCall = function (X, K, J, Z) { return new F(K, 0, { immediateRender: !1, lazy: !1, overwrite: !1, delay: X, onComplete: K, onReverseComplete: K, onCompleteParams: J, onReverseCompleteParams: J, callbackScope: Z }) }, F.fromTo = function (X, K, J) { return _createTweenType(2, arguments) }, F.set = function (X, K) { return K.duration = 0, K.repeatDelay || (K.repeat = 0), new F(X, K) }, F.killTweensOf = function (X, K, J) { return _globalTimeline.killTweensOf(X, K, J) }, F }(Animation); _setDefaults$1(Tween.prototype, { _targets: [], _lazy: 0, _startAt: 0, _op: 0, _onInit: 0 }); _forEachName("staggerTo,staggerFrom,staggerFromTo", function (z) { Tween[z] = function () { var F = new Timeline, G = _slice.call(arguments, 0); return G.splice(z === "staggerFromTo" ? 5 : 4, 0, 0), F[z].apply(F, G) } }); var _setterPlain = function (F, G, Y) { return F[G] = Y }, _setterFunc = function (F, G, Y) { return F[G](Y) }, _setterFuncWithParam = function (F, G, Y, X) { return F[G](X.fp, Y) }, _setterAttribute = function (F, G, Y) { return F.setAttribute(G, Y) }, _getSetter = function (F, G) { return _isFunction$2(F[G]) ? _setterFunc : _isUndefined(F[G]) && F.setAttribute ? _setterAttribute : _setterPlain }, _renderPlain = function (F, G) { return G.set(G.t, G.p, Math.round((G.s + G.c * F) * 1e6) / 1e6, G) }, _renderBoolean = function (F, G) { return G.set(G.t, G.p, !!(G.s + G.c * F), G) }, _renderComplexString = function (F, G) { var Y = G._pt, X = ""; if (!F && G.b) X = G.b; else if (F === 1 && G.e) X = G.e; else { for (; Y;)X = Y.p + (Y.m ? Y.m(Y.s + Y.c * F) : Math.round((Y.s + Y.c * F) * 1e4) / 1e4) + X, Y = Y._next; X += G.c } G.set(G.t, G.p, X, G) }, _renderPropTweens = function (F, G) { for (var Y = G._pt; Y;)Y.r(F, Y.d), Y = Y._next }, _addPluginModifier = function (F, G, Y, X) { for (var K = this._pt, J; K;)J = K._next, K.p === X && K.modifier(F, G, Y), K = J }, _killPropTweensOf = function (F) { for (var G = this._pt, Y, X; G;)X = G._next, G.p === F && !G.op || G.op === F ? _removeLinkedListItem(this, G, "_pt") : G.dep || (Y = 1), G = X; return !Y }, _setterWithModifier = function (F, G, Y, X) { X.mSet(F, G, X.m.call(X.tween, Y, X.mt), X) }, _sortPropTweensByPriority = function (F) { for (var G = F._pt, Y, X, K, J; G;) { for (Y = G._next, X = K; X && X.pr > G.pr;)X = X._next; (G._prev = X ? X._prev : J) ? G._prev._next = G : K = G, (G._next = X) ? X._prev = G : J = G, G = Y } F._pt = K }, PropTween = function () { function z(G, Y, X, K, J, Z, Q, ee, te) { this.t = Y, this.s = K, this.c = J, this.p = X, this.r = Z || _renderPlain, this.d = Q || this, this.set = ee || _setterPlain, this.pr = te || 0, this._next = G, G && (G._prev = this) } var F = z.prototype; return F.modifier = function (Y, X, K) { this.mSet = this.mSet || this.set, this.set = _setterWithModifier, this.m = Y, this.mt = K, this.tween = X }, z }(); _forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function (z) { return _reservedProps[z] = 1 }); _globals.TweenMax = _globals.TweenLite = Tween; _globals.TimelineLite = _globals.TimelineMax = Timeline; _globalTimeline = new Timeline({ sortChildren: !1, defaults: _defaults$1, autoRemoveChildren: !0, id: "root", smoothChildTiming: !0 }); _config$1.stringFilter = _colorStringFilter; var _media = [], _listeners$1 = {}, _emptyArray$1 = [], _lastMediaTime = 0, _contextID = 0, _dispatch$1 = function (F) { return (_listeners$1[F] || _emptyArray$1).map(function (G) { return G() }) }, _onMediaChange = function () { var F = Date.now(), G = []; F - _lastMediaTime > 2 && (_dispatch$1("matchMediaInit"), _media.forEach(function (Y) { var X = Y.queries, K = Y.conditions, J, Z, Q, ee; for (Z in X) J = _win$5.matchMedia(X[Z]).matches, J && (Q = 1), J !== K[Z] && (K[Z] = J, ee = 1); ee && (Y.revert(), Q && G.push(Y)) }), _dispatch$1("matchMediaRevert"), G.forEach(function (Y) { return Y.onMatch(Y, function (X) { return Y.add(null, X) }) }), _lastMediaTime = F, _dispatch$1("matchMedia")) }, Context = function () { function z(G, Y) { this.selector = Y && selector(Y), this.data = [], this._r = [], this.isReverted = !1, this.id = _contextID++, G && this.add(G) } var F = z.prototype; return F.add = function (Y, X, K) { _isFunction$2(Y) && (K = X, X = Y, Y = _isFunction$2); var J = this, Z = function () { var ee = _context$3, te = J.selector, oe; return ee && ee !== J && ee.data.push(J), K && (J.selector = selector(K)), _context$3 = J, oe = X.apply(J, arguments), _isFunction$2(oe) && J._r.push(oe), _context$3 = ee, J.selector = te, J.isReverted = !1, oe }; return J.last = Z, Y === _isFunction$2 ? Z(J, function (Q) { return J.add(null, Q) }) : Y ? J[Y] = Z : Z }, F.ignore = function (Y) { var X = _context$3; _context$3 = null, Y(this), _context$3 = X }, F.getTweens = function () { var Y = []; return this.data.forEach(function (X) { return X instanceof z ? Y.push.apply(Y, X.getTweens()) : X instanceof Tween && !(X.parent && X.parent.data === "nested") && Y.push(X) }), Y }, F.clear = function () { this._r.length = this.data.length = 0 }, F.kill = function (Y, X) { var K = this; if (Y ? function () { for (var Z = K.getTweens(), Q = K.data.length, ee; Q--;)ee = K.data[Q], ee.data === "isFlip" && (ee.revert(), ee.getChildren(!0, !0, !1).forEach(function (te) { return Z.splice(Z.indexOf(te), 1) })); for (Z.map(function (te) { return { g: te._dur || te._delay || te._sat && !te._sat.vars.immediateRender ? te.globalTime(0) : -1 / 0, t: te } }).sort(function (te, oe) { return oe.g - te.g || -1 / 0 }).forEach(function (te) { return te.t.revert(Y) }), Q = K.data.length; Q--;)ee = K.data[Q], ee instanceof Timeline ? ee.data !== "nested" && (ee.scrollTrigger && ee.scrollTrigger.revert(), ee.kill()) : !(ee instanceof Tween) && ee.revert && ee.revert(Y); K._r.forEach(function (te) { return te(Y, K) }), K.isReverted = !0 }() : this.data.forEach(function (Z) { return Z.kill && Z.kill() }), this.clear(), X) for (var J = _media.length; J--;)_media[J].id === this.id && _media.splice(J, 1) }, F.revert = function (Y) { this.kill(Y || {}) }, z }(), MatchMedia = function () { function z(G) { this.contexts = [], this.scope = G, _context$3 && _context$3.data.push(this) } var F = z.prototype; return F.add = function (Y, X, K) { _isObject$1(Y) || (Y = { matches: Y }); var J = new Context(0, K || this.scope), Z = J.conditions = {}, Q, ee, te; _context$3 && !J.selector && (J.selector = _context$3.selector), this.contexts.push(J), X = J.add("onMatch", X), J.queries = Y; for (ee in Y) ee === "all" ? te = 1 : (Q = _win$5.matchMedia(Y[ee]), Q && (_media.indexOf(J) < 0 && _media.push(J), (Z[ee] = Q.matches) && (te = 1), Q.addListener ? Q.addListener(_onMediaChange) : Q.addEventListener("change", _onMediaChange))); return te && X(J, function (oe) { return J.add(null, oe) }), this }, F.revert = function (Y) { this.kill(Y || {}) }, F.kill = function (Y) { this.contexts.forEach(function (X) { return X.kill(Y, !0) }) }, z }(), _gsap = { registerPlugin: function () { for (var F = arguments.length, G = new Array(F), Y = 0; Y < F; Y++)G[Y] = arguments[Y]; G.forEach(function (X) { return _createPlugin(X) }) }, timeline: function (F) { return new Timeline(F) }, getTweensOf: function (F, G) { return _globalTimeline.getTweensOf(F, G) }, getProperty: function (F, G, Y, X) { _isString$2(F) && (F = toArray(F)[0]); var K = _getCache(F || {}).get, J = Y ? _passThrough$1 : _numericIfPossible; return Y === "native" && (Y = ""), F && (G ? J((_plugins[G] && _plugins[G].get || K)(F, G, Y, X)) : function (Z, Q, ee) { return J((_plugins[Z] && _plugins[Z].get || K)(F, Z, Q, ee)) }) }, quickSetter: function (F, G, Y) { if (F = toArray(F), F.length > 1) { var X = F.map(function (te) { return gsap$8.quickSetter(te, G, Y) }), K = X.length; return function (te) { for (var oe = K; oe--;)X[oe](te) } } F = F[0] || {}; var J = _plugins[G], Z = _getCache(F), Q = Z.harness && (Z.harness.aliases || {})[G] || G, ee = J ? function (te) { var oe = new J; _quickTween._pt = 0, oe.init(F, Y ? te + Y : te, _quickTween, 0, [F]), oe.render(1, oe), _quickTween._pt && _renderPropTweens(1, _quickTween) } : Z.set(F, Q); return J ? ee : function (te) { return ee(F, Q, Y ? te + Y : te, Z, 1) } }, quickTo: function (F, G, Y) { var X, K = gsap$8.to(F, _setDefaults$1((X = {}, X[G] = "+=0.1", X.paused = !0, X.stagger = 0, X), Y || {})), J = function (Q, ee, te) { return K.resetTo(G, Q, ee, te) }; return J.tween = K, J }, isTweening: function (F) { return _globalTimeline.getTweensOf(F, !0).length > 0 }, defaults: function (F) { return F && F.ease && (F.ease = _parseEase(F.ease, _defaults$1.ease)), _mergeDeep(_defaults$1, F || {}) }, config: function (F) { return _mergeDeep(_config$1, F || {}) }, registerEffect: function (F) { var G = F.name, Y = F.effect, X = F.plugins, K = F.defaults, J = F.extendTimeline; (X || "").split(",").forEach(function (Z) { return Z && !_plugins[Z] && !_globals[Z] && _warn$1(G + " effect requires " + Z + " plugin.") }), _effects[G] = function (Z, Q, ee) { return Y(toArray(Z), _setDefaults$1(Q || {}, K), ee) }, J && (Timeline.prototype[G] = function (Z, Q, ee) { return this.add(_effects[G](Z, _isObject$1(Q) ? Q : (ee = Q) && {}, this), ee) }) }, registerEase: function (F, G) { _easeMap[F] = _parseEase(G) }, parseEase: function (F, G) { return arguments.length ? _parseEase(F, G) : _easeMap }, getById: function (F) { return _globalTimeline.getById(F) }, exportRoot: function (F, G) { F === void 0 && (F = {}); var Y = new Timeline(F), X, K; for (Y.smoothChildTiming = _isNotFalse(F.smoothChildTiming), _globalTimeline.remove(Y), Y._dp = 0, Y._time = Y._tTime = _globalTimeline._time, X = _globalTimeline._first; X;)K = X._next, (G || !(!X._dur && X instanceof Tween && X.vars.onComplete === X._targets[0])) && _addToTimeline(Y, X, X._start - X._delay), X = K; return _addToTimeline(_globalTimeline, Y, 0), Y }, context: function (F, G) { return F ? new Context(F, G) : _context$3 }, matchMedia: function (F) { return new MatchMedia(F) }, matchMediaRefresh: function () { return _media.forEach(function (F) { var G = F.conditions, Y, X; for (X in G) G[X] && (G[X] = !1, Y = 1); Y && F.revert() }) || _onMediaChange() }, addEventListener: function (F, G) { var Y = _listeners$1[F] || (_listeners$1[F] = []); ~Y.indexOf(G) || Y.push(G) }, removeEventListener: function (F, G) { var Y = _listeners$1[F], X = Y && Y.indexOf(G); X >= 0 && Y.splice(X, 1) }, utils: { wrap, wrapYoyo, distribute, random, snap, normalize, getUnit, clamp: clamp$1, splitColor, toArray, selector, mapRange, pipe, unitize, interpolate, shuffle }, install: _install, effects: _effects, ticker: _ticker, updateRoot: Timeline.updateRoot, plugins: _plugins, globalTimeline: _globalTimeline, core: { PropTween, globals: _addGlobal, Tween, Timeline, Animation, getCache: _getCache, _removeLinkedListItem, reverting: function () { return _reverting$2 }, context: function (F) { return F && _context$3 && (_context$3.data.push(F), F._ctx = _context$3), _context$3 }, suppressOverwrites: function (F) { return _suppressOverwrites$1 = F } } }; _forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function (z) { return _gsap[z] = Tween[z] }); _ticker.add(Timeline.updateRoot); _quickTween = _gsap.to({}, { duration: 0 }); var _getPluginPropTween = function (F, G) { for (var Y = F._pt; Y && Y.p !== G && Y.op !== G && Y.fp !== G;)Y = Y._next; return Y }, _addModifiers = function (F, G) { var Y = F._targets, X, K, J; for (X in G) for (K = Y.length; K--;)J = F._ptLookup[K][X], J && (J = J.d) && (J._pt && (J = _getPluginPropTween(J, X)), J && J.modifier && J.modifier(G[X], F, Y[K], X)) }, _buildModifierPlugin = function (F, G) { return { name: F, rawVars: 1, init: function (X, K, J) { J._onInit = function (Z) { var Q, ee; if (_isString$2(K) && (Q = {}, _forEachName(K, function (te) { return Q[te] = 1 }), K = Q), G) { Q = {}; for (ee in K) Q[ee] = G(K[ee]); K = Q } _addModifiers(Z, K) } } } }, gsap$8 = _gsap.registerPlugin({ name: "attr", init: function (F, G, Y, X, K) { var J, Z, Q; this.tween = Y; for (J in G) Q = F.getAttribute(J) || "", Z = this.add(F, "setAttribute", (Q || 0) + "", G[J], X, K, 0, 0, J), Z.op = J, Z.b = Q, this._props.push(J) }, render: function (F, G) { for (var Y = G._pt; Y;)_reverting$2 ? Y.set(Y.t, Y.p, Y.b, Y) : Y.r(F, Y.d), Y = Y._next } }, { name: "endArray", init: function (F, G) { for (var Y = G.length; Y--;)this.add(F, Y, F[Y] || 0, G[Y], 0, 0, 0, 0, 0, 1) } }, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap; Tween.version = Timeline.version = gsap$8.version = "3.12.7"; _coreReady = 1; _windowExists$4() && _wake(); _easeMap.Power0; _easeMap.Power1; _easeMap.Power2; _easeMap.Power3; _easeMap.Power4; _easeMap.Linear; _easeMap.Quad; _easeMap.Cubic; _easeMap.Quart; _easeMap.Quint; _easeMap.Strong; _easeMap.Elastic; _easeMap.Back; _easeMap.SteppedEase; _easeMap.Bounce; _easeMap.Sine; _easeMap.Expo; _easeMap.Circ;/*!
 * CSSPlugin 3.12.7
 * https://gsap.com
 *
 * Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/var _win$4, _doc$3, _docElement, _pluginInitted, _tempDiv$1, _recentSetterPlugin, _reverting$1, _windowExists$3 = function () { return typeof window < "u" }, _transformProps = {}, _RAD2DEG = 180 / Math.PI, _DEG2RAD$1 = Math.PI / 180, _atan2 = Math.atan2, _bigNum$1 = 1e8, _capsExp$1 = /([A-Z])/g, _horizontalExp = /(left|right|width|margin|padding|x)/i, _complexExp = /[\s,\(]\S/, _propertyAliases = { autoAlpha: "opacity,visibility", scale: "scaleX,scaleY", alpha: "opacity" }, _renderCSSProp = function (F, G) { return G.set(G.t, G.p, Math.round((G.s + G.c * F) * 1e4) / 1e4 + G.u, G) }, _renderPropWithEnd = function (F, G) { return G.set(G.t, G.p, F === 1 ? G.e : Math.round((G.s + G.c * F) * 1e4) / 1e4 + G.u, G) }, _renderCSSPropWithBeginning = function (F, G) { return G.set(G.t, G.p, F ? Math.round((G.s + G.c * F) * 1e4) / 1e4 + G.u : G.b, G) }, _renderRoundedCSSProp = function (F, G) { var Y = G.s + G.c * F; G.set(G.t, G.p, ~~(Y + (Y < 0 ? -.5 : .5)) + G.u, G) }, _renderNonTweeningValue = function (F, G) { return G.set(G.t, G.p, F ? G.e : G.b, G) }, _renderNonTweeningValueOnlyAtEnd = function (F, G) { return G.set(G.t, G.p, F !== 1 ? G.b : G.e, G) }, _setterCSSStyle = function (F, G, Y) { return F.style[G] = Y }, _setterCSSProp = function (F, G, Y) { return F.style.setProperty(G, Y) }, _setterTransform = function (F, G, Y) { return F._gsap[G] = Y }, _setterScale = function (F, G, Y) { return F._gsap.scaleX = F._gsap.scaleY = Y }, _setterScaleWithRender = function (F, G, Y, X, K) { var J = F._gsap; J.scaleX = J.scaleY = Y, J.renderTransform(K, J) }, _setterTransformWithRender = function (F, G, Y, X, K) { var J = F._gsap; J[G] = Y, J.renderTransform(K, J) }, _transformProp$1 = "transform", _transformOriginProp = _transformProp$1 + "Origin", _saveStyle = function z(F, G) { var Y = this, X = this.target, K = X.style, J = X._gsap; if (F in _transformProps && K) { if (this.tfm = this.tfm || {}, F !== "transform") F = _propertyAliases[F] || F, ~F.indexOf(",") ? F.split(",").forEach(function (Z) { return Y.tfm[Z] = _get(X, Z) }) : this.tfm[F] = J.x ? J[F] : _get(X, F), F === _transformOriginProp && (this.tfm.zOrigin = J.zOrigin); else return _propertyAliases.transform.split(",").forEach(function (Z) { return z.call(Y, Z, G) }); if (this.props.indexOf(_transformProp$1) >= 0) return; J.svg && (this.svgo = X.getAttribute("data-svg-origin"), this.props.push(_transformOriginProp, G, "")), F = _transformProp$1 } (K || G) && this.props.push(F, G, K[F]) }, _removeIndependentTransforms = function (F) { F.translate && (F.removeProperty("translate"), F.removeProperty("scale"), F.removeProperty("rotate")) }, _revertStyle = function () { var F = this.props, G = this.target, Y = G.style, X = G._gsap, K, J; for (K = 0; K < F.length; K += 3)F[K + 1] ? F[K + 1] === 2 ? G[F[K]](F[K + 2]) : G[F[K]] = F[K + 2] : F[K + 2] ? Y[F[K]] = F[K + 2] : Y.removeProperty(F[K].substr(0, 2) === "--" ? F[K] : F[K].replace(_capsExp$1, "-$1").toLowerCase()); if (this.tfm) { for (J in this.tfm) X[J] = this.tfm[J]; X.svg && (X.renderTransform(), G.setAttribute("data-svg-origin", this.svgo || "")), K = _reverting$1(), (!K || !K.isStart) && !Y[_transformProp$1] && (_removeIndependentTransforms(Y), X.zOrigin && Y[_transformOriginProp] && (Y[_transformOriginProp] += " " + X.zOrigin + "px", X.zOrigin = 0, X.renderTransform()), X.uncache = 1) } }, _getStyleSaver$1 = function (F, G) { var Y = { target: F, props: [], revert: _revertStyle, save: _saveStyle }; return F._gsap || gsap$8.core.getCache(F), G && F.style && F.nodeType && G.split(",").forEach(function (X) { return Y.save(X) }), Y }, _supports3D, _createElement = function (F, G) { var Y = _doc$3.createElementNS ? _doc$3.createElementNS((G || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), F) : _doc$3.createElement(F); return Y && Y.style ? Y : _doc$3.createElement(F) }, _getComputedProperty = function z(F, G, Y) { var X = getComputedStyle(F); return X[G] || X.getPropertyValue(G.replace(_capsExp$1, "-$1").toLowerCase()) || X.getPropertyValue(G) || !Y && z(F, _checkPropPrefix(G) || G, 1) || "" }, _prefixes = "O,Moz,ms,Ms,Webkit".split(","), _checkPropPrefix = function (F, G, Y) { var X = G || _tempDiv$1, K = X.style, J = 5; if (F in K && !Y) return F; for (F = F.charAt(0).toUpperCase() + F.substr(1); J-- && !(_prefixes[J] + F in K);); return J < 0 ? null : (J === 3 ? "ms" : J >= 0 ? _prefixes[J] : "") + F }, _initCore$6 = function () { _windowExists$3() && window.document && (_win$4 = window, _doc$3 = _win$4.document, _docElement = _doc$3.documentElement, _tempDiv$1 = _createElement("div") || { style: {} }, _createElement("div"), _transformProp$1 = _checkPropPrefix(_transformProp$1), _transformOriginProp = _transformProp$1 + "Origin", _tempDiv$1.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", _supports3D = !!_checkPropPrefix("perspective"), _reverting$1 = gsap$8.core.reverting, _pluginInitted = 1) }, _getReparentedCloneBBox = function (F) { var G = F.ownerSVGElement, Y = _createElement("svg", G && G.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), X = F.cloneNode(!0), K; X.style.display = "block", Y.appendChild(X), _docElement.appendChild(Y); try { K = X.getBBox() } catch { } return Y.removeChild(X), _docElement.removeChild(Y), K }, _getAttributeFallbacks = function (F, G) { for (var Y = G.length; Y--;)if (F.hasAttribute(G[Y])) return F.getAttribute(G[Y]) }, _getBBox = function (F) { var G, Y; try { G = F.getBBox() } catch { G = _getReparentedCloneBBox(F), Y = 1 } return G && (G.width || G.height) || Y || (G = _getReparentedCloneBBox(F)), G && !G.width && !G.x && !G.y ? { x: +_getAttributeFallbacks(F, ["x", "cx", "x1"]) || 0, y: +_getAttributeFallbacks(F, ["y", "cy", "y1"]) || 0, width: 0, height: 0 } : G }, _isSVG = function (F) { return !!(F.getCTM && (!F.parentNode || F.ownerSVGElement) && _getBBox(F)) }, _removeProperty = function (F, G) { if (G) { var Y = F.style, X; G in _transformProps && G !== _transformOriginProp && (G = _transformProp$1), Y.removeProperty ? (X = G.substr(0, 2), (X === "ms" || G.substr(0, 6) === "webkit") && (G = "-" + G), Y.removeProperty(X === "--" ? G : G.replace(_capsExp$1, "-$1").toLowerCase())) : Y.removeAttribute(G) } }, _addNonTweeningPT = function (F, G, Y, X, K, J) { var Z = new PropTween(F._pt, G, Y, 0, 1, J ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue); return F._pt = Z, Z.b = X, Z.e = K, F._props.push(Y), Z }, _nonConvertibleUnits = { deg: 1, rad: 1, turn: 1 }, _nonStandardLayouts = { grid: 1, flex: 1 }, _convertToUnit = function z(F, G, Y, X) { var K = parseFloat(Y) || 0, J = (Y + "").trim().substr((K + "").length) || "px", Z = _tempDiv$1.style, Q = _horizontalExp.test(G), ee = F.tagName.toLowerCase() === "svg", te = (ee ? "client" : "offset") + (Q ? "Width" : "Height"), oe = 100, ie = X === "px", se = X === "%", ne, re, fe, ae; if (X === J || !K || _nonConvertibleUnits[X] || _nonConvertibleUnits[J]) return K; if (J !== "px" && !ie && (K = z(F, G, Y, "px")), ae = F.getCTM && _isSVG(F), (se || J === "%") && (_transformProps[G] || ~G.indexOf("adius"))) return ne = ae ? F.getBBox()[Q ? "width" : "height"] : F[te], _round$4(se ? K / ne * oe : K / 100 * ne); if (Z[Q ? "width" : "height"] = oe + (ie ? J : X), re = X !== "rem" && ~G.indexOf("adius") || X === "em" && F.appendChild && !ee ? F : F.parentNode, ae && (re = (F.ownerSVGElement || {}).parentNode), (!re || re === _doc$3 || !re.appendChild) && (re = _doc$3.body), fe = re._gsap, fe && se && fe.width && Q && fe.time === _ticker.time && !fe.uncache) return _round$4(K / fe.width * oe); if (se && (G === "height" || G === "width")) { var he = F.style[G]; F.style[G] = oe + X, ne = F[te], he ? F.style[G] = he : _removeProperty(F, G) } else (se || J === "%") && !_nonStandardLayouts[_getComputedProperty(re, "display")] && (Z.position = _getComputedProperty(F, "position")), re === F && (Z.position = "static"), re.appendChild(_tempDiv$1), ne = _tempDiv$1[te], re.removeChild(_tempDiv$1), Z.position = "absolute"; return Q && se && (fe = _getCache(re), fe.time = _ticker.time, fe.width = re[te]), _round$4(ie ? ne * K / oe : ne && K ? oe / ne * K : 0) }, _get = function (F, G, Y, X) { var K; return _pluginInitted || _initCore$6(), G in _propertyAliases && G !== "transform" && (G = _propertyAliases[G], ~G.indexOf(",") && (G = G.split(",")[0])), _transformProps[G] && G !== "transform" ? (K = _parseTransform(F, X), K = G !== "transformOrigin" ? K[G] : K.svg ? K.origin : _firstTwoOnly(_getComputedProperty(F, _transformOriginProp)) + " " + K.zOrigin + "px") : (K = F.style[G], (!K || K === "auto" || X || ~(K + "").indexOf("calc(")) && (K = _specialProps[G] && _specialProps[G](F, G, Y) || _getComputedProperty(F, G) || _getProperty(F, G) || (G === "opacity" ? 1 : 0))), Y && !~(K + "").trim().indexOf(" ") ? _convertToUnit(F, G, K, Y) + Y : K }, _tweenComplexCSSString = function (F, G, Y, X) { if (!Y || Y === "none") { var K = _checkPropPrefix(G, F, 1), J = K && _getComputedProperty(F, K, 1); J && J !== Y ? (G = K, Y = J) : G === "borderColor" && (Y = _getComputedProperty(F, "borderTopColor")) } var Z = new PropTween(this._pt, F.style, G, 0, 1, _renderComplexString), Q = 0, ee = 0, te, oe, ie, se, ne, re, fe, ae, he, le, ce, ue; if (Z.b = Y, Z.e = X, Y += "", X += "", X === "auto" && (re = F.style[G], F.style[G] = X, X = _getComputedProperty(F, G) || X, re ? F.style[G] = re : _removeProperty(F, G)), te = [Y, X], _colorStringFilter(te), Y = te[0], X = te[1], ie = Y.match(_numWithUnitExp) || [], ue = X.match(_numWithUnitExp) || [], ue.length) { for (; oe = _numWithUnitExp.exec(X);)fe = oe[0], he = X.substring(Q, oe.index), ne ? ne = (ne + 1) % 5 : (he.substr(-5) === "rgba(" || he.substr(-5) === "hsla(") && (ne = 1), fe !== (re = ie[ee++] || "") && (se = parseFloat(re) || 0, ce = re.substr((se + "").length), fe.charAt(1) === "=" && (fe = _parseRelative(se, fe) + ce), ae = parseFloat(fe), le = fe.substr((ae + "").length), Q = _numWithUnitExp.lastIndex - le.length, le || (le = le || _config$1.units[G] || ce, Q === X.length && (X += le, Z.e += le)), ce !== le && (se = _convertToUnit(F, G, re, le) || 0), Z._pt = { _next: Z._pt, p: he || ee === 1 ? he : ",", s: se, c: ae - se, m: ne && ne < 4 || G === "zIndex" ? Math.round : 0 }); Z.c = Q < X.length ? X.substring(Q, X.length) : "" } else Z.r = G === "display" && X === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue; return _relExp.test(X) && (Z.e = 0), this._pt = Z, Z }, _keywordToPercent = { top: "0%", bottom: "100%", left: "0%", right: "100%", center: "50%" }, _convertKeywordsToPercentages = function (F) { var G = F.split(" "), Y = G[0], X = G[1] || "50%"; return (Y === "top" || Y === "bottom" || X === "left" || X === "right") && (F = Y, Y = X, X = F), G[0] = _keywordToPercent[Y] || Y, G[1] = _keywordToPercent[X] || X, G.join(" ") }, _renderClearProps = function (F, G) { if (G.tween && G.tween._time === G.tween._dur) { var Y = G.t, X = Y.style, K = G.u, J = Y._gsap, Z, Q, ee; if (K === "all" || K === !0) X.cssText = "", Q = 1; else for (K = K.split(","), ee = K.length; --ee > -1;)Z = K[ee], _transformProps[Z] && (Q = 1, Z = Z === "transformOrigin" ? _transformOriginProp : _transformProp$1), _removeProperty(Y, Z); Q && (_removeProperty(Y, _transformProp$1), J && (J.svg && Y.removeAttribute("transform"), X.scale = X.rotate = X.translate = "none", _parseTransform(Y, 1), J.uncache = 1, _removeIndependentTransforms(X))) } }, _specialProps = { clearProps: function (F, G, Y, X, K) { if (K.data !== "isFromStart") { var J = F._pt = new PropTween(F._pt, G, Y, 0, 0, _renderClearProps); return J.u = X, J.pr = -10, J.tween = K, F._props.push(Y), 1 } } }, _identity2DMatrix = [1, 0, 0, 1, 0, 0], _rotationalProperties = {}, _isNullTransform = function (F) { return F === "matrix(1, 0, 0, 1, 0, 0)" || F === "none" || !F }, _getComputedTransformMatrixAsArray = function (F) { var G = _getComputedProperty(F, _transformProp$1); return _isNullTransform(G) ? _identity2DMatrix : G.substr(7).match(_numExp$2).map(_round$4) }, _getMatrix = function (F, G) { var Y = F._gsap || _getCache(F), X = F.style, K = _getComputedTransformMatrixAsArray(F), J, Z, Q, ee; return Y.svg && F.getAttribute("transform") ? (Q = F.transform.baseVal.consolidate().matrix, K = [Q.a, Q.b, Q.c, Q.d, Q.e, Q.f], K.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : K) : (K === _identity2DMatrix && !F.offsetParent && F !== _docElement && !Y.svg && (Q = X.display, X.display = "block", J = F.parentNode, (!J || !F.offsetParent && !F.getBoundingClientRect().width) && (ee = 1, Z = F.nextElementSibling, _docElement.appendChild(F)), K = _getComputedTransformMatrixAsArray(F), Q ? X.display = Q : _removeProperty(F, "display"), ee && (Z ? J.insertBefore(F, Z) : J ? J.appendChild(F) : _docElement.removeChild(F))), G && K.length > 6 ? [K[0], K[1], K[4], K[5], K[12], K[13]] : K) }, _applySVGOrigin = function (F, G, Y, X, K, J) { var Z = F._gsap, Q = K || _getMatrix(F, !0), ee = Z.xOrigin || 0, te = Z.yOrigin || 0, oe = Z.xOffset || 0, ie = Z.yOffset || 0, se = Q[0], ne = Q[1], re = Q[2], fe = Q[3], ae = Q[4], he = Q[5], le = G.split(" "), ce = parseFloat(le[0]) || 0, ue = parseFloat(le[1]) || 0, me, ge, ve, Se; Y ? Q !== _identity2DMatrix && (ge = se * fe - ne * re) && (ve = ce * (fe / ge) + ue * (-re / ge) + (re * he - fe * ae) / ge, Se = ce * (-ne / ge) + ue * (se / ge) - (se * he - ne * ae) / ge, ce = ve, ue = Se) : (me = _getBBox(F), ce = me.x + (~le[0].indexOf("%") ? ce / 100 * me.width : ce), ue = me.y + (~(le[1] || le[0]).indexOf("%") ? ue / 100 * me.height : ue)), X || X !== !1 && Z.smooth ? (ae = ce - ee, he = ue - te, Z.xOffset = oe + (ae * se + he * re) - ae, Z.yOffset = ie + (ae * ne + he * fe) - he) : Z.xOffset = Z.yOffset = 0, Z.xOrigin = ce, Z.yOrigin = ue, Z.smooth = !!X, Z.origin = G, Z.originIsAbsolute = !!Y, F.style[_transformOriginProp] = "0px 0px", J && (_addNonTweeningPT(J, Z, "xOrigin", ee, ce), _addNonTweeningPT(J, Z, "yOrigin", te, ue), _addNonTweeningPT(J, Z, "xOffset", oe, Z.xOffset), _addNonTweeningPT(J, Z, "yOffset", ie, Z.yOffset)), F.setAttribute("data-svg-origin", ce + " " + ue) }, _parseTransform = function (F, G) { var Y = F._gsap || new GSCache(F); if ("x" in Y && !G && !Y.uncache) return Y; var X = F.style, K = Y.scaleX < 0, J = "px", Z = "deg", Q = getComputedStyle(F), ee = _getComputedProperty(F, _transformOriginProp) || "0", te, oe, ie, se, ne, re, fe, ae, he, le, ce, ue, me, ge, ve, Se, ke, Ce, Ee, De, Pe, Te, ye, xe, pe, de, _e, be, Ae, $e, Fe, Ie; return te = oe = ie = re = fe = ae = he = le = ce = 0, se = ne = 1, Y.svg = !!(F.getCTM && _isSVG(F)), Q.translate && ((Q.translate !== "none" || Q.scale !== "none" || Q.rotate !== "none") && (X[_transformProp$1] = (Q.translate !== "none" ? "translate3d(" + (Q.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (Q.rotate !== "none" ? "rotate(" + Q.rotate + ") " : "") + (Q.scale !== "none" ? "scale(" + Q.scale.split(" ").join(",") + ") " : "") + (Q[_transformProp$1] !== "none" ? Q[_transformProp$1] : "")), X.scale = X.rotate = X.translate = "none"), ge = _getMatrix(F, Y.svg), Y.svg && (Y.uncache ? (pe = F.getBBox(), ee = Y.xOrigin - pe.x + "px " + (Y.yOrigin - pe.y) + "px", xe = "") : xe = !G && F.getAttribute("data-svg-origin"), _applySVGOrigin(F, xe || ee, !!xe || Y.originIsAbsolute, Y.smooth !== !1, ge)), ue = Y.xOrigin || 0, me = Y.yOrigin || 0, ge !== _identity2DMatrix && (Ce = ge[0], Ee = ge[1], De = ge[2], Pe = ge[3], te = Te = ge[4], oe = ye = ge[5], ge.length === 6 ? (se = Math.sqrt(Ce * Ce + Ee * Ee), ne = Math.sqrt(Pe * Pe + De * De), re = Ce || Ee ? _atan2(Ee, Ce) * _RAD2DEG : 0, he = De || Pe ? _atan2(De, Pe) * _RAD2DEG + re : 0, he && (ne *= Math.abs(Math.cos(he * _DEG2RAD$1))), Y.svg && (te -= ue - (ue * Ce + me * De), oe -= me - (ue * Ee + me * Pe))) : (Ie = ge[6], $e = ge[7], _e = ge[8], be = ge[9], Ae = ge[10], Fe = ge[11], te = ge[12], oe = ge[13], ie = ge[14], ve = _atan2(Ie, Ae), fe = ve * _RAD2DEG, ve && (Se = Math.cos(-ve), ke = Math.sin(-ve), xe = Te * Se + _e * ke, pe = ye * Se + be * ke, de = Ie * Se + Ae * ke, _e = Te * -ke + _e * Se, be = ye * -ke + be * Se, Ae = Ie * -ke + Ae * Se, Fe = $e * -ke + Fe * Se, Te = xe, ye = pe, Ie = de), ve = _atan2(-De, Ae), ae = ve * _RAD2DEG, ve && (Se = Math.cos(-ve), ke = Math.sin(-ve), xe = Ce * Se - _e * ke, pe = Ee * Se - be * ke, de = De * Se - Ae * ke, Fe = Pe * ke + Fe * Se, Ce = xe, Ee = pe, De = de), ve = _atan2(Ee, Ce), re = ve * _RAD2DEG, ve && (Se = Math.cos(ve), ke = Math.sin(ve), xe = Ce * Se + Ee * ke, pe = Te * Se + ye * ke, Ee = Ee * Se - Ce * ke, ye = ye * Se - Te * ke, Ce = xe, Te = pe), fe && Math.abs(fe) + Math.abs(re) > 359.9 && (fe = re = 0, ae = 180 - ae), se = _round$4(Math.sqrt(Ce * Ce + Ee * Ee + De * De)), ne = _round$4(Math.sqrt(ye * ye + Ie * Ie)), ve = _atan2(Te, ye), he = Math.abs(ve) > 2e-4 ? ve * _RAD2DEG : 0, ce = Fe ? 1 / (Fe < 0 ? -Fe : Fe) : 0), Y.svg && (xe = F.getAttribute("transform"), Y.forceCSS = F.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(F, _transformProp$1)), xe && F.setAttribute("transform", xe))), Math.abs(he) > 90 && Math.abs(he) < 270 && (K ? (se *= -1, he += re <= 0 ? 180 : -180, re += re <= 0 ? 180 : -180) : (ne *= -1, he += he <= 0 ? 180 : -180)), G = G || Y.uncache, Y.x = te - ((Y.xPercent = te && (!G && Y.xPercent || (Math.round(F.offsetWidth / 2) === Math.round(-te) ? -50 : 0))) ? F.offsetWidth * Y.xPercent / 100 : 0) + J, Y.y = oe - ((Y.yPercent = oe && (!G && Y.yPercent || (Math.round(F.offsetHeight / 2) === Math.round(-oe) ? -50 : 0))) ? F.offsetHeight * Y.yPercent / 100 : 0) + J, Y.z = ie + J, Y.scaleX = _round$4(se), Y.scaleY = _round$4(ne), Y.rotation = _round$4(re) + Z, Y.rotationX = _round$4(fe) + Z, Y.rotationY = _round$4(ae) + Z, Y.skewX = he + Z, Y.skewY = le + Z, Y.transformPerspective = ce + J, (Y.zOrigin = parseFloat(ee.split(" ")[2]) || !G && Y.zOrigin || 0) && (X[_transformOriginProp] = _firstTwoOnly(ee)), Y.xOffset = Y.yOffset = 0, Y.force3D = _config$1.force3D, Y.renderTransform = Y.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms, Y.uncache = 0, Y }, _firstTwoOnly = function (F) { return (F = F.split(" "))[0] + " " + F[1] }, _addPxTranslate = function (F, G, Y) { var X = getUnit(G); return _round$4(parseFloat(G) + parseFloat(_convertToUnit(F, "x", Y + "px", X))) + X }, _renderNon3DTransforms = function (F, G) { G.z = "0px", G.rotationY = G.rotationX = "0deg", G.force3D = 0, _renderCSSTransforms(F, G) }, _zeroDeg = "0deg", _zeroPx = "0px", _endParenthesis = ") ", _renderCSSTransforms = function (F, G) { var Y = G || this, X = Y.xPercent, K = Y.yPercent, J = Y.x, Z = Y.y, Q = Y.z, ee = Y.rotation, te = Y.rotationY, oe = Y.rotationX, ie = Y.skewX, se = Y.skewY, ne = Y.scaleX, re = Y.scaleY, fe = Y.transformPerspective, ae = Y.force3D, he = Y.target, le = Y.zOrigin, ce = "", ue = ae === "auto" && F && F !== 1 || ae === !0; if (le && (oe !== _zeroDeg || te !== _zeroDeg)) { var me = parseFloat(te) * _DEG2RAD$1, ge = Math.sin(me), ve = Math.cos(me), Se; me = parseFloat(oe) * _DEG2RAD$1, Se = Math.cos(me), J = _addPxTranslate(he, J, ge * Se * -le), Z = _addPxTranslate(he, Z, -Math.sin(me) * -le), Q = _addPxTranslate(he, Q, ve * Se * -le + le) } fe !== _zeroPx && (ce += "perspective(" + fe + _endParenthesis), (X || K) && (ce += "translate(" + X + "%, " + K + "%) "), (ue || J !== _zeroPx || Z !== _zeroPx || Q !== _zeroPx) && (ce += Q !== _zeroPx || ue ? "translate3d(" + J + ", " + Z + ", " + Q + ") " : "translate(" + J + ", " + Z + _endParenthesis), ee !== _zeroDeg && (ce += "rotate(" + ee + _endParenthesis), te !== _zeroDeg && (ce += "rotateY(" + te + _endParenthesis), oe !== _zeroDeg && (ce += "rotateX(" + oe + _endParenthesis), (ie !== _zeroDeg || se !== _zeroDeg) && (ce += "skew(" + ie + ", " + se + _endParenthesis), (ne !== 1 || re !== 1) && (ce += "scale(" + ne + ", " + re + _endParenthesis), he.style[_transformProp$1] = ce || "translate(0, 0)" }, _renderSVGTransforms = function (F, G) { var Y = G || this, X = Y.xPercent, K = Y.yPercent, J = Y.x, Z = Y.y, Q = Y.rotation, ee = Y.skewX, te = Y.skewY, oe = Y.scaleX, ie = Y.scaleY, se = Y.target, ne = Y.xOrigin, re = Y.yOrigin, fe = Y.xOffset, ae = Y.yOffset, he = Y.forceCSS, le = parseFloat(J), ce = parseFloat(Z), ue, me, ge, ve, Se; Q = parseFloat(Q), ee = parseFloat(ee), te = parseFloat(te), te && (te = parseFloat(te), ee += te, Q += te), Q || ee ? (Q *= _DEG2RAD$1, ee *= _DEG2RAD$1, ue = Math.cos(Q) * oe, me = Math.sin(Q) * oe, ge = Math.sin(Q - ee) * -ie, ve = Math.cos(Q - ee) * ie, ee && (te *= _DEG2RAD$1, Se = Math.tan(ee - te), Se = Math.sqrt(1 + Se * Se), ge *= Se, ve *= Se, te && (Se = Math.tan(te), Se = Math.sqrt(1 + Se * Se), ue *= Se, me *= Se)), ue = _round$4(ue), me = _round$4(me), ge = _round$4(ge), ve = _round$4(ve)) : (ue = oe, ve = ie, me = ge = 0), (le && !~(J + "").indexOf("px") || ce && !~(Z + "").indexOf("px")) && (le = _convertToUnit(se, "x", J, "px"), ce = _convertToUnit(se, "y", Z, "px")), (ne || re || fe || ae) && (le = _round$4(le + ne - (ne * ue + re * ge) + fe), ce = _round$4(ce + re - (ne * me + re * ve) + ae)), (X || K) && (Se = se.getBBox(), le = _round$4(le + X / 100 * Se.width), ce = _round$4(ce + K / 100 * Se.height)), Se = "matrix(" + ue + "," + me + "," + ge + "," + ve + "," + le + "," + ce + ")", se.setAttribute("transform", Se), he && (se.style[_transformProp$1] = Se) }, _addRotationalPropTween = function (F, G, Y, X, K) { var J = 360, Z = _isString$2(K), Q = parseFloat(K) * (Z && ~K.indexOf("rad") ? _RAD2DEG : 1), ee = Q - X, te = X + ee + "deg", oe, ie; return Z && (oe = K.split("_")[1], oe === "short" && (ee %= J, ee !== ee % (J / 2) && (ee += ee < 0 ? J : -360)), oe === "cw" && ee < 0 ? ee = (ee + J * _bigNum$1) % J - ~~(ee / J) * J : oe === "ccw" && ee > 0 && (ee = (ee - J * _bigNum$1) % J - ~~(ee / J) * J)), F._pt = ie = new PropTween(F._pt, G, Y, X, ee, _renderPropWithEnd), ie.e = te, ie.u = "deg", F._props.push(Y), ie }, _assign = function (F, G) { for (var Y in G) F[Y] = G[Y]; return F }, _addRawTransformPTs = function (F, G, Y) { var X = _assign({}, Y._gsap), K = "perspective,force3D,transformOrigin,svgOrigin", J = Y.style, Z, Q, ee, te, oe, ie, se, ne; X.svg ? (ee = Y.getAttribute("transform"), Y.setAttribute("transform", ""), J[_transformProp$1] = G, Z = _parseTransform(Y, 1), _removeProperty(Y, _transformProp$1), Y.setAttribute("transform", ee)) : (ee = getComputedStyle(Y)[_transformProp$1], J[_transformProp$1] = G, Z = _parseTransform(Y, 1), J[_transformProp$1] = ee); for (Q in _transformProps) ee = X[Q], te = Z[Q], ee !== te && K.indexOf(Q) < 0 && (se = getUnit(ee), ne = getUnit(te), oe = se !== ne ? _convertToUnit(Y, Q, ee, ne) : parseFloat(ee), ie = parseFloat(te), F._pt = new PropTween(F._pt, Z, Q, oe, ie - oe, _renderCSSProp), F._pt.u = ne || 0, F._props.push(Q)); _assign(Z, X) }; _forEachName("padding,margin,Width,Radius", function (z, F) { var G = "Top", Y = "Right", X = "Bottom", K = "Left", J = (F < 3 ? [G, Y, X, K] : [G + K, G + Y, X + Y, X + K]).map(function (Z) { return F < 2 ? z + Z : "border" + Z + z }); _specialProps[F > 1 ? "border" + z : z] = function (Z, Q, ee, te, oe) { var ie, se; if (arguments.length < 4) return ie = J.map(function (ne) { return _get(Z, ne, ee) }), se = ie.join(" "), se.split(ie[0]).length === 5 ? ie[0] : se; ie = (te + "").split(" "), se = {}, J.forEach(function (ne, re) { return se[ne] = ie[re] = ie[re] || ie[(re - 1) / 2 | 0] }), Z.init(Q, se, oe) } }); var CSSPlugin = { name: "css", register: _initCore$6, targetTest: function (F) { return F.style && F.nodeType }, init: function (F, G, Y, X, K) { var J = this._props, Z = F.style, Q = Y.vars.startAt, ee, te, oe, ie, se, ne, re, fe, ae, he, le, ce, ue, me, ge, ve; _pluginInitted || _initCore$6(), this.styles = this.styles || _getStyleSaver$1(F), ve = this.styles.props, this.tween = Y; for (re in G) if (re !== "autoRound" && (te = G[re], !(_plugins[re] && _checkPlugin(re, G, Y, X, F, K)))) { if (se = typeof te, ne = _specialProps[re], se === "function" && (te = te.call(Y, X, F, K), se = typeof te), se === "string" && ~te.indexOf("random(") && (te = _replaceRandom(te)), ne) ne(this, F, re, te, Y) && (ge = 1); else if (re.substr(0, 2) === "--") ee = (getComputedStyle(F).getPropertyValue(re) + "").trim(), te += "", _colorExp.lastIndex = 0, _colorExp.test(ee) || (fe = getUnit(ee), ae = getUnit(te)), ae ? fe !== ae && (ee = _convertToUnit(F, re, ee, ae) + ae) : fe && (te += fe), this.add(Z, "setProperty", ee, te, X, K, 0, 0, re), J.push(re), ve.push(re, 0, Z[re]); else if (se !== "undefined") { if (Q && re in Q ? (ee = typeof Q[re] == "function" ? Q[re].call(Y, X, F, K) : Q[re], _isString$2(ee) && ~ee.indexOf("random(") && (ee = _replaceRandom(ee)), getUnit(ee + "") || ee === "auto" || (ee += _config$1.units[re] || getUnit(_get(F, re)) || ""), (ee + "").charAt(1) === "=" && (ee = _get(F, re))) : ee = _get(F, re), ie = parseFloat(ee), he = se === "string" && te.charAt(1) === "=" && te.substr(0, 2), he && (te = te.substr(2)), oe = parseFloat(te), re in _propertyAliases && (re === "autoAlpha" && (ie === 1 && _get(F, "visibility") === "hidden" && oe && (ie = 0), ve.push("visibility", 0, Z.visibility), _addNonTweeningPT(this, Z, "visibility", ie ? "inherit" : "hidden", oe ? "inherit" : "hidden", !oe)), re !== "scale" && re !== "transform" && (re = _propertyAliases[re], ~re.indexOf(",") && (re = re.split(",")[0]))), le = re in _transformProps, le) { if (this.styles.save(re), ce || (ue = F._gsap, ue.renderTransform && !G.parseTransform || _parseTransform(F, G.parseTransform), me = G.smoothOrigin !== !1 && ue.smooth, ce = this._pt = new PropTween(this._pt, Z, _transformProp$1, 0, 1, ue.renderTransform, ue, 0, -1), ce.dep = 1), re === "scale") this._pt = new PropTween(this._pt, ue, "scaleY", ue.scaleY, (he ? _parseRelative(ue.scaleY, he + oe) : oe) - ue.scaleY || 0, _renderCSSProp), this._pt.u = 0, J.push("scaleY", re), re += "X"; else if (re === "transformOrigin") { ve.push(_transformOriginProp, 0, Z[_transformOriginProp]), te = _convertKeywordsToPercentages(te), ue.svg ? _applySVGOrigin(F, te, 0, me, 0, this) : (ae = parseFloat(te.split(" ")[2]) || 0, ae !== ue.zOrigin && _addNonTweeningPT(this, ue, "zOrigin", ue.zOrigin, ae), _addNonTweeningPT(this, Z, re, _firstTwoOnly(ee), _firstTwoOnly(te))); continue } else if (re === "svgOrigin") { _applySVGOrigin(F, te, 1, me, 0, this); continue } else if (re in _rotationalProperties) { _addRotationalPropTween(this, ue, re, ie, he ? _parseRelative(ie, he + te) : te); continue } else if (re === "smoothOrigin") { _addNonTweeningPT(this, ue, "smooth", ue.smooth, te); continue } else if (re === "force3D") { ue[re] = te; continue } else if (re === "transform") { _addRawTransformPTs(this, te, F); continue } } else re in Z || (re = _checkPropPrefix(re) || re); if (le || (oe || oe === 0) && (ie || ie === 0) && !_complexExp.test(te) && re in Z) fe = (ee + "").substr((ie + "").length), oe || (oe = 0), ae = getUnit(te) || (re in _config$1.units ? _config$1.units[re] : fe), fe !== ae && (ie = _convertToUnit(F, re, ee, ae)), this._pt = new PropTween(this._pt, le ? ue : Z, re, ie, (he ? _parseRelative(ie, he + oe) : oe) - ie, !le && (ae === "px" || re === "zIndex") && G.autoRound !== !1 ? _renderRoundedCSSProp : _renderCSSProp), this._pt.u = ae || 0, fe !== ae && ae !== "%" && (this._pt.b = ee, this._pt.r = _renderCSSPropWithBeginning); else if (re in Z) _tweenComplexCSSString.call(this, F, re, ee, he ? he + te : te); else if (re in F) this.add(F, re, ee || F[re], he ? he + te : te, X, K); else if (re !== "parseTransform") { _missingPlugin(re, te); continue } le || (re in Z ? ve.push(re, 0, Z[re]) : typeof F[re] == "function" ? ve.push(re, 2, F[re]()) : ve.push(re, 1, ee || F[re])), J.push(re) } } ge && _sortPropTweensByPriority(this) }, render: function (F, G) { if (G.tween._time || !_reverting$1()) for (var Y = G._pt; Y;)Y.r(F, Y.d), Y = Y._next; else G.styles.revert() }, get: _get, aliases: _propertyAliases, getSetter: function (F, G, Y) { var X = _propertyAliases[G]; return X && X.indexOf(",") < 0 && (G = X), G in _transformProps && G !== _transformOriginProp && (F._gsap.x || _get(F, "x")) ? Y && _recentSetterPlugin === Y ? G === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = Y || {}) && (G === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : F.style && !_isUndefined(F.style[G]) ? _setterCSSStyle : ~G.indexOf("-") ? _setterCSSProp : _getSetter(F, G) }, core: { _removeProperty, _getMatrix } }; gsap$8.utils.checkPrefix = _checkPropPrefix; gsap$8.core.getStyleSaver = _getStyleSaver$1; (function (z, F, G, Y) { var X = _forEachName(z + "," + F + "," + G, function (K) { _transformProps[K] = 1 }); _forEachName(F, function (K) { _config$1.units[K] = "deg", _rotationalProperties[K] = 1 }), _propertyAliases[X[13]] = z + "," + F, _forEachName(Y, function (K) { var J = K.split(":"); _propertyAliases[J[1]] = X[J[0]] }) })("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY"); _forEachName("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function (z) { _config$1.units[z] = "px" }); gsap$8.registerPlugin(CSSPlugin); var gsapWithCSS = gsap$8.registerPlugin(CSSPlugin) || gsap$8; gsapWithCSS.core.Tween;/*!
 * strings: 3.12.7
 * https://gsap.com
 *
 * Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/var _trimExp = /(?:^\s+|\s+$)/g, emojiExp = /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2642\u2640]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDD27\uDCBC\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCC\uDFCB]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/; function getText(z) { var F = z.nodeType, G = ""; if (F === 1 || F === 9 || F === 11) { if (typeof z.textContent == "string") return z.textContent; for (z = z.firstChild; z; z = z.nextSibling)G += getText(z) } else if (F === 3 || F === 4) return z.nodeValue; return G } function splitInnerHTML(z, F, G, Y, X) { for (var K = z.firstChild, J = [], Z; K;)K.nodeType === 3 ? (Z = (K.nodeValue + "").replace(/^\n+/g, ""), Y || (Z = Z.replace(/\s+/g, " ")), J.push.apply(J, emojiSafeSplit(Z, F, G, Y, X))) : (K.nodeName + "").toLowerCase() === "br" ? J[J.length - 1] += "<br>" : J.push(K.outerHTML), K = K.nextSibling; if (!X) for (Z = J.length; Z--;)J[Z] === "&" && J.splice(Z, 1, "&amp;"); return J } function emojiSafeSplit(z, F, G, Y, X) { if (z += "", G && (z = z.trim ? z.trim() : z.replace(_trimExp, "")), F && F !== "") return z.replace(/>/g, "&gt;").replace(/</g, "&lt;").split(F); for (var K = [], J = z.length, Z = 0, Q, ee; Z < J; Z++)ee = z.charAt(Z), (ee.charCodeAt(0) >= 55296 && ee.charCodeAt(0) <= 56319 || z.charCodeAt(Z + 1) >= 65024 && z.charCodeAt(Z + 1) <= 65039) && (Q = ((z.substr(Z, 12).split(emojiExp) || [])[1] || "").length || 2, ee = z.substr(Z, Q), K.emoji = 1, Z += Q - 1), K.push(X ? ee : ee === ">" ? "&gt;" : ee === "<" ? "&lt;" : Y && ee === " " && (z.charAt(Z - 1) === " " || z.charAt(Z + 1) === " ") ? "&nbsp;" : ee); return K }/*!
 * SplitText: 3.12.7
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/var _doc$2, _win$3, _coreInitted$6, gsap$7, _context$2, _toArray$3, _stripExp = /(?:\r|\n|\t\t)/g, _multipleSpacesExp = /(?:\s\s+)/g, _nonBreakingSpace = " ", _initCore$5 = function (F) { _doc$2 = document, _win$3 = window, gsap$7 = gsap$7 || F || _win$3.gsap || console.warn("Please gsap.registerPlugin(SplitText)"), gsap$7 && (_toArray$3 = gsap$7.utils.toArray, _context$2 = gsap$7.core.context || function () { }, _coreInitted$6 = 1) }, _getComputedStyle$1 = function (F) { return _win$3.getComputedStyle(F) }, _isAbsolute = function (F) { return F.position === "absolute" || F.absolute === !0 }, _findSpecialChars = function (F, G) { for (var Y = G.length, X; --Y > -1;)if (X = G[Y], F.substr(0, X.length) === X) return X.length }, _divStart = " style='position:relative;display:inline-block;'", _cssClassFunc = function (F, G) { F === void 0 && (F = ""); var Y = ~F.indexOf("++"), X = 1; return Y && (F = F.split("++").join("")), function () { return "<" + G + _divStart + (F ? " class='" + F + (Y ? X++ : "") + "'>" : ">") } }, _swapText = function z(F, G, Y) { var X = F.nodeType; if (X === 1 || X === 9 || X === 11) for (F = F.firstChild; F; F = F.nextSibling)z(F, G, Y); else (X === 3 || X === 4) && (F.nodeValue = F.nodeValue.split(G).join(Y)) }, _pushReversed = function (F, G) { for (var Y = G.length; --Y > -1;)F.push(G[Y]) }, _isBeforeWordDelimiter = function (F, G, Y) { for (var X; F && F !== G;) { if (X = F._next || F.nextSibling, X) return X.textContent.charAt(0) === Y; F = F.parentNode || F._parent } }, _deWordify = function z(F) { var G = _toArray$3(F.childNodes), Y = G.length, X, K; for (X = 0; X < Y; X++)K = G[X], K._isSplit ? z(K) : X && K.previousSibling && K.previousSibling.nodeType === 3 ? (K.previousSibling.nodeValue += K.nodeType === 3 ? K.nodeValue : K.firstChild.nodeValue, F.removeChild(K)) : K.nodeType !== 3 && (F.insertBefore(K.firstChild, K), F.removeChild(K)) }, _getStyleAsNumber = function (F, G) { return parseFloat(G[F]) || 0 }, _setPositionsAfterSplit = function (F, G, Y, X, K, J, Z) { var Q = _getComputedStyle$1(F), ee = _getStyleAsNumber("paddingLeft", Q), te = -999, oe = _getStyleAsNumber("borderBottomWidth", Q) + _getStyleAsNumber("borderTopWidth", Q), ie = _getStyleAsNumber("borderLeftWidth", Q) + _getStyleAsNumber("borderRightWidth", Q), se = _getStyleAsNumber("paddingTop", Q) + _getStyleAsNumber("paddingBottom", Q), ne = _getStyleAsNumber("paddingLeft", Q) + _getStyleAsNumber("paddingRight", Q), re = _getStyleAsNumber("fontSize", Q) * (G.lineThreshold || .2), fe = Q.textAlign, ae = [], he = [], le = [], ce = G.wordDelimiter || " ", ue = G.tag ? G.tag : G.span ? "span" : "div", me = G.type || G.split || "chars,words,lines", ge = K && ~me.indexOf("lines") ? [] : null, ve = ~me.indexOf("words"), Se = ~me.indexOf("chars"), ke = _isAbsolute(G), Ce = G.linesClass, Ee = ~(Ce || "").indexOf("++"), De = [], Pe = Q.display === "flex", Te = F.style.display, ye, xe, pe, de, _e, be, Ae, $e, Fe, Ie, Be, Ve; for (Ee && (Ce = Ce.split("++").join("")), Pe && (F.style.display = "block"), xe = F.getElementsByTagName("*"), pe = xe.length, _e = [], ye = 0; ye < pe; ye++)_e[ye] = xe[ye]; if (ge || ke) for (ye = 0; ye < pe; ye++)de = _e[ye], be = de.parentNode === F, (be || ke || Se && !ve) && (Ve = de.offsetTop, ge && be && Math.abs(Ve - te) > re && (de.nodeName !== "BR" || ye === 0) && (Ae = [], ge.push(Ae), te = Ve), ke && (de._x = de.offsetLeft, de._y = Ve, de._w = de.offsetWidth, de._h = de.offsetHeight), ge && ((de._isSplit && be || !Se && be || ve && be || !ve && de.parentNode.parentNode === F && !de.parentNode._isSplit) && (Ae.push(de), de._x -= ee, _isBeforeWordDelimiter(de, F, ce) && (de._wordEnd = !0)), de.nodeName === "BR" && (de.nextSibling && de.nextSibling.nodeName === "BR" || ye === 0) && ge.push([]))); for (ye = 0; ye < pe; ye++) { if (de = _e[ye], be = de.parentNode === F, de.nodeName === "BR") { ge || ke ? (de.parentNode && de.parentNode.removeChild(de), _e.splice(ye--, 1), pe--) : ve || F.appendChild(de); continue } if (ke && (Fe = de.style, !ve && !be && (de._x += de.parentNode._x, de._y += de.parentNode._y), Fe.left = de._x + "px", Fe.top = de._y + "px", Fe.position = "absolute", Fe.display = "block", Fe.width = de._w + 1 + "px", Fe.height = de._h + "px"), !ve && Se) if (de._isSplit) for (de._next = xe = de.nextSibling, de.parentNode.appendChild(de); xe && xe.nodeType === 3 && xe.textContent === " ";)de._next = xe.nextSibling, de.parentNode.appendChild(xe), xe = xe.nextSibling; else de.parentNode._isSplit ? (de._parent = de.parentNode, !de.previousSibling && de.firstChild && (de.firstChild._isFirst = !0), de.nextSibling && de.nextSibling.textContent === " " && !de.nextSibling.nextSibling && De.push(de.nextSibling), de._next = de.nextSibling && de.nextSibling._isFirst ? null : de.nextSibling, de.parentNode.removeChild(de), _e.splice(ye--, 1), pe--) : be || (Ve = !de.nextSibling && _isBeforeWordDelimiter(de.parentNode, F, ce), de.parentNode._parent && de.parentNode._parent.appendChild(de), Ve && de.parentNode.appendChild(_doc$2.createTextNode(" ")), ue === "span" && (de.style.display = "inline"), ae.push(de)); else de.parentNode._isSplit && !de._isSplit && de.innerHTML !== "" ? he.push(de) : Se && !de._isSplit && (ue === "span" && (de.style.display = "inline"), ae.push(de)) } for (ye = De.length; --ye > -1;)De[ye].parentNode.removeChild(De[ye]); if (ge) { for (ke && (Ie = _doc$2.createElement(ue), F.appendChild(Ie), Be = Ie.offsetWidth + "px", Ve = Ie.offsetParent === F ? 0 : F.offsetLeft, F.removeChild(Ie)), Fe = F.style.cssText, F.style.cssText = "display:none;"; F.firstChild;)F.removeChild(F.firstChild); for ($e = ce === " " && (!ke || !ve && !Se), ye = 0; ye < ge.length; ye++) { for (Ae = ge[ye], Ie = _doc$2.createElement(ue), Ie.style.cssText = "display:block;text-align:" + fe + ";position:" + (ke ? "absolute;" : "relative;"), Ce && (Ie.className = Ce + (Ee ? ye + 1 : "")), le.push(Ie), pe = Ae.length, xe = 0; xe < pe; xe++)Ae[xe].nodeName !== "BR" && (de = Ae[xe], Ie.appendChild(de), $e && de._wordEnd && Ie.appendChild(_doc$2.createTextNode(" ")), ke && (xe === 0 && (Ie.style.top = de._y + "px", Ie.style.left = ee + Ve + "px"), de.style.top = "0px", Ve && (de.style.left = de._x - Ve + "px"))); pe === 0 ? Ie.innerHTML = "&nbsp;" : !ve && !Se && (_deWordify(Ie), _swapText(Ie, " ", " ")), ke && (Ie.style.width = Be, Ie.style.height = de._h + "px"), F.appendChild(Ie) } F.style.cssText = Fe } ke && (Z > F.clientHeight && (F.style.height = Z - se + "px", F.clientHeight < Z && (F.style.height = Z + oe + "px")), J > F.clientWidth && (F.style.width = J - ne + "px", F.clientWidth < J && (F.style.width = J + ie + "px"))), Pe && (Te ? F.style.display = Te : F.style.removeProperty("display")), _pushReversed(Y, ae), ve && _pushReversed(X, he), _pushReversed(K, le) }, _splitRawText = function (F, G, Y, X) { var K = G.tag ? G.tag : G.span ? "span" : "div", J = G.type || G.split || "chars,words,lines", Z = ~J.indexOf("chars"), Q = _isAbsolute(G), ee = G.wordDelimiter || " ", te = function (ke) { return ke === ee || ke === _nonBreakingSpace && ee === " " }, oe = ee !== " " ? "" : Q ? "&#173; " : " ", ie = "</" + K + ">", se = 1, ne = G.specialChars ? typeof G.specialChars == "function" ? G.specialChars : _findSpecialChars : null, re, fe, ae, he, le, ce, ue, me, ge = _doc$2.createElement("div"), ve = F.parentNode; for (ve.insertBefore(ge, F), ge.textContent = F.nodeValue, ve.removeChild(F), F = ge, re = getText(F), ue = re.indexOf("<") !== -1, G.reduceWhiteSpace !== !1 && (re = re.replace(_multipleSpacesExp, " ").replace(_stripExp, "")), ue && (re = re.split("<").join("{{LT}}")), le = re.length, fe = (re.charAt(0) === " " ? oe : "") + Y(), ae = 0; ae < le; ae++)if (ce = re.charAt(ae), ne && (me = ne(re.substr(ae), G.specialChars))) ce = re.substr(ae, me || 1), fe += Z && ce !== " " ? X() + ce + "</" + K + ">" : ce, ae += me - 1; else if (te(ce) && !te(re.charAt(ae - 1)) && ae) { for (fe += se ? ie : "", se = 0; te(re.charAt(ae + 1));)fe += oe, ae++; ae === le - 1 ? fe += oe : re.charAt(ae + 1) !== ")" && (fe += oe + Y(), se = 1) } else ce === "{" && re.substr(ae, 6) === "{{LT}}" ? (fe += Z ? X() + "{{LT}}</" + K + ">" : "{{LT}}", ae += 5) : ce.charCodeAt(0) >= 55296 && ce.charCodeAt(0) <= 56319 || re.charCodeAt(ae + 1) >= 65024 && re.charCodeAt(ae + 1) <= 65039 ? (he = ((re.substr(ae, 12).split(emojiExp) || [])[1] || "").length || 2, fe += Z && ce !== " " ? X() + re.substr(ae, he) + "</" + K + ">" : re.substr(ae, he), ae += he - 1) : fe += Z && ce !== " " ? X() + ce + "</" + K + ">" : ce; F.outerHTML = fe + (se ? ie : ""), ue && _swapText(ve, "{{LT}}", "<") }, _split = function z(F, G, Y, X) { var K = _toArray$3(F.childNodes), J = K.length, Z = _isAbsolute(G), Q, ee; if (F.nodeType !== 3 || J > 1) { for (G.absolute = !1, Q = 0; Q < J; Q++)ee = K[Q], ee._next = ee._isFirst = ee._parent = ee._wordEnd = null, (ee.nodeType !== 3 || /\S+/.test(ee.nodeValue)) && (Z && ee.nodeType !== 3 && _getComputedStyle$1(ee).display === "inline" && (ee.style.display = "inline-block", ee.style.position = "relative"), ee._isSplit = !0, z(ee, G, Y, X)); G.absolute = Z, F._isSplit = !0; return } _splitRawText(F, G, Y, X) }, SplitText = function () { function z(G, Y) { _coreInitted$6 || _initCore$5(), this.elements = _toArray$3(G), this.chars = [], this.words = [], this.lines = [], this._originals = [], this.vars = Y || {}, _context$2(this), this.split(Y) } var F = z.prototype; return F.split = function (Y) { this.isSplit && this.revert(), this.vars = Y = Y || this.vars, this._originals.length = this.chars.length = this.words.length = this.lines.length = 0; for (var X = this.elements.length, K = Y.tag ? Y.tag : Y.span ? "span" : "div", J = _cssClassFunc(Y.wordsClass, K), Z = _cssClassFunc(Y.charsClass, K), Q, ee, te; --X > -1;)te = this.elements[X], this._originals[X] = { html: te.innerHTML, style: te.getAttribute("style") }, Q = te.clientHeight, ee = te.clientWidth, _split(te, Y, J, Z), _setPositionsAfterSplit(te, Y, this.chars, this.words, this.lines, ee, Q); return this.chars.reverse(), this.words.reverse(), this.lines.reverse(), this.isSplit = !0, this }, F.revert = function () { var Y = this._originals; if (!Y) throw "revert() call wasn't scoped properly."; return this.elements.forEach(function (X, K) { X.innerHTML = Y[K].html, X.setAttribute("style", Y[K].style || "") }), this.chars = [], this.words = [], this.lines = [], this.isSplit = !1, this }, z.create = function (Y, X) { return new z(Y, X) }, z }(); SplitText.version = "3.12.7"; SplitText.register = _initCore$5; gsapWithCSS.registerPlugin(SplitText); const $$1 = (z, F) => { if (F || (F = document), z instanceof HTMLElement || z instanceof SVGElement ? F = z : F = F.querySelector(z), F === null) return F; let G = null; return F.rect = Y => (G || (G = F.getBoundingClientRect()), G[Y]), F }, $$ = (z, F) => (F || (F = document), Array.from(F.querySelectorAll(z)).map(G => $$1(G))); class OneLineSplit {
    constructor(F) { this.obj = F, this.init(); const G = this.obj.target; let Y = null; typeof G == "object" ? Y = G : typeof G == "string" && (Y = document.querySelector(G)), this.lines = Y.querySelectorAll(".split-text") } init() {
        const F = this.obj.target, G = this.obj.className || "split-text"; let Y = null; if (typeof F == "object" ? Y = F : typeof F == "string" && (Y = document.querySelector(F)), Y === null) return; this.obj.element = Y, this.obj.old = Y.innerHTML, this.obj.element.querySelectorAll(`br[${window.innerWidth < 750 ? "pc-only" : "sp-only"}]`).forEach(te => { te.remove() }), Y.style.visibility = "hidden"; let X = "";[...Y.childNodes].forEach(te => {
            if (te.nodeType === 3) {
                const oe = te.textContent.replace(/\r?\n/g, `
`); X = X + oe.split("").reduce((ie, se) => ie + `<span>${se}</span>`, "")
            } else if (te.nodeType === 1) { const oe = te.tagName.toLowerCase(); if (oe !== "br") { const ie = te.attributes; let se = ""; for (let ne = 0; ne < ie.length; ne++)se += `${ie[ne].name}="${ie[ne].value}" `; X = X + `<${oe} ${se} char-ignore>${te.innerHTML}</${oe}>` } else X = X + "<br>" }
        }), Y.innerHTML = X; const J = [...Y.childNodes].filter(te => te.nodeType === 1 && te.tagName.toLowerCase() !== "br"); let Z = []; J.forEach(te => { const oe = Math.round(te.getBoundingClientRect().top); te.setAttribute("char-pos", oe), Z.push(oe) }), Z = Z.filter(function (te, oe, ie) { return ie.indexOf(te) === oe }); const Q = []; Z.forEach(te => { const oe = document.querySelectorAll(`[char-pos="${te}"]`); let ie = ""; oe.forEach(se => { ie += se.outerHTML }), Q.push(ie) }); let ee = ""; Q.forEach(te => { te !== "" && (ee += `<span class="${G}" style="white-space: nowrap; display: inline-block; will-change: transform; line-height: 1.35">${te}</span><br/>`) }), Y.innerHTML = ee, $$(`.${G}`, Y).forEach(te => { const ie = [...$$("*", te)].map(se => se.hasAttribute("char-ignore") ? (se.removeAttribute("char-ignore"), se.removeAttribute("char-pos"), se.outerHTML) : se.textContent).join(""); te.innerHTML = ie }), Y.style.visibility = ""
    } kill() { this.obj.element.innerHTML = this.obj.old }
} const getMode = () => document.documentElement.classList.contains("dark") ? "dark" : "light", getDeviceType = () => { if (typeof window < "u") return window.matchMedia(`(max-width: ${BREAKPOINTS.SP}px)`).matches ? "sp" : window.matchMedia(`(max-width: ${BREAKPOINTS.TB}px)`).matches ? "tb" : "pc" }, touchOnly = () => { const z = navigator.userAgent.toLowerCase(); return /android|ipod|ipad|iphone|macintosh/.test(z) && "ontouchend" in document }, wrapSpecificText = (z, F, G = "") => { if (!z || !Array.isArray(F) || F.length === 0) return; const Y = X => { if (X.nodeType === Node.TEXT_NODE) { let K = X.nodeValue; const J = document.createDocumentFragment(); F.forEach(Z => { if (K.includes(Z)) { const Q = K.split(Z); J.textContent = "", Q.forEach((ee, te) => { if (ee && J.appendChild(document.createTextNode(ee)), te < Q.length - 1) { const oe = document.createElement("span"); G && (oe.className = G), oe.textContent = Z, J.appendChild(oe) } }), K = "" } }), K === "" && X.parentNode && X.parentNode.replaceChild(J, X) } else X.nodeType === Node.ELEMENT_NODE && Array.from(X.childNodes).forEach(Y) }; Array.from(z.childNodes).forEach(Y) }, scrollSet = z => { z === "stop" && (window.lenis ? window.lenis.stop() : document.querySelector("body").style.overflow = "hidden"), z === "start" && (window.lenis ? window.lenis.start() : document.querySelector("body").style.overflow = "") }, splitText = (z, F) => new SplitText(z, { type: F, linesClass: F === "char" ? "text-split-char" : "text-split-line" }), setColorVariables = (z, F) => { document.documentElement.style.setProperty("--color-main", z), document.documentElement.style.setProperty("--color-sub", F) }, lerp$1 = (z, F, G, Y) => { const X = Y ? Y(G) : G; return z + (F - z) * X }; function _defineProperties(z, F) { for (var G = 0; G < F.length; G++) { var Y = F[G]; Y.enumerable = Y.enumerable || !1, Y.configurable = !0, "value" in Y && (Y.writable = !0), Object.defineProperty(z, Y.key, Y) } } function _createClass(z, F, G) { return F && _defineProperties(z.prototype, F), z }/*!
 * Observer 3.12.7
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/var gsap$6, _coreInitted$5, _win$2, _doc$1, _docEl$2, _body$2, _isTouch, _pointerType, ScrollTrigger$2, _root$1, _normalizer$1, _eventTypes, _context$1, _getGSAP$6 = function () { return gsap$6 || typeof window < "u" && (gsap$6 = window.gsap) && gsap$6.registerPlugin && gsap$6 }, _startup$1 = 1, _observers = [], _scrollers = [], _proxies = [], _getTime$1 = Date.now, _bridge = function (F, G) { return G }, _integrate = function () { var F = ScrollTrigger$2.core, G = F.bridge || {}, Y = F._scrollers, X = F._proxies; Y.push.apply(Y, _scrollers), X.push.apply(X, _proxies), _scrollers = Y, _proxies = X, _bridge = function (J, Z) { return G[J](Z) } }, _getProxyProp = function (F, G) { return ~_proxies.indexOf(F) && _proxies[_proxies.indexOf(F) + 1][G] }, _isViewport$1 = function (F) { return !!~_root$1.indexOf(F) }, _addListener$1 = function (F, G, Y, X, K) { return F.addEventListener(G, Y, { passive: X !== !1, capture: !!K }) }, _removeListener$1 = function (F, G, Y, X) { return F.removeEventListener(G, Y, !!X) }, _scrollLeft = "scrollLeft", _scrollTop = "scrollTop", _onScroll$1 = function () { return _normalizer$1 && _normalizer$1.isPressed || _scrollers.cache++ }, _scrollCacheFunc = function (F, G) { var Y = function X(K) { if (K || K === 0) { _startup$1 && (_win$2.history.scrollRestoration = "manual"); var J = _normalizer$1 && _normalizer$1.isPressed; K = X.v = Math.round(K) || (_normalizer$1 && _normalizer$1.iOS ? 1 : 0), F(K), X.cacheID = _scrollers.cache, J && _bridge("ss", K) } else (G || _scrollers.cache !== X.cacheID || _bridge("ref")) && (X.cacheID = _scrollers.cache, X.v = F()); return X.v + X.offset }; return Y.offset = 0, F && Y }, _horizontal = { s: _scrollLeft, p: "left", p2: "Left", os: "right", os2: "Right", d: "width", d2: "Width", a: "x", sc: _scrollCacheFunc(function (z) { return arguments.length ? _win$2.scrollTo(z, _vertical.sc()) : _win$2.pageXOffset || _doc$1[_scrollLeft] || _docEl$2[_scrollLeft] || _body$2[_scrollLeft] || 0 }) }, _vertical = { s: _scrollTop, p: "top", p2: "Top", os: "bottom", os2: "Bottom", d: "height", d2: "Height", a: "y", op: _horizontal, sc: _scrollCacheFunc(function (z) { return arguments.length ? _win$2.scrollTo(_horizontal.sc(), z) : _win$2.pageYOffset || _doc$1[_scrollTop] || _docEl$2[_scrollTop] || _body$2[_scrollTop] || 0 }) }, _getTarget = function (F, G) { return (G && G._ctx && G._ctx.selector || gsap$6.utils.toArray)(F)[0] || (typeof F == "string" && gsap$6.config().nullTargetWarn !== !1 ? console.warn("Element not found:", F) : null) }, _getScrollFunc = function (F, G) { var Y = G.s, X = G.sc; _isViewport$1(F) && (F = _doc$1.scrollingElement || _docEl$2); var K = _scrollers.indexOf(F), J = X === _vertical.sc ? 1 : 2; !~K && (K = _scrollers.push(F) - 1), _scrollers[K + J] || _addListener$1(F, "scroll", _onScroll$1); var Z = _scrollers[K + J], Q = Z || (_scrollers[K + J] = _scrollCacheFunc(_getProxyProp(F, Y), !0) || (_isViewport$1(F) ? X : _scrollCacheFunc(function (ee) { return arguments.length ? F[Y] = ee : F[Y] }))); return Q.target = F, Z || (Q.smooth = gsap$6.getProperty(F, "scrollBehavior") === "smooth"), Q }, _getVelocityProp = function (F, G, Y) { var X = F, K = F, J = _getTime$1(), Z = J, Q = G || 50, ee = Math.max(500, Q * 3), te = function (ne, re) { var fe = _getTime$1(); re || fe - J > Q ? (K = X, X = ne, Z = J, J = fe) : Y ? X += ne : X = K + (ne - K) / (fe - Z) * (J - Z) }, oe = function () { K = X = Y ? 0 : X, Z = J = 0 }, ie = function (ne) { var re = Z, fe = K, ae = _getTime$1(); return (ne || ne === 0) && ne !== X && te(ne), J === Z || ae - Z > ee ? 0 : (X + (Y ? fe : -fe)) / ((Y ? ae : J) - re) * 1e3 }; return { update: te, reset: oe, getVelocity: ie } }, _getEvent = function (F, G) { return G && !F._gsapAllow && F.preventDefault(), F.changedTouches ? F.changedTouches[0] : F }, _getAbsoluteMax = function (F) { var G = Math.max.apply(Math, F), Y = Math.min.apply(Math, F); return Math.abs(G) >= Math.abs(Y) ? G : Y }, _setScrollTrigger = function () { ScrollTrigger$2 = gsap$6.core.globals().ScrollTrigger, ScrollTrigger$2 && ScrollTrigger$2.core && _integrate() }, _initCore$4 = function (F) { return gsap$6 = F || _getGSAP$6(), !_coreInitted$5 && gsap$6 && typeof document < "u" && document.body && (_win$2 = window, _doc$1 = document, _docEl$2 = _doc$1.documentElement, _body$2 = _doc$1.body, _root$1 = [_win$2, _doc$1, _docEl$2, _body$2], gsap$6.utils.clamp, _context$1 = gsap$6.core.context || function () { }, _pointerType = "onpointerenter" in _body$2 ? "pointer" : "mouse", _isTouch = Observer.isTouch = _win$2.matchMedia && _win$2.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in _win$2 || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0, _eventTypes = Observer.eventTypes = ("ontouchstart" in _docEl$2 ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown" in _docEl$2 ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","), setTimeout(function () { return _startup$1 = 0 }, 500), _setScrollTrigger(), _coreInitted$5 = 1), _coreInitted$5 }; _horizontal.op = _vertical; _scrollers.cache = 0; var Observer = function () { function z(G) { this.init(G) } var F = z.prototype; return F.init = function (Y) { _coreInitted$5 || _initCore$4(gsap$6) || console.warn("Please gsap.registerPlugin(Observer)"), ScrollTrigger$2 || _setScrollTrigger(); var X = Y.tolerance, K = Y.dragMinimum, J = Y.type, Z = Y.target, Q = Y.lineHeight, ee = Y.debounce, te = Y.preventDefault, oe = Y.onStop, ie = Y.onStopDelay, se = Y.ignore, ne = Y.wheelSpeed, re = Y.event, fe = Y.onDragStart, ae = Y.onDragEnd, he = Y.onDrag, le = Y.onPress, ce = Y.onRelease, ue = Y.onRight, me = Y.onLeft, ge = Y.onUp, ve = Y.onDown, Se = Y.onChangeX, ke = Y.onChangeY, Ce = Y.onChange, Ee = Y.onToggleX, De = Y.onToggleY, Pe = Y.onHover, Te = Y.onHoverEnd, ye = Y.onMove, xe = Y.ignoreCheck, pe = Y.isNormalizer, de = Y.onGestureStart, _e = Y.onGestureEnd, be = Y.onWheel, Ae = Y.onEnable, $e = Y.onDisable, Fe = Y.onClick, Ie = Y.scrollSpeed, Be = Y.capture, Ve = Y.allowClicks, Ze = Y.lockAxis, Qe = Y.onLockAxis; this.target = Z = _getTarget(Z) || _docEl$2, this.vars = Y, se && (se = gsap$6.utils.toArray(se)), X = X || 1e-9, K = K || 0, ne = ne || 1, Ie = Ie || 1, J = J || "wheel,touch,pointer", ee = ee !== !1, Q || (Q = parseFloat(_win$2.getComputedStyle(_body$2).lineHeight) || 22); var Ue, Ye, Xe, Re, Me, it, nt, we = this, Ge = 0, Oe = 0, at = Y.passive || !te && Y.passive !== !1, We = _getScrollFunc(Z, _horizontal), ot = _getScrollFunc(Z, _vertical), dt = We(), mt = ot(), rt = ~J.indexOf("touch") && !~J.indexOf("pointer") && _eventTypes[0] === "pointerdown", ut = _isViewport$1(Z), tt = Z.ownerDocument || _doc$1, St = [0, 0, 0], _t = [0, 0, 0], Tt = 0, Ht = function () { return Tt = _getTime$1() }, pt = function (ze, et) { return (we.event = ze) && se && ~se.indexOf(ze.target) || et && rt && ze.pointerType !== "touch" || xe && xe(ze, et) }, Xt = function () { we._vx.reset(), we._vy.reset(), Ye.pause(), oe && oe(we) }, It = function () { var ze = we.deltaX = _getAbsoluteMax(St), et = we.deltaY = _getAbsoluteMax(_t), Le = Math.abs(ze) >= X, He = Math.abs(et) >= X; Ce && (Le || He) && Ce(we, ze, et, St, _t), Le && (ue && we.deltaX > 0 && ue(we), me && we.deltaX < 0 && me(we), Se && Se(we), Ee && we.deltaX < 0 != Ge < 0 && Ee(we), Ge = we.deltaX, St[0] = St[1] = St[2] = 0), He && (ve && we.deltaY > 0 && ve(we), ge && we.deltaY < 0 && ge(we), ke && ke(we), De && we.deltaY < 0 != Oe < 0 && De(we), Oe = we.deltaY, _t[0] = _t[1] = _t[2] = 0), (Re || Xe) && (ye && ye(we), Xe && (fe && Xe === 1 && fe(we), he && he(we), Xe = 0), Re = !1), it && !(it = !1) && Qe && Qe(we), Me && (be(we), Me = !1), Ue = 0 }, zt = function (ze, et, Le) { St[Le] += ze, _t[Le] += et, we._vx.update(ze), we._vy.update(et), ee ? Ue || (Ue = requestAnimationFrame(It)) : It() }, Gt = function (ze, et) { Ze && !nt && (we.axis = nt = Math.abs(ze) > Math.abs(et) ? "x" : "y", it = !0), nt !== "y" && (St[2] += ze, we._vx.update(ze, !0)), nt !== "x" && (_t[2] += et, we._vy.update(et, !0)), ee ? Ue || (Ue = requestAnimationFrame(It)) : It() }, Rt = function (ze) { if (!pt(ze, 1)) { ze = _getEvent(ze, te); var et = ze.clientX, Le = ze.clientY, He = et - we.x, Ne = Le - we.y, qe = we.isDragging; we.x = et, we.y = Le, (qe || (He || Ne) && (Math.abs(we.startX - et) >= K || Math.abs(we.startY - Le) >= K)) && (Xe = qe ? 2 : 1, qe || (we.isDragging = !0), Gt(He, Ne)) } }, Bt = we.onPress = function (je) { pt(je, 1) || je && je.button || (we.axis = nt = null, Ye.pause(), we.isPressed = !0, je = _getEvent(je), Ge = Oe = 0, we.startX = we.x = je.clientX, we.startY = we.y = je.clientY, we._vx.reset(), we._vy.reset(), _addListener$1(pe ? Z : tt, _eventTypes[1], Rt, at, !0), we.deltaX = we.deltaY = 0, le && le(we)) }, Ke = we.onRelease = function (je) { if (!pt(je, 1)) { _removeListener$1(pe ? Z : tt, _eventTypes[1], Rt, !0); var ze = !isNaN(we.y - we.startY), et = we.isDragging, Le = et && (Math.abs(we.x - we.startX) > 3 || Math.abs(we.y - we.startY) > 3), He = _getEvent(je); !Le && ze && (we._vx.reset(), we._vy.reset(), te && Ve && gsap$6.delayedCall(.08, function () { if (_getTime$1() - Tt > 300 && !je.defaultPrevented) { if (je.target.click) je.target.click(); else if (tt.createEvent) { var Ne = tt.createEvent("MouseEvents"); Ne.initMouseEvent("click", !0, !0, _win$2, 1, He.screenX, He.screenY, He.clientX, He.clientY, !1, !1, !1, !1, 0, null), je.target.dispatchEvent(Ne) } } })), we.isDragging = we.isGesturing = we.isPressed = !1, oe && et && !pe && Ye.restart(!0), Xe && It(), ae && et && ae(we), ce && ce(we, Le) } }, Vt = function (ze) { return ze.touches && ze.touches.length > 1 && (we.isGesturing = !0) && de(ze, we.isDragging) }, wt = function () { return (we.isGesturing = !1) || _e(we) }, Dt = function (ze) { if (!pt(ze)) { var et = We(), Le = ot(); zt((et - dt) * Ie, (Le - mt) * Ie, 1), dt = et, mt = Le, oe && Ye.restart(!0) } }, Pt = function (ze) { if (!pt(ze)) { ze = _getEvent(ze, te), be && (Me = !0); var et = (ze.deltaMode === 1 ? Q : ze.deltaMode === 2 ? _win$2.innerHeight : 1) * ne; zt(ze.deltaX * et, ze.deltaY * et, 0), oe && !pe && Ye.restart(!0) } }, Ot = function (ze) { if (!pt(ze)) { var et = ze.clientX, Le = ze.clientY, He = et - we.x, Ne = Le - we.y; we.x = et, we.y = Le, Re = !0, oe && Ye.restart(!0), (He || Ne) && Gt(He, Ne) } }, Wt = function (ze) { we.event = ze, Pe(we) }, Lt = function (ze) { we.event = ze, Te(we) }, qt = function (ze) { return pt(ze) || _getEvent(ze, te) && Fe(we) }; Ye = we._dc = gsap$6.delayedCall(ie || .25, Xt).pause(), we.deltaX = we.deltaY = 0, we._vx = _getVelocityProp(0, 50, !0), we._vy = _getVelocityProp(0, 50, !0), we.scrollX = We, we.scrollY = ot, we.isDragging = we.isGesturing = we.isPressed = !1, _context$1(this), we.enable = function (je) { return we.isEnabled || (_addListener$1(ut ? tt : Z, "scroll", _onScroll$1), J.indexOf("scroll") >= 0 && _addListener$1(ut ? tt : Z, "scroll", Dt, at, Be), J.indexOf("wheel") >= 0 && _addListener$1(Z, "wheel", Pt, at, Be), (J.indexOf("touch") >= 0 && _isTouch || J.indexOf("pointer") >= 0) && (_addListener$1(Z, _eventTypes[0], Bt, at, Be), _addListener$1(tt, _eventTypes[2], Ke), _addListener$1(tt, _eventTypes[3], Ke), Ve && _addListener$1(Z, "click", Ht, !0, !0), Fe && _addListener$1(Z, "click", qt), de && _addListener$1(tt, "gesturestart", Vt), _e && _addListener$1(tt, "gestureend", wt), Pe && _addListener$1(Z, _pointerType + "enter", Wt), Te && _addListener$1(Z, _pointerType + "leave", Lt), ye && _addListener$1(Z, _pointerType + "move", Ot)), we.isEnabled = !0, we.isDragging = we.isGesturing = we.isPressed = Re = Xe = !1, we._vx.reset(), we._vy.reset(), dt = We(), mt = ot(), je && je.type && Bt(je), Ae && Ae(we)), we }, we.disable = function () { we.isEnabled && (_observers.filter(function (je) { return je !== we && _isViewport$1(je.target) }).length || _removeListener$1(ut ? tt : Z, "scroll", _onScroll$1), we.isPressed && (we._vx.reset(), we._vy.reset(), _removeListener$1(pe ? Z : tt, _eventTypes[1], Rt, !0)), _removeListener$1(ut ? tt : Z, "scroll", Dt, Be), _removeListener$1(Z, "wheel", Pt, Be), _removeListener$1(Z, _eventTypes[0], Bt, Be), _removeListener$1(tt, _eventTypes[2], Ke), _removeListener$1(tt, _eventTypes[3], Ke), _removeListener$1(Z, "click", Ht, !0), _removeListener$1(Z, "click", qt), _removeListener$1(tt, "gesturestart", Vt), _removeListener$1(tt, "gestureend", wt), _removeListener$1(Z, _pointerType + "enter", Wt), _removeListener$1(Z, _pointerType + "leave", Lt), _removeListener$1(Z, _pointerType + "move", Ot), we.isEnabled = we.isPressed = we.isDragging = !1, $e && $e(we)) }, we.kill = we.revert = function () { we.disable(); var je = _observers.indexOf(we); je >= 0 && _observers.splice(je, 1), _normalizer$1 === we && (_normalizer$1 = 0) }, _observers.push(we), pe && _isViewport$1(Z) && (_normalizer$1 = we), we.enable(re) }, _createClass(z, [{ key: "velocityX", get: function () { return this._vx.getVelocity() } }, { key: "velocityY", get: function () { return this._vy.getVelocity() } }]), z }(); Observer.version = "3.12.7"; Observer.create = function (z) { return new Observer(z) }; Observer.register = _initCore$4; Observer.getAll = function () { return _observers.slice() }; Observer.getById = function (z) { return _observers.filter(function (F) { return F.vars.id === z })[0] }; _getGSAP$6() && gsap$6.registerPlugin(Observer);/*!
 * ScrollTrigger 3.12.7
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/var gsap$5, _coreInitted$4, _win$1, _doc, _docEl$1, _body$1, _root, _resizeDelay, _toArray$2, _clamp, _time2, _syncInterval, _refreshing, _pointerIsDown, _transformProp, _i, _prevWidth, _prevHeight, _autoRefresh, _sort, _suppressOverwrites, _ignoreResize, _normalizer, _ignoreMobileResize, _baseScreenHeight, _baseScreenWidth, _fixIOSBug, _context, _scrollRestoration, _div100vh, _100vh, _isReverted, _clampingMax, _limitCallbacks, _startup = 1, _getTime = Date.now, _time1 = _getTime(), _lastScrollTime = 0, _enabled = 0, _parseClamp = function (F, G, Y) { var X = _isString$1(F) && (F.substr(0, 6) === "clamp(" || F.indexOf("max") > -1); return Y["_" + G + "Clamp"] = X, X ? F.substr(6, F.length - 7) : F }, _keepClamp = function (F, G) { return G && (!_isString$1(F) || F.substr(0, 6) !== "clamp(") ? "clamp(" + F + ")" : F }, _rafBugFix = function z() { return _enabled && requestAnimationFrame(z) }, _pointerDownHandler = function () { return _pointerIsDown = 1 }, _pointerUpHandler = function () { return _pointerIsDown = 0 }, _passThrough = function (F) { return F }, _round$3 = function (F) { return Math.round(F * 1e5) / 1e5 || 0 }, _windowExists$2 = function () { return typeof window < "u" }, _getGSAP$5 = function () { return gsap$5 || _windowExists$2() && (gsap$5 = window.gsap) && gsap$5.registerPlugin && gsap$5 }, _isViewport = function (F) { return !!~_root.indexOf(F) }, _getViewportDimension = function (F) { return (F === "Height" ? _100vh : _win$1["inner" + F]) || _docEl$1["client" + F] || _body$1["client" + F] }, _getBoundsFunc = function (F) { return _getProxyProp(F, "getBoundingClientRect") || (_isViewport(F) ? function () { return _winOffsets.width = _win$1.innerWidth, _winOffsets.height = _100vh, _winOffsets } : function () { return _getBounds(F) }) }, _getSizeFunc = function (F, G, Y) { var X = Y.d, K = Y.d2, J = Y.a; return (J = _getProxyProp(F, "getBoundingClientRect")) ? function () { return J()[X] } : function () { return (G ? _getViewportDimension(K) : F["client" + K]) || 0 } }, _getOffsetsFunc = function (F, G) { return !G || ~_proxies.indexOf(F) ? _getBoundsFunc(F) : function () { return _winOffsets } }, _maxScroll = function (F, G) { var Y = G.s, X = G.d2, K = G.d, J = G.a; return Math.max(0, (Y = "scroll" + X) && (J = _getProxyProp(F, Y)) ? J() - _getBoundsFunc(F)()[K] : _isViewport(F) ? (_docEl$1[Y] || _body$1[Y]) - _getViewportDimension(X) : F[Y] - F["offset" + X]) }, _iterateAutoRefresh = function (F, G) { for (var Y = 0; Y < _autoRefresh.length; Y += 3)(!G || ~G.indexOf(_autoRefresh[Y + 1])) && F(_autoRefresh[Y], _autoRefresh[Y + 1], _autoRefresh[Y + 2]) }, _isString$1 = function (F) { return typeof F == "string" }, _isFunction$1 = function (F) { return typeof F == "function" }, _isNumber$1 = function (F) { return typeof F == "number" }, _isObject = function (F) { return typeof F == "object" }, _endAnimation = function (F, G, Y) { return F && F.progress(G ? 0 : 1) && Y && F.pause() }, _callback = function (F, G) { if (F.enabled) { var Y = F._ctx ? F._ctx.add(function () { return G(F) }) : G(F); Y && Y.totalTime && (F.callbackAnimation = Y) } }, _abs$1 = Math.abs, _left = "left", _top = "top", _right = "right", _bottom = "bottom", _width = "width", _height = "height", _Right = "Right", _Left = "Left", _Top = "Top", _Bottom = "Bottom", _padding = "padding", _margin = "margin", _Width = "Width", _Height = "Height", _px = "px", _getComputedStyle = function (F) { return _win$1.getComputedStyle(F) }, _makePositionable = function (F) { var G = _getComputedStyle(F).position; F.style.position = G === "absolute" || G === "fixed" ? G : "relative" }, _setDefaults = function (F, G) { for (var Y in G) Y in F || (F[Y] = G[Y]); return F }, _getBounds = function (F, G) { var Y = G && _getComputedStyle(F)[_transformProp] !== "matrix(1, 0, 0, 1, 0, 0)" && gsap$5.to(F, { x: 0, y: 0, xPercent: 0, yPercent: 0, rotation: 0, rotationX: 0, rotationY: 0, scale: 1, skewX: 0, skewY: 0 }).progress(1), X = F.getBoundingClientRect(); return Y && Y.progress(0).kill(), X }, _getSize = function (F, G) { var Y = G.d2; return F["offset" + Y] || F["client" + Y] || 0 }, _getLabelRatioArray = function (F) { var G = [], Y = F.labels, X = F.duration(), K; for (K in Y) G.push(Y[K] / X); return G }, _getClosestLabel = function (F) { return function (G) { return gsap$5.utils.snap(_getLabelRatioArray(F), G) } }, _snapDirectional = function (F) { var G = gsap$5.utils.snap(F), Y = Array.isArray(F) && F.slice(0).sort(function (X, K) { return X - K }); return Y ? function (X, K, J) { J === void 0 && (J = .001); var Z; if (!K) return G(X); if (K > 0) { for (X -= J, Z = 0; Z < Y.length; Z++)if (Y[Z] >= X) return Y[Z]; return Y[Z - 1] } else for (Z = Y.length, X += J; Z--;)if (Y[Z] <= X) return Y[Z]; return Y[0] } : function (X, K, J) { J === void 0 && (J = .001); var Z = G(X); return !K || Math.abs(Z - X) < J || Z - X < 0 == K < 0 ? Z : G(K < 0 ? X - F : X + F) } }, _getLabelAtDirection = function (F) { return function (G, Y) { return _snapDirectional(_getLabelRatioArray(F))(G, Y.direction) } }, _multiListener = function (F, G, Y, X) { return Y.split(",").forEach(function (K) { return F(G, K, X) }) }, _addListener = function (F, G, Y, X, K) { return F.addEventListener(G, Y, { passive: !X, capture: !!K }) }, _removeListener = function (F, G, Y, X) { return F.removeEventListener(G, Y, !!X) }, _wheelListener = function (F, G, Y) { Y = Y && Y.wheelHandler, Y && (F(G, "wheel", Y), F(G, "touchmove", Y)) }, _markerDefaults = { startColor: "green", endColor: "red", indent: 0, fontSize: "16px", fontWeight: "normal" }, _defaults = { toggleActions: "play", anticipatePin: 0 }, _keywords = { top: 0, left: 0, center: .5, bottom: 1, right: 1 }, _offsetToPx = function (F, G) { if (_isString$1(F)) { var Y = F.indexOf("="), X = ~Y ? +(F.charAt(Y - 1) + 1) * parseFloat(F.substr(Y + 1)) : 0; ~Y && (F.indexOf("%") > Y && (X *= G / 100), F = F.substr(0, Y - 1)), F = X + (F in _keywords ? _keywords[F] * G : ~F.indexOf("%") ? parseFloat(F) * G / 100 : parseFloat(F) || 0) } return F }, _createMarker = function (F, G, Y, X, K, J, Z, Q) { var ee = K.startColor, te = K.endColor, oe = K.fontSize, ie = K.indent, se = K.fontWeight, ne = _doc.createElement("div"), re = _isViewport(Y) || _getProxyProp(Y, "pinType") === "fixed", fe = F.indexOf("scroller") !== -1, ae = re ? _body$1 : Y, he = F.indexOf("start") !== -1, le = he ? ee : te, ce = "border-color:" + le + ";font-size:" + oe + ";color:" + le + ";font-weight:" + se + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;"; return ce += "position:" + ((fe || Q) && re ? "fixed;" : "absolute;"), (fe || Q || !re) && (ce += (X === _vertical ? _right : _bottom) + ":" + (J + parseFloat(ie)) + "px;"), Z && (ce += "box-sizing:border-box;text-align:left;width:" + Z.offsetWidth + "px;"), ne._isStart = he, ne.setAttribute("class", "gsap-marker-" + F + (G ? " marker-" + G : "")), ne.style.cssText = ce, ne.innerText = G || G === 0 ? F + "-" + G : F, ae.children[0] ? ae.insertBefore(ne, ae.children[0]) : ae.appendChild(ne), ne._offset = ne["offset" + X.op.d2], _positionMarker(ne, 0, X, he), ne }, _positionMarker = function (F, G, Y, X) { var K = { display: "block" }, J = Y[X ? "os2" : "p2"], Z = Y[X ? "p2" : "os2"]; F._isFlipped = X, K[Y.a + "Percent"] = X ? -100 : 0, K[Y.a] = X ? "1px" : 0, K["border" + J + _Width] = 1, K["border" + Z + _Width] = 0, K[Y.p] = G + "px", gsap$5.set(F, K) }, _triggers = [], _ids = {}, _rafID, _sync = function () { return _getTime() - _lastScrollTime > 34 && (_rafID || (_rafID = requestAnimationFrame(_updateAll))) }, _onScroll = function () { (!_normalizer || !_normalizer.isPressed || _normalizer.startX > _body$1.clientWidth) && (_scrollers.cache++, _normalizer ? _rafID || (_rafID = requestAnimationFrame(_updateAll)) : _updateAll(), _lastScrollTime || _dispatch("scrollStart"), _lastScrollTime = _getTime()) }, _setBaseDimensions = function () { _baseScreenWidth = _win$1.innerWidth, _baseScreenHeight = _win$1.innerHeight }, _onResize = function (F) { _scrollers.cache++, (F === !0 || !_refreshing && !_ignoreResize && !_doc.fullscreenElement && !_doc.webkitFullscreenElement && (!_ignoreMobileResize || _baseScreenWidth !== _win$1.innerWidth || Math.abs(_win$1.innerHeight - _baseScreenHeight) > _win$1.innerHeight * .25)) && _resizeDelay.restart(!0) }, _listeners = {}, _emptyArray = [], _softRefresh = function z() { return _removeListener(ScrollTrigger$1, "scrollEnd", z) || _refreshAll(!0) }, _dispatch = function (F) { return _listeners[F] && _listeners[F].map(function (G) { return G() }) || _emptyArray }, _savedStyles = [], _revertRecorded = function (F) { for (var G = 0; G < _savedStyles.length; G += 5)(!F || _savedStyles[G + 4] && _savedStyles[G + 4].query === F) && (_savedStyles[G].style.cssText = _savedStyles[G + 1], _savedStyles[G].getBBox && _savedStyles[G].setAttribute("transform", _savedStyles[G + 2] || ""), _savedStyles[G + 3].uncache = 1) }, _revertAll = function (F, G) { var Y; for (_i = 0; _i < _triggers.length; _i++)Y = _triggers[_i], Y && (!G || Y._ctx === G) && (F ? Y.kill(1) : Y.revert(!0, !0)); _isReverted = !0, G && _revertRecorded(G), G || _dispatch("revert") }, _clearScrollMemory = function (F, G) { _scrollers.cache++, (G || !_refreshingAll) && _scrollers.forEach(function (Y) { return _isFunction$1(Y) && Y.cacheID++ && (Y.rec = 0) }), _isString$1(F) && (_win$1.history.scrollRestoration = _scrollRestoration = F) }, _refreshingAll, _refreshID = 0, _queueRefreshID, _queueRefreshAll = function () { if (_queueRefreshID !== _refreshID) { var F = _queueRefreshID = _refreshID; requestAnimationFrame(function () { return F === _refreshID && _refreshAll(!0) }) } }, _refresh100vh = function () { _body$1.appendChild(_div100vh), _100vh = !_normalizer && _div100vh.offsetHeight || _win$1.innerHeight, _body$1.removeChild(_div100vh) }, _hideAllMarkers = function (F) { return _toArray$2(".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end").forEach(function (G) { return G.style.display = F ? "none" : "block" }) }, _refreshAll = function (F, G) { if (_docEl$1 = _doc.documentElement, _body$1 = _doc.body, _root = [_win$1, _doc, _docEl$1, _body$1], _lastScrollTime && !F && !_isReverted) { _addListener(ScrollTrigger$1, "scrollEnd", _softRefresh); return } _refresh100vh(), _refreshingAll = ScrollTrigger$1.isRefreshing = !0, _scrollers.forEach(function (X) { return _isFunction$1(X) && ++X.cacheID && (X.rec = X()) }); var Y = _dispatch("refreshInit"); _sort && ScrollTrigger$1.sort(), G || _revertAll(), _scrollers.forEach(function (X) { _isFunction$1(X) && (X.smooth && (X.target.style.scrollBehavior = "auto"), X(0)) }), _triggers.slice(0).forEach(function (X) { return X.refresh() }), _isReverted = !1, _triggers.forEach(function (X) { if (X._subPinOffset && X.pin) { var K = X.vars.horizontal ? "offsetWidth" : "offsetHeight", J = X.pin[K]; X.revert(!0, 1), X.adjustPinSpacing(X.pin[K] - J), X.refresh() } }), _clampingMax = 1, _hideAllMarkers(!0), _triggers.forEach(function (X) { var K = _maxScroll(X.scroller, X._dir), J = X.vars.end === "max" || X._endClamp && X.end > K, Z = X._startClamp && X.start >= K; (J || Z) && X.setPositions(Z ? K - 1 : X.start, J ? Math.max(Z ? K : X.start + 1, K) : X.end, !0) }), _hideAllMarkers(!1), _clampingMax = 0, Y.forEach(function (X) { return X && X.render && X.render(-1) }), _scrollers.forEach(function (X) { _isFunction$1(X) && (X.smooth && requestAnimationFrame(function () { return X.target.style.scrollBehavior = "smooth" }), X.rec && X(X.rec)) }), _clearScrollMemory(_scrollRestoration, 1), _resizeDelay.pause(), _refreshID++, _refreshingAll = 2, _updateAll(2), _triggers.forEach(function (X) { return _isFunction$1(X.vars.onRefresh) && X.vars.onRefresh(X) }), _refreshingAll = ScrollTrigger$1.isRefreshing = !1, _dispatch("refresh") }, _lastScroll = 0, _direction = 1, _primary, _updateAll = function (F) { if (F === 2 || !_refreshingAll && !_isReverted) { ScrollTrigger$1.isUpdating = !0, _primary && _primary.update(0); var G = _triggers.length, Y = _getTime(), X = Y - _time1 >= 50, K = G && _triggers[0].scroll(); if (_direction = _lastScroll > K ? -1 : 1, _refreshingAll || (_lastScroll = K), X && (_lastScrollTime && !_pointerIsDown && Y - _lastScrollTime > 200 && (_lastScrollTime = 0, _dispatch("scrollEnd")), _time2 = _time1, _time1 = Y), _direction < 0) { for (_i = G; _i-- > 0;)_triggers[_i] && _triggers[_i].update(0, X); _direction = 1 } else for (_i = 0; _i < G; _i++)_triggers[_i] && _triggers[_i].update(0, X); ScrollTrigger$1.isUpdating = !1 } _rafID = 0 }, _propNamesToCopy = [_left, _top, _bottom, _right, _margin + _Bottom, _margin + _Right, _margin + _Top, _margin + _Left, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"], _stateProps = _propNamesToCopy.concat([_width, _height, "boxSizing", "max" + _Width, "max" + _Height, "position", _margin, _padding, _padding + _Top, _padding + _Right, _padding + _Bottom, _padding + _Left]), _swapPinOut = function (F, G, Y) { _setState(Y); var X = F._gsap; if (X.spacerIsNative) _setState(X.spacerState); else if (F._gsap.swappedIn) { var K = G.parentNode; K && (K.insertBefore(F, G), K.removeChild(G)) } F._gsap.swappedIn = !1 }, _swapPinIn = function (F, G, Y, X) { if (!F._gsap.swappedIn) { for (var K = _propNamesToCopy.length, J = G.style, Z = F.style, Q; K--;)Q = _propNamesToCopy[K], J[Q] = Y[Q]; J.position = Y.position === "absolute" ? "absolute" : "relative", Y.display === "inline" && (J.display = "inline-block"), Z[_bottom] = Z[_right] = "auto", J.flexBasis = Y.flexBasis || "auto", J.overflow = "visible", J.boxSizing = "border-box", J[_width] = _getSize(F, _horizontal) + _px, J[_height] = _getSize(F, _vertical) + _px, J[_padding] = Z[_margin] = Z[_top] = Z[_left] = "0", _setState(X), Z[_width] = Z["max" + _Width] = Y[_width], Z[_height] = Z["max" + _Height] = Y[_height], Z[_padding] = Y[_padding], F.parentNode !== G && (F.parentNode.insertBefore(G, F), G.appendChild(F)), F._gsap.swappedIn = !0 } }, _capsExp = /([A-Z])/g, _setState = function (F) { if (F) { var G = F.t.style, Y = F.length, X = 0, K, J; for ((F.t._gsap || gsap$5.core.getCache(F.t)).uncache = 1; X < Y; X += 2)J = F[X + 1], K = F[X], J ? G[K] = J : G[K] && G.removeProperty(K.replace(_capsExp, "-$1").toLowerCase()) } }, _getState = function (F) { for (var G = _stateProps.length, Y = F.style, X = [], K = 0; K < G; K++)X.push(_stateProps[K], Y[_stateProps[K]]); return X.t = F, X }, _copyState = function (F, G, Y) { for (var X = [], K = F.length, J = Y ? 8 : 0, Z; J < K; J += 2)Z = F[J], X.push(Z, Z in G ? G[Z] : F[J + 1]); return X.t = F.t, X }, _winOffsets = { left: 0, top: 0 }, _parsePosition = function (F, G, Y, X, K, J, Z, Q, ee, te, oe, ie, se, ne) { _isFunction$1(F) && (F = F(Q)), _isString$1(F) && F.substr(0, 3) === "max" && (F = ie + (F.charAt(4) === "=" ? _offsetToPx("0" + F.substr(3), Y) : 0)); var re = se ? se.time() : 0, fe, ae, he; if (se && se.seek(0), isNaN(F) || (F = +F), _isNumber$1(F)) se && (F = gsap$5.utils.mapRange(se.scrollTrigger.start, se.scrollTrigger.end, 0, ie, F)), Z && _positionMarker(Z, Y, X, !0); else { _isFunction$1(G) && (G = G(Q)); var le = (F || "0").split(" "), ce, ue, me, ge; he = _getTarget(G, Q) || _body$1, ce = _getBounds(he) || {}, (!ce || !ce.left && !ce.top) && _getComputedStyle(he).display === "none" && (ge = he.style.display, he.style.display = "block", ce = _getBounds(he), ge ? he.style.display = ge : he.style.removeProperty("display")), ue = _offsetToPx(le[0], ce[X.d]), me = _offsetToPx(le[1] || "0", Y), F = ce[X.p] - ee[X.p] - te + ue + K - me, Z && _positionMarker(Z, me, X, Y - me < 20 || Z._isStart && me > 20), Y -= Y - me } if (ne && (Q[ne] = F || -.001, F < 0 && (F = 0)), J) { var ve = F + Y, Se = J._isStart; fe = "scroll" + X.d2, _positionMarker(J, ve, X, Se && ve > 20 || !Se && (oe ? Math.max(_body$1[fe], _docEl$1[fe]) : J.parentNode[fe]) <= ve + 1), oe && (ee = _getBounds(Z), oe && (J.style[X.op.p] = ee[X.op.p] - X.op.m - J._offset + _px)) } return se && he && (fe = _getBounds(he), se.seek(ie), ae = _getBounds(he), se._caScrollDist = fe[X.p] - ae[X.p], F = F / se._caScrollDist * ie), se && se.seek(re), se ? F : Math.round(F) }, _prefixExp = /(webkit|moz|length|cssText|inset)/i, _reparent = function (F, G, Y, X) { if (F.parentNode !== G) { var K = F.style, J, Z; if (G === _body$1) { F._stOrig = K.cssText, Z = _getComputedStyle(F); for (J in Z) !+J && !_prefixExp.test(J) && Z[J] && typeof K[J] == "string" && J !== "0" && (K[J] = Z[J]); K.top = Y, K.left = X } else K.cssText = F._stOrig; gsap$5.core.getCache(F).uncache = 1, G.appendChild(F) } }, _interruptionTracker = function (F, G, Y) { var X = G, K = X; return function (J) { var Z = Math.round(F()); return Z !== X && Z !== K && Math.abs(Z - X) > 3 && Math.abs(Z - K) > 3 && (J = Z, Y && Y()), K = X, X = Math.round(J), X } }, _shiftMarker = function (F, G, Y) { var X = {}; X[G.p] = "+=" + Y, gsap$5.set(F, X) }, _getTweenCreator = function (F, G) { var Y = _getScrollFunc(F, G), X = "_scroll" + G.p2, K = function J(Z, Q, ee, te, oe) { var ie = J.tween, se = Q.onComplete, ne = {}; ee = ee || Y(); var re = _interruptionTracker(Y, ee, function () { ie.kill(), J.tween = 0 }); return oe = te && oe || 0, te = te || Z - ee, ie && ie.kill(), Q[X] = Z, Q.inherit = !1, Q.modifiers = ne, ne[X] = function () { return re(ee + te * ie.ratio + oe * ie.ratio * ie.ratio) }, Q.onUpdate = function () { _scrollers.cache++, J.tween && _updateAll() }, Q.onComplete = function () { J.tween = 0, se && se.call(ie) }, ie = J.tween = gsap$5.to(F, Q), ie }; return F[X] = Y, Y.wheelHandler = function () { return K.tween && K.tween.kill() && (K.tween = 0) }, _addListener(F, "wheel", Y.wheelHandler), ScrollTrigger$1.isTouch && _addListener(F, "touchmove", Y.wheelHandler), K }, ScrollTrigger$1 = function () { function z(G, Y) { _coreInitted$4 || z.register(gsap$5) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"), _context(this), this.init(G, Y) } var F = z.prototype; return F.init = function (Y, X) { if (this.progress = this.start = 0, this.vars && this.kill(!0, !0), !_enabled) { this.update = this.refresh = this.kill = _passThrough; return } Y = _setDefaults(_isString$1(Y) || _isNumber$1(Y) || Y.nodeType ? { trigger: Y } : Y, _defaults); var K = Y, J = K.onUpdate, Z = K.toggleClass, Q = K.id, ee = K.onToggle, te = K.onRefresh, oe = K.scrub, ie = K.trigger, se = K.pin, ne = K.pinSpacing, re = K.invalidateOnRefresh, fe = K.anticipatePin, ae = K.onScrubComplete, he = K.onSnapComplete, le = K.once, ce = K.snap, ue = K.pinReparent, me = K.pinSpacer, ge = K.containerAnimation, ve = K.fastScrollEnd, Se = K.preventOverlaps, ke = Y.horizontal || Y.containerAnimation && Y.horizontal !== !1 ? _horizontal : _vertical, Ce = !oe && oe !== 0, Ee = _getTarget(Y.scroller || _win$1), De = gsap$5.core.getCache(Ee), Pe = _isViewport(Ee), Te = ("pinType" in Y ? Y.pinType : _getProxyProp(Ee, "pinType") || Pe && "fixed") === "fixed", ye = [Y.onEnter, Y.onLeave, Y.onEnterBack, Y.onLeaveBack], xe = Ce && Y.toggleActions.split(" "), pe = "markers" in Y ? Y.markers : _defaults.markers, de = Pe ? 0 : parseFloat(_getComputedStyle(Ee)["border" + ke.p2 + _Width]) || 0, _e = this, be = Y.onRefreshInit && function () { return Y.onRefreshInit(_e) }, Ae = _getSizeFunc(Ee, Pe, ke), $e = _getOffsetsFunc(Ee, Pe), Fe = 0, Ie = 0, Be = 0, Ve = _getScrollFunc(Ee, ke), Ze, Qe, Ue, Ye, Xe, Re, Me, it, nt, we, Ge, Oe, at, We, ot, dt, mt, rt, ut, tt, St, _t, Tt, Ht, pt, Xt, It, zt, Gt, Rt, Bt, Ke, Vt, wt, Dt, Pt, Ot, Wt, Lt; if (_e._startClamp = _e._endClamp = !1, _e._dir = ke, fe *= 45, _e.scroller = Ee, _e.scroll = ge ? ge.time.bind(ge) : Ve, Ye = Ve(), _e.vars = Y, X = X || Y.animation, "refreshPriority" in Y && (_sort = 1, Y.refreshPriority === -9999 && (_primary = _e)), De.tweenScroll = De.tweenScroll || { top: _getTweenCreator(Ee, _vertical), left: _getTweenCreator(Ee, _horizontal) }, _e.tweenTo = Ze = De.tweenScroll[ke.p], _e.scrubDuration = function (Le) { Vt = _isNumber$1(Le) && Le, Vt ? Ke ? Ke.duration(Le) : Ke = gsap$5.to(X, { ease: "expo", totalProgress: "+=0", inherit: !1, duration: Vt, paused: !0, onComplete: function () { return ae && ae(_e) } }) : (Ke && Ke.progress(1).kill(), Ke = 0) }, X && (X.vars.lazy = !1, X._initted && !_e.isReverted || X.vars.immediateRender !== !1 && Y.immediateRender !== !1 && X.duration() && X.render(0, !0, !0), _e.animation = X.pause(), X.scrollTrigger = _e, _e.scrubDuration(oe), Rt = 0, Q || (Q = X.vars.id)), ce && ((!_isObject(ce) || ce.push) && (ce = { snapTo: ce }), "scrollBehavior" in _body$1.style && gsap$5.set(Pe ? [_body$1, _docEl$1] : Ee, { scrollBehavior: "auto" }), _scrollers.forEach(function (Le) { return _isFunction$1(Le) && Le.target === (Pe ? _doc.scrollingElement || _docEl$1 : Ee) && (Le.smooth = !1) }), Ue = _isFunction$1(ce.snapTo) ? ce.snapTo : ce.snapTo === "labels" ? _getClosestLabel(X) : ce.snapTo === "labelsDirectional" ? _getLabelAtDirection(X) : ce.directional !== !1 ? function (Le, He) { return _snapDirectional(ce.snapTo)(Le, _getTime() - Ie < 500 ? 0 : He.direction) } : gsap$5.utils.snap(ce.snapTo), wt = ce.duration || { min: .1, max: 2 }, wt = _isObject(wt) ? _clamp(wt.min, wt.max) : _clamp(wt, wt), Dt = gsap$5.delayedCall(ce.delay || Vt / 2 || .1, function () { var Le = Ve(), He = _getTime() - Ie < 500, Ne = Ze.tween; if ((He || Math.abs(_e.getVelocity()) < 10) && !Ne && !_pointerIsDown && Fe !== Le) { var qe = (Le - Re) / We, yt = X && !Ce ? X.totalProgress() : qe, Je = He ? 0 : (yt - Bt) / (_getTime() - _time2) * 1e3 || 0, ft = gsap$5.utils.clamp(-qe, 1 - qe, _abs$1(Je / 2) * Je / .185), bt = qe + (ce.inertia === !1 ? 0 : ft), ct, lt, st = ce, At = st.onStart, ht = st.onInterrupt, Ct = st.onComplete; if (ct = Ue(bt, _e), _isNumber$1(ct) || (ct = bt), lt = Math.max(0, Math.round(Re + ct * We)), Le <= Me && Le >= Re && lt !== Le) { if (Ne && !Ne._initted && Ne.data <= _abs$1(lt - Le)) return; ce.inertia === !1 && (ft = ct - qe), Ze(lt, { duration: wt(_abs$1(Math.max(_abs$1(bt - yt), _abs$1(ct - yt)) * .185 / Je / .05 || 0)), ease: ce.ease || "power3", data: _abs$1(lt - Le), onInterrupt: function () { return Dt.restart(!0) && ht && ht(_e) }, onComplete: function () { _e.update(), Fe = Ve(), X && !Ce && (Ke ? Ke.resetTo("totalProgress", ct, X._tTime / X._tDur) : X.progress(ct)), Rt = Bt = X && !Ce ? X.totalProgress() : _e.progress, he && he(_e), Ct && Ct(_e) } }, Le, ft * We, lt - Le - ft * We), At && At(_e, Ze.tween) } } else _e.isActive && Fe !== Le && Dt.restart(!0) }).pause()), Q && (_ids[Q] = _e), ie = _e.trigger = _getTarget(ie || se !== !0 && se), Lt = ie && ie._gsap && ie._gsap.stRevert, Lt && (Lt = Lt(_e)), se = se === !0 ? ie : _getTarget(se), _isString$1(Z) && (Z = { targets: ie, className: Z }), se && (ne === !1 || ne === _margin || (ne = !ne && se.parentNode && se.parentNode.style && _getComputedStyle(se.parentNode).display === "flex" ? !1 : _padding), _e.pin = se, Qe = gsap$5.core.getCache(se), Qe.spacer ? ot = Qe.pinState : (me && (me = _getTarget(me), me && !me.nodeType && (me = me.current || me.nativeElement), Qe.spacerIsNative = !!me, me && (Qe.spacerState = _getState(me))), Qe.spacer = rt = me || _doc.createElement("div"), rt.classList.add("pin-spacer"), Q && rt.classList.add("pin-spacer-" + Q), Qe.pinState = ot = _getState(se)), Y.force3D !== !1 && gsap$5.set(se, { force3D: !0 }), _e.spacer = rt = Qe.spacer, Gt = _getComputedStyle(se), Ht = Gt[ne + ke.os2], tt = gsap$5.getProperty(se), St = gsap$5.quickSetter(se, ke.a, _px), _swapPinIn(se, rt, Gt), mt = _getState(se)), pe) { Oe = _isObject(pe) ? _setDefaults(pe, _markerDefaults) : _markerDefaults, we = _createMarker("scroller-start", Q, Ee, ke, Oe, 0), Ge = _createMarker("scroller-end", Q, Ee, ke, Oe, 0, we), ut = we["offset" + ke.op.d2]; var qt = _getTarget(_getProxyProp(Ee, "content") || Ee); it = this.markerStart = _createMarker("start", Q, qt, ke, Oe, ut, 0, ge), nt = this.markerEnd = _createMarker("end", Q, qt, ke, Oe, ut, 0, ge), ge && (Wt = gsap$5.quickSetter([it, nt], ke.a, _px)), !Te && !(_proxies.length && _getProxyProp(Ee, "fixedMarkers") === !0) && (_makePositionable(Pe ? _body$1 : Ee), gsap$5.set([we, Ge], { force3D: !0 }), Xt = gsap$5.quickSetter(we, ke.a, _px), zt = gsap$5.quickSetter(Ge, ke.a, _px)) } if (ge) { var je = ge.vars.onUpdate, ze = ge.vars.onUpdateParams; ge.eventCallback("onUpdate", function () { _e.update(0, 0, 1), je && je.apply(ge, ze || []) }) } if (_e.previous = function () { return _triggers[_triggers.indexOf(_e) - 1] }, _e.next = function () { return _triggers[_triggers.indexOf(_e) + 1] }, _e.revert = function (Le, He) { if (!He) return _e.kill(!0); var Ne = Le !== !1 || !_e.enabled, qe = _refreshing; Ne !== _e.isReverted && (Ne && (Pt = Math.max(Ve(), _e.scroll.rec || 0), Be = _e.progress, Ot = X && X.progress()), it && [it, nt, we, Ge].forEach(function (yt) { return yt.style.display = Ne ? "none" : "block" }), Ne && (_refreshing = _e, _e.update(Ne)), se && (!ue || !_e.isActive) && (Ne ? _swapPinOut(se, rt, ot) : _swapPinIn(se, rt, _getComputedStyle(se), pt)), Ne || _e.update(Ne), _refreshing = qe, _e.isReverted = Ne) }, _e.refresh = function (Le, He, Ne, qe) { if (!((_refreshing || !_e.enabled) && !He)) { if (se && Le && _lastScrollTime) { _addListener(z, "scrollEnd", _softRefresh); return } !_refreshingAll && be && be(_e), _refreshing = _e, Ze.tween && !Ne && (Ze.tween.kill(), Ze.tween = 0), Ke && Ke.pause(), re && X && X.revert({ kill: !1 }).invalidate(), _e.isReverted || _e.revert(!0, !0), _e._subPinOffset = !1; var yt = Ae(), Je = $e(), ft = ge ? ge.duration() : _maxScroll(Ee, ke), bt = We <= .01, ct = 0, lt = qe || 0, st = _isObject(Ne) ? Ne.end : Y.end, At = Y.endTrigger || ie, ht = _isObject(Ne) ? Ne.start : Y.start || (Y.start === 0 || !ie ? 0 : se ? "0 0" : "0 100%"), Ct = _e.pinnedContainer = Y.pinnedContainer && _getTarget(Y.pinnedContainer, _e), Ft = ie && Math.max(0, _triggers.indexOf(_e)) || 0, vt = Ft, xt, kt, Nt, Kt, Et, gt, Mt, Zt, Qt, jt, $t, Ut, Jt; for (pe && _isObject(Ne) && (Ut = gsap$5.getProperty(we, ke.p), Jt = gsap$5.getProperty(Ge, ke.p)); vt-- > 0;)gt = _triggers[vt], gt.end || gt.refresh(0, 1) || (_refreshing = _e), Mt = gt.pin, Mt && (Mt === ie || Mt === se || Mt === Ct) && !gt.isReverted && (jt || (jt = []), jt.unshift(gt), gt.revert(!0, !0)), gt !== _triggers[vt] && (Ft--, vt--); for (_isFunction$1(ht) && (ht = ht(_e)), ht = _parseClamp(ht, "start", _e), Re = _parsePosition(ht, ie, yt, ke, Ve(), it, we, _e, Je, de, Te, ft, ge, _e._startClamp && "_startClamp") || (se ? -.001 : 0), _isFunction$1(st) && (st = st(_e)), _isString$1(st) && !st.indexOf("+=") && (~st.indexOf(" ") ? st = (_isString$1(ht) ? ht.split(" ")[0] : "") + st : (ct = _offsetToPx(st.substr(2), yt), st = _isString$1(ht) ? ht : (ge ? gsap$5.utils.mapRange(0, ge.duration(), ge.scrollTrigger.start, ge.scrollTrigger.end, Re) : Re) + ct, At = ie)), st = _parseClamp(st, "end", _e), Me = Math.max(Re, _parsePosition(st || (At ? "100% 0" : ft), At, yt, ke, Ve() + ct, nt, Ge, _e, Je, de, Te, ft, ge, _e._endClamp && "_endClamp")) || -.001, ct = 0, vt = Ft; vt--;)gt = _triggers[vt], Mt = gt.pin, Mt && gt.start - gt._pinPush <= Re && !ge && gt.end > 0 && (xt = gt.end - (_e._startClamp ? Math.max(0, gt.start) : gt.start), (Mt === ie && gt.start - gt._pinPush < Re || Mt === Ct) && isNaN(ht) && (ct += xt * (1 - gt.progress)), Mt === se && (lt += xt)); if (Re += ct, Me += ct, _e._startClamp && (_e._startClamp += ct), _e._endClamp && !_refreshingAll && (_e._endClamp = Me || -.001, Me = Math.min(Me, _maxScroll(Ee, ke))), We = Me - Re || (Re -= .01) && .001, bt && (Be = gsap$5.utils.clamp(0, 1, gsap$5.utils.normalize(Re, Me, Pt))), _e._pinPush = lt, it && ct && (xt = {}, xt[ke.a] = "+=" + ct, Ct && (xt[ke.p] = "-=" + Ve()), gsap$5.set([it, nt], xt)), se && !(_clampingMax && _e.end >= _maxScroll(Ee, ke))) xt = _getComputedStyle(se), Kt = ke === _vertical, Nt = Ve(), _t = parseFloat(tt(ke.a)) + lt, !ft && Me > 1 && ($t = (Pe ? _doc.scrollingElement || _docEl$1 : Ee).style, $t = { style: $t, value: $t["overflow" + ke.a.toUpperCase()] }, Pe && _getComputedStyle(_body$1)["overflow" + ke.a.toUpperCase()] !== "scroll" && ($t.style["overflow" + ke.a.toUpperCase()] = "scroll")), _swapPinIn(se, rt, xt), mt = _getState(se), kt = _getBounds(se, !0), Zt = Te && _getScrollFunc(Ee, Kt ? _horizontal : _vertical)(), ne ? (pt = [ne + ke.os2, We + lt + _px], pt.t = rt, vt = ne === _padding ? _getSize(se, ke) + We + lt : 0, vt && (pt.push(ke.d, vt + _px), rt.style.flexBasis !== "auto" && (rt.style.flexBasis = vt + _px)), _setState(pt), Ct && _triggers.forEach(function (Yt) { Yt.pin === Ct && Yt.vars.pinSpacing !== !1 && (Yt._subPinOffset = !0) }), Te && Ve(Pt)) : (vt = _getSize(se, ke), vt && rt.style.flexBasis !== "auto" && (rt.style.flexBasis = vt + _px)), Te && (Et = { top: kt.top + (Kt ? Nt - Re : Zt) + _px, left: kt.left + (Kt ? Zt : Nt - Re) + _px, boxSizing: "border-box", position: "fixed" }, Et[_width] = Et["max" + _Width] = Math.ceil(kt.width) + _px, Et[_height] = Et["max" + _Height] = Math.ceil(kt.height) + _px, Et[_margin] = Et[_margin + _Top] = Et[_margin + _Right] = Et[_margin + _Bottom] = Et[_margin + _Left] = "0", Et[_padding] = xt[_padding], Et[_padding + _Top] = xt[_padding + _Top], Et[_padding + _Right] = xt[_padding + _Right], Et[_padding + _Bottom] = xt[_padding + _Bottom], Et[_padding + _Left] = xt[_padding + _Left], dt = _copyState(ot, Et, ue), _refreshingAll && Ve(0)), X ? (Qt = X._initted, _suppressOverwrites(1), X.render(X.duration(), !0, !0), Tt = tt(ke.a) - _t + We + lt, It = Math.abs(We - Tt) > 1, Te && It && dt.splice(dt.length - 2, 2), X.render(0, !0, !0), Qt || X.invalidate(!0), X.parent || X.totalTime(X.totalTime()), _suppressOverwrites(0)) : Tt = We, $t && ($t.value ? $t.style["overflow" + ke.a.toUpperCase()] = $t.value : $t.style.removeProperty("overflow-" + ke.a)); else if (ie && Ve() && !ge) for (kt = ie.parentNode; kt && kt !== _body$1;)kt._pinOffset && (Re -= kt._pinOffset, Me -= kt._pinOffset), kt = kt.parentNode; jt && jt.forEach(function (Yt) { return Yt.revert(!1, !0) }), _e.start = Re, _e.end = Me, Ye = Xe = _refreshingAll ? Pt : Ve(), !ge && !_refreshingAll && (Ye < Pt && Ve(Pt), _e.scroll.rec = 0), _e.revert(!1, !0), Ie = _getTime(), Dt && (Fe = -1, Dt.restart(!0)), _refreshing = 0, X && Ce && (X._initted || Ot) && X.progress() !== Ot && X.progress(Ot || 0, !0).render(X.time(), !0, !0), (bt || Be !== _e.progress || ge || re || X && !X._initted) && (X && !Ce && X.totalProgress(ge && Re < -.001 && !Be ? gsap$5.utils.normalize(Re, Me, 0) : Be, !0), _e.progress = bt || (Ye - Re) / We === Be ? 0 : Be), se && ne && (rt._pinOffset = Math.round(_e.progress * Tt)), Ke && Ke.invalidate(), isNaN(Ut) || (Ut -= gsap$5.getProperty(we, ke.p), Jt -= gsap$5.getProperty(Ge, ke.p), _shiftMarker(we, ke, Ut), _shiftMarker(it, ke, Ut - (qe || 0)), _shiftMarker(Ge, ke, Jt), _shiftMarker(nt, ke, Jt - (qe || 0))), bt && !_refreshingAll && _e.update(), te && !_refreshingAll && !at && (at = !0, te(_e), at = !1) } }, _e.getVelocity = function () { return (Ve() - Xe) / (_getTime() - _time2) * 1e3 || 0 }, _e.endAnimation = function () { _endAnimation(_e.callbackAnimation), X && (Ke ? Ke.progress(1) : X.paused() ? Ce || _endAnimation(X, _e.direction < 0, 1) : _endAnimation(X, X.reversed())) }, _e.labelToScroll = function (Le) { return X && X.labels && (Re || _e.refresh() || Re) + X.labels[Le] / X.duration() * We || 0 }, _e.getTrailing = function (Le) { var He = _triggers.indexOf(_e), Ne = _e.direction > 0 ? _triggers.slice(0, He).reverse() : _triggers.slice(He + 1); return (_isString$1(Le) ? Ne.filter(function (qe) { return qe.vars.preventOverlaps === Le }) : Ne).filter(function (qe) { return _e.direction > 0 ? qe.end <= Re : qe.start >= Me }) }, _e.update = function (Le, He, Ne) { if (!(ge && !Ne && !Le)) { var qe = _refreshingAll === !0 ? Pt : _e.scroll(), yt = Le ? 0 : (qe - Re) / We, Je = yt < 0 ? 0 : yt > 1 ? 1 : yt || 0, ft = _e.progress, bt, ct, lt, st, At, ht, Ct, Ft; if (He && (Xe = Ye, Ye = ge ? Ve() : qe, ce && (Bt = Rt, Rt = X && !Ce ? X.totalProgress() : Je)), fe && se && !_refreshing && !_startup && _lastScrollTime && (!Je && Re < qe + (qe - Xe) / (_getTime() - _time2) * fe ? Je = 1e-4 : Je === 1 && Me > qe + (qe - Xe) / (_getTime() - _time2) * fe && (Je = .9999)), Je !== ft && _e.enabled) { if (bt = _e.isActive = !!Je && Je < 1, ct = !!ft && ft < 1, ht = bt !== ct, At = ht || !!Je != !!ft, _e.direction = Je > ft ? 1 : -1, _e.progress = Je, At && !_refreshing && (lt = Je && !ft ? 0 : Je === 1 ? 1 : ft === 1 ? 2 : 3, Ce && (st = !ht && xe[lt + 1] !== "none" && xe[lt + 1] || xe[lt], Ft = X && (st === "complete" || st === "reset" || st in X))), Se && (ht || Ft) && (Ft || oe || !X) && (_isFunction$1(Se) ? Se(_e) : _e.getTrailing(Se).forEach(function (Nt) { return Nt.endAnimation() })), Ce || (Ke && !_refreshing && !_startup ? (Ke._dp._time - Ke._start !== Ke._time && Ke.render(Ke._dp._time - Ke._start), Ke.resetTo ? Ke.resetTo("totalProgress", Je, X._tTime / X._tDur) : (Ke.vars.totalProgress = Je, Ke.invalidate().restart())) : X && X.totalProgress(Je, !!(_refreshing && (Ie || Le)))), se) { if (Le && ne && (rt.style[ne + ke.os2] = Ht), !Te) St(_round$3(_t + Tt * Je)); else if (At) { if (Ct = !Le && Je > ft && Me + 1 > qe && qe + 1 >= _maxScroll(Ee, ke), ue) if (!Le && (bt || Ct)) { var vt = _getBounds(se, !0), xt = qe - Re; _reparent(se, _body$1, vt.top + (ke === _vertical ? xt : 0) + _px, vt.left + (ke === _vertical ? 0 : xt) + _px) } else _reparent(se, rt); _setState(bt || Ct ? dt : mt), It && Je < 1 && bt || St(_t + (Je === 1 && !Ct ? Tt : 0)) } } ce && !Ze.tween && !_refreshing && !_startup && Dt.restart(!0), Z && (ht || le && Je && (Je < 1 || !_limitCallbacks)) && _toArray$2(Z.targets).forEach(function (Nt) { return Nt.classList[bt || le ? "add" : "remove"](Z.className) }), J && !Ce && !Le && J(_e), At && !_refreshing ? (Ce && (Ft && (st === "complete" ? X.pause().totalProgress(1) : st === "reset" ? X.restart(!0).pause() : st === "restart" ? X.restart(!0) : X[st]()), J && J(_e)), (ht || !_limitCallbacks) && (ee && ht && _callback(_e, ee), ye[lt] && _callback(_e, ye[lt]), le && (Je === 1 ? _e.kill(!1, 1) : ye[lt] = 0), ht || (lt = Je === 1 ? 1 : 3, ye[lt] && _callback(_e, ye[lt]))), ve && !bt && Math.abs(_e.getVelocity()) > (_isNumber$1(ve) ? ve : 2500) && (_endAnimation(_e.callbackAnimation), Ke ? Ke.progress(1) : _endAnimation(X, st === "reverse" ? 1 : !Je, 1))) : Ce && J && !_refreshing && J(_e) } if (zt) { var kt = ge ? qe / ge.duration() * (ge._caScrollDist || 0) : qe; Xt(kt + (we._isFlipped ? 1 : 0)), zt(kt) } Wt && Wt(-qe / ge.duration() * (ge._caScrollDist || 0)) } }, _e.enable = function (Le, He) { _e.enabled || (_e.enabled = !0, _addListener(Ee, "resize", _onResize), Pe || _addListener(Ee, "scroll", _onScroll), be && _addListener(z, "refreshInit", be), Le !== !1 && (_e.progress = Be = 0, Ye = Xe = Fe = Ve()), He !== !1 && _e.refresh()) }, _e.getTween = function (Le) { return Le && Ze ? Ze.tween : Ke }, _e.setPositions = function (Le, He, Ne, qe) { if (ge) { var yt = ge.scrollTrigger, Je = ge.duration(), ft = yt.end - yt.start; Le = yt.start + ft * Le / Je, He = yt.start + ft * He / Je } _e.refresh(!1, !1, { start: _keepClamp(Le, Ne && !!_e._startClamp), end: _keepClamp(He, Ne && !!_e._endClamp) }, qe), _e.update() }, _e.adjustPinSpacing = function (Le) { if (pt && Le) { var He = pt.indexOf(ke.d) + 1; pt[He] = parseFloat(pt[He]) + Le + _px, pt[1] = parseFloat(pt[1]) + Le + _px, _setState(pt) } }, _e.disable = function (Le, He) { if (_e.enabled && (Le !== !1 && _e.revert(!0, !0), _e.enabled = _e.isActive = !1, He || Ke && Ke.pause(), Pt = 0, Qe && (Qe.uncache = 1), be && _removeListener(z, "refreshInit", be), Dt && (Dt.pause(), Ze.tween && Ze.tween.kill() && (Ze.tween = 0)), !Pe)) { for (var Ne = _triggers.length; Ne--;)if (_triggers[Ne].scroller === Ee && _triggers[Ne] !== _e) return; _removeListener(Ee, "resize", _onResize), Pe || _removeListener(Ee, "scroll", _onScroll) } }, _e.kill = function (Le, He) { _e.disable(Le, He), Ke && !He && Ke.kill(), Q && delete _ids[Q]; var Ne = _triggers.indexOf(_e); Ne >= 0 && _triggers.splice(Ne, 1), Ne === _i && _direction > 0 && _i--, Ne = 0, _triggers.forEach(function (qe) { return qe.scroller === _e.scroller && (Ne = 1) }), Ne || _refreshingAll || (_e.scroll.rec = 0), X && (X.scrollTrigger = null, Le && X.revert({ kill: !1 }), He || X.kill()), it && [it, nt, we, Ge].forEach(function (qe) { return qe.parentNode && qe.parentNode.removeChild(qe) }), _primary === _e && (_primary = 0), se && (Qe && (Qe.uncache = 1), Ne = 0, _triggers.forEach(function (qe) { return qe.pin === se && Ne++ }), Ne || (Qe.spacer = 0)), Y.onKill && Y.onKill(_e) }, _triggers.push(_e), _e.enable(!1, !1), Lt && Lt(_e), X && X.add && !We) { var et = _e.update; _e.update = function () { _e.update = et, _scrollers.cache++, Re || Me || _e.refresh() }, gsap$5.delayedCall(.01, _e.update), We = .01, Re = Me = 0 } else _e.refresh(); se && _queueRefreshAll() }, z.register = function (Y) { return _coreInitted$4 || (gsap$5 = Y || _getGSAP$5(), _windowExists$2() && window.document && z.enable(), _coreInitted$4 = _enabled), _coreInitted$4 }, z.defaults = function (Y) { if (Y) for (var X in Y) _defaults[X] = Y[X]; return _defaults }, z.disable = function (Y, X) { _enabled = 0, _triggers.forEach(function (J) { return J[X ? "kill" : "disable"](Y) }), _removeListener(_win$1, "wheel", _onScroll), _removeListener(_doc, "scroll", _onScroll), clearInterval(_syncInterval), _removeListener(_doc, "touchcancel", _passThrough), _removeListener(_body$1, "touchstart", _passThrough), _multiListener(_removeListener, _doc, "pointerdown,touchstart,mousedown", _pointerDownHandler), _multiListener(_removeListener, _doc, "pointerup,touchend,mouseup", _pointerUpHandler), _resizeDelay.kill(), _iterateAutoRefresh(_removeListener); for (var K = 0; K < _scrollers.length; K += 3)_wheelListener(_removeListener, _scrollers[K], _scrollers[K + 1]), _wheelListener(_removeListener, _scrollers[K], _scrollers[K + 2]) }, z.enable = function () { if (_win$1 = window, _doc = document, _docEl$1 = _doc.documentElement, _body$1 = _doc.body, gsap$5 && (_toArray$2 = gsap$5.utils.toArray, _clamp = gsap$5.utils.clamp, _context = gsap$5.core.context || _passThrough, _suppressOverwrites = gsap$5.core.suppressOverwrites || _passThrough, _scrollRestoration = _win$1.history.scrollRestoration || "auto", _lastScroll = _win$1.pageYOffset || 0, gsap$5.core.globals("ScrollTrigger", z), _body$1)) { _enabled = 1, _div100vh = document.createElement("div"), _div100vh.style.height = "100vh", _div100vh.style.position = "absolute", _refresh100vh(), _rafBugFix(), Observer.register(gsap$5), z.isTouch = Observer.isTouch, _fixIOSBug = Observer.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent), _ignoreMobileResize = Observer.isTouch === 1, _addListener(_win$1, "wheel", _onScroll), _root = [_win$1, _doc, _docEl$1, _body$1], gsap$5.matchMedia ? (z.matchMedia = function (ee) { var te = gsap$5.matchMedia(), oe; for (oe in ee) te.add(oe, ee[oe]); return te }, gsap$5.addEventListener("matchMediaInit", function () { return _revertAll() }), gsap$5.addEventListener("matchMediaRevert", function () { return _revertRecorded() }), gsap$5.addEventListener("matchMedia", function () { _refreshAll(0, 1), _dispatch("matchMedia") }), gsap$5.matchMedia().add("(orientation: portrait)", function () { return _setBaseDimensions(), _setBaseDimensions })) : console.warn("Requires GSAP 3.11.0 or later"), _setBaseDimensions(), _addListener(_doc, "scroll", _onScroll); var Y = _body$1.hasAttribute("style"), X = _body$1.style, K = X.borderTopStyle, J = gsap$5.core.Animation.prototype, Z, Q; for (J.revert || Object.defineProperty(J, "revert", { value: function () { return this.time(-.01, !0) } }), X.borderTopStyle = "solid", Z = _getBounds(_body$1), _vertical.m = Math.round(Z.top + _vertical.sc()) || 0, _horizontal.m = Math.round(Z.left + _horizontal.sc()) || 0, K ? X.borderTopStyle = K : X.removeProperty("border-top-style"), Y || (_body$1.setAttribute("style", ""), _body$1.removeAttribute("style")), _syncInterval = setInterval(_sync, 250), gsap$5.delayedCall(.5, function () { return _startup = 0 }), _addListener(_doc, "touchcancel", _passThrough), _addListener(_body$1, "touchstart", _passThrough), _multiListener(_addListener, _doc, "pointerdown,touchstart,mousedown", _pointerDownHandler), _multiListener(_addListener, _doc, "pointerup,touchend,mouseup", _pointerUpHandler), _transformProp = gsap$5.utils.checkPrefix("transform"), _stateProps.push(_transformProp), _coreInitted$4 = _getTime(), _resizeDelay = gsap$5.delayedCall(.2, _refreshAll).pause(), _autoRefresh = [_doc, "visibilitychange", function () { var ee = _win$1.innerWidth, te = _win$1.innerHeight; _doc.hidden ? (_prevWidth = ee, _prevHeight = te) : (_prevWidth !== ee || _prevHeight !== te) && _onResize() }, _doc, "DOMContentLoaded", _refreshAll, _win$1, "load", _refreshAll, _win$1, "resize", _onResize], _iterateAutoRefresh(_addListener), _triggers.forEach(function (ee) { return ee.enable(0, 1) }), Q = 0; Q < _scrollers.length; Q += 3)_wheelListener(_removeListener, _scrollers[Q], _scrollers[Q + 1]), _wheelListener(_removeListener, _scrollers[Q], _scrollers[Q + 2]) } }, z.config = function (Y) { "limitCallbacks" in Y && (_limitCallbacks = !!Y.limitCallbacks); var X = Y.syncInterval; X && clearInterval(_syncInterval) || (_syncInterval = X) && setInterval(_sync, X), "ignoreMobileResize" in Y && (_ignoreMobileResize = z.isTouch === 1 && Y.ignoreMobileResize), "autoRefreshEvents" in Y && (_iterateAutoRefresh(_removeListener) || _iterateAutoRefresh(_addListener, Y.autoRefreshEvents || "none"), _ignoreResize = (Y.autoRefreshEvents + "").indexOf("resize") === -1) }, z.scrollerProxy = function (Y, X) { var K = _getTarget(Y), J = _scrollers.indexOf(K), Z = _isViewport(K); ~J && _scrollers.splice(J, Z ? 6 : 2), X && (Z ? _proxies.unshift(_win$1, X, _body$1, X, _docEl$1, X) : _proxies.unshift(K, X)) }, z.clearMatchMedia = function (Y) { _triggers.forEach(function (X) { return X._ctx && X._ctx.query === Y && X._ctx.kill(!0, !0) }) }, z.isInViewport = function (Y, X, K) { var J = (_isString$1(Y) ? _getTarget(Y) : Y).getBoundingClientRect(), Z = J[K ? _width : _height] * X || 0; return K ? J.right - Z > 0 && J.left + Z < _win$1.innerWidth : J.bottom - Z > 0 && J.top + Z < _win$1.innerHeight }, z.positionInViewport = function (Y, X, K) { _isString$1(Y) && (Y = _getTarget(Y)); var J = Y.getBoundingClientRect(), Z = J[K ? _width : _height], Q = X == null ? Z / 2 : X in _keywords ? _keywords[X] * Z : ~X.indexOf("%") ? parseFloat(X) * Z / 100 : parseFloat(X) || 0; return K ? (J.left + Q) / _win$1.innerWidth : (J.top + Q) / _win$1.innerHeight }, z.killAll = function (Y) { if (_triggers.slice(0).forEach(function (K) { return K.vars.id !== "ScrollSmoother" && K.kill() }), Y !== !0) { var X = _listeners.killAll || []; _listeners = {}, X.forEach(function (K) { return K() }) } }, z }(); ScrollTrigger$1.version = "3.12.7"; ScrollTrigger$1.saveStyles = function (z) { return z ? _toArray$2(z).forEach(function (F) { if (F && F.style) { var G = _savedStyles.indexOf(F); G >= 0 && _savedStyles.splice(G, 5), _savedStyles.push(F, F.style.cssText, F.getBBox && F.getAttribute("transform"), gsap$5.core.getCache(F), _context()) } }) : _savedStyles }; ScrollTrigger$1.revert = function (z, F) { return _revertAll(!z, F) }; ScrollTrigger$1.create = function (z, F) { return new ScrollTrigger$1(z, F) }; ScrollTrigger$1.refresh = function (z) { return z ? _onResize(!0) : (_coreInitted$4 || ScrollTrigger$1.register()) && _refreshAll(!0) }; ScrollTrigger$1.update = function (z) { return ++_scrollers.cache && _updateAll(z === !0 ? 2 : 0) }; ScrollTrigger$1.clearScrollMemory = _clearScrollMemory; ScrollTrigger$1.maxScroll = function (z, F) { return _maxScroll(z, F ? _horizontal : _vertical) }; ScrollTrigger$1.getScrollFunc = function (z, F) { return _getScrollFunc(_getTarget(z), F ? _horizontal : _vertical) }; ScrollTrigger$1.getById = function (z) { return _ids[z] }; ScrollTrigger$1.getAll = function () { return _triggers.filter(function (z) { return z.vars.id !== "ScrollSmoother" }) }; ScrollTrigger$1.isScrolling = function () { return !!_lastScrollTime }; ScrollTrigger$1.snapDirectional = _snapDirectional; ScrollTrigger$1.addEventListener = function (z, F) { var G = _listeners[z] || (_listeners[z] = []); ~G.indexOf(F) || G.push(F) }; ScrollTrigger$1.removeEventListener = function (z, F) { var G = _listeners[z], Y = G && G.indexOf(F); Y >= 0 && G.splice(Y, 1) }; ScrollTrigger$1.batch = function (z, F) { var G = [], Y = {}, X = F.interval || .016, K = F.batchMax || 1e9, J = function (ee, te) { var oe = [], ie = [], se = gsap$5.delayedCall(X, function () { te(oe, ie), oe = [], ie = [] }).pause(); return function (ne) { oe.length || se.restart(!0), oe.push(ne.trigger), ie.push(ne), K <= oe.length && se.progress(1) } }, Z; for (Z in F) Y[Z] = Z.substr(0, 2) === "on" && _isFunction$1(F[Z]) && Z !== "onRefreshInit" ? J(Z, F[Z]) : F[Z]; return _isFunction$1(K) && (K = K(), _addListener(ScrollTrigger$1, "refresh", function () { return K = F.batchMax() })), _toArray$2(z).forEach(function (Q) { var ee = {}; for (Z in Y) ee[Z] = Y[Z]; ee.trigger = Q, G.push(ScrollTrigger$1.create(ee)) }), G }; var _clampScrollAndGetDurationMultiplier = function (F, G, Y, X) { return G > X ? F(X) : G < 0 && F(0), Y > X ? (X - G) / (Y - G) : Y < 0 ? G / (G - Y) : 1 }, _allowNativePanning = function z(F, G) { G === !0 ? F.style.removeProperty("touch-action") : F.style.touchAction = G === !0 ? "auto" : G ? "pan-" + G + (Observer.isTouch ? " pinch-zoom" : "") : "none", F === _docEl$1 && z(_body$1, G) }, _overflow = { auto: 1, scroll: 1 }, _nestedScroll = function (F) { var G = F.event, Y = F.target, X = F.axis, K = (G.changedTouches ? G.changedTouches[0] : G).target, J = K._gsap || gsap$5.core.getCache(K), Z = _getTime(), Q; if (!J._isScrollT || Z - J._isScrollT > 2e3) { for (; K && K !== _body$1 && (K.scrollHeight <= K.clientHeight && K.scrollWidth <= K.clientWidth || !(_overflow[(Q = _getComputedStyle(K)).overflowY] || _overflow[Q.overflowX]));)K = K.parentNode; J._isScroll = K && K !== Y && !_isViewport(K) && (_overflow[(Q = _getComputedStyle(K)).overflowY] || _overflow[Q.overflowX]), J._isScrollT = Z } (J._isScroll || X === "x") && (G.stopPropagation(), G._gsapAllow = !0) }, _inputObserver = function (F, G, Y, X) { return Observer.create({ target: F, capture: !0, debounce: !1, lockAxis: !0, type: G, onWheel: X = X && _nestedScroll, onPress: X, onDrag: X, onScroll: X, onEnable: function () { return Y && _addListener(_doc, Observer.eventTypes[0], _captureInputs, !1, !0) }, onDisable: function () { return _removeListener(_doc, Observer.eventTypes[0], _captureInputs, !0) } }) }, _inputExp = /(input|label|select|textarea)/i, _inputIsFocused, _captureInputs = function (F) { var G = _inputExp.test(F.target.tagName); (G || _inputIsFocused) && (F._gsapAllow = !0, _inputIsFocused = G) }, _getScrollNormalizer = function (F) { _isObject(F) || (F = {}), F.preventDefault = F.isNormalizer = F.allowClicks = !0, F.type || (F.type = "wheel,touch"), F.debounce = !!F.debounce, F.id = F.id || "normalizer"; var G = F, Y = G.normalizeScrollX, X = G.momentum, K = G.allowNestedScroll, J = G.onRelease, Z, Q, ee = _getTarget(F.target) || _docEl$1, te = gsap$5.core.globals().ScrollSmoother, oe = te && te.get(), ie = _fixIOSBug && (F.content && _getTarget(F.content) || oe && F.content !== !1 && !oe.smooth() && oe.content()), se = _getScrollFunc(ee, _vertical), ne = _getScrollFunc(ee, _horizontal), re = 1, fe = (Observer.isTouch && _win$1.visualViewport ? _win$1.visualViewport.scale * _win$1.visualViewport.width : _win$1.outerWidth) / _win$1.innerWidth, ae = 0, he = _isFunction$1(X) ? function () { return X(Z) } : function () { return X || 2.8 }, le, ce, ue = _inputObserver(ee, F.type, !0, K), me = function () { return ce = !1 }, ge = _passThrough, ve = _passThrough, Se = function () { Q = _maxScroll(ee, _vertical), ve = _clamp(_fixIOSBug ? 1 : 0, Q), Y && (ge = _clamp(0, _maxScroll(ee, _horizontal))), le = _refreshID }, ke = function () { ie._gsap.y = _round$3(parseFloat(ie._gsap.y) + se.offset) + "px", ie.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(ie._gsap.y) + ", 0, 1)", se.offset = se.cacheID = 0 }, Ce = function () { if (ce) { requestAnimationFrame(me); var pe = _round$3(Z.deltaY / 2), de = ve(se.v - pe); if (ie && de !== se.v + se.offset) { se.offset = de - se.v; var _e = _round$3((parseFloat(ie && ie._gsap.y) || 0) - se.offset); ie.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + _e + ", 0, 1)", ie._gsap.y = _e + "px", se.cacheID = _scrollers.cache, _updateAll() } return !0 } se.offset && ke(), ce = !0 }, Ee, De, Pe, Te, ye = function () { Se(), Ee.isActive() && Ee.vars.scrollY > Q && (se() > Q ? Ee.progress(1) && se(Q) : Ee.resetTo("scrollY", Q)) }; return ie && gsap$5.set(ie, { y: "+=0" }), F.ignoreCheck = function (xe) { return _fixIOSBug && xe.type === "touchmove" && Ce() || re > 1.05 && xe.type !== "touchstart" || Z.isGesturing || xe.touches && xe.touches.length > 1 }, F.onPress = function () { ce = !1; var xe = re; re = _round$3((_win$1.visualViewport && _win$1.visualViewport.scale || 1) / fe), Ee.pause(), xe !== re && _allowNativePanning(ee, re > 1.01 ? !0 : Y ? !1 : "x"), De = ne(), Pe = se(), Se(), le = _refreshID }, F.onRelease = F.onGestureStart = function (xe, pe) { if (se.offset && ke(), !pe) Te.restart(!0); else { _scrollers.cache++; var de = he(), _e, be; Y && (_e = ne(), be = _e + de * .05 * -xe.velocityX / .227, de *= _clampScrollAndGetDurationMultiplier(ne, _e, be, _maxScroll(ee, _horizontal)), Ee.vars.scrollX = ge(be)), _e = se(), be = _e + de * .05 * -xe.velocityY / .227, de *= _clampScrollAndGetDurationMultiplier(se, _e, be, _maxScroll(ee, _vertical)), Ee.vars.scrollY = ve(be), Ee.invalidate().duration(de).play(.01), (_fixIOSBug && Ee.vars.scrollY >= Q || _e >= Q - 1) && gsap$5.to({}, { onUpdate: ye, duration: de }) } J && J(xe) }, F.onWheel = function () { Ee._ts && Ee.pause(), _getTime() - ae > 1e3 && (le = 0, ae = _getTime()) }, F.onChange = function (xe, pe, de, _e, be) { if (_refreshID !== le && Se(), pe && Y && ne(ge(_e[2] === pe ? De + (xe.startX - xe.x) : ne() + pe - _e[1])), de) { se.offset && ke(); var Ae = be[2] === de, $e = Ae ? Pe + xe.startY - xe.y : se() + de - be[1], Fe = ve($e); Ae && $e !== Fe && (Pe += Fe - $e), se(Fe) } (de || pe) && _updateAll() }, F.onEnable = function () { _allowNativePanning(ee, Y ? !1 : "x"), ScrollTrigger$1.addEventListener("refresh", ye), _addListener(_win$1, "resize", ye), se.smooth && (se.target.style.scrollBehavior = "auto", se.smooth = ne.smooth = !1), ue.enable() }, F.onDisable = function () { _allowNativePanning(ee, !0), _removeListener(_win$1, "resize", ye), ScrollTrigger$1.removeEventListener("refresh", ye), ue.kill() }, F.lockAxis = F.lockAxis !== !1, Z = new Observer(F), Z.iOS = _fixIOSBug, _fixIOSBug && !se() && se(1), _fixIOSBug && gsap$5.ticker.add(_passThrough), Te = Z._dc, Ee = gsap$5.to(Z, { ease: "power4", paused: !0, inherit: !1, scrollX: Y ? "+=0.1" : "+=0", scrollY: "+=0.1", modifiers: { scrollY: _interruptionTracker(se, se(), function () { return Ee.pause() }) }, onUpdate: _updateAll, onComplete: Te.vars.onComplete }), Z }; ScrollTrigger$1.sort = function (z) { if (_isFunction$1(z)) return _triggers.sort(z); var F = _win$1.pageYOffset || 0; return ScrollTrigger$1.getAll().forEach(function (G) { return G._sortY = G.trigger ? F + G.trigger.getBoundingClientRect().top : G.start + _win$1.innerHeight }), _triggers.sort(z || function (G, Y) { return (G.vars.refreshPriority || 0) * -1e6 + (G.vars.containerAnimation ? 1e6 : G._sortY) - ((Y.vars.containerAnimation ? 1e6 : Y._sortY) + (Y.vars.refreshPriority || 0) * -1e6) }) }; ScrollTrigger$1.observe = function (z) { return new Observer(z) }; ScrollTrigger$1.normalizeScroll = function (z) { if (typeof z > "u") return _normalizer; if (z === !0 && _normalizer) return _normalizer.enable(); if (z === !1) { _normalizer && _normalizer.kill(), _normalizer = z; return } var F = z instanceof Observer ? z : _getScrollNormalizer(z); return _normalizer && _normalizer.target === F.target && _normalizer.kill(), _isViewport(F.target) && (_normalizer = F), F }; ScrollTrigger$1.core = { _getVelocityProp, _inputObserver, _scrollers, _proxies, bridge: { ss: function () { _lastScrollTime || _dispatch("scrollStart"), _lastScrollTime = _getTime() }, ref: function () { return _refreshing } } }; _getGSAP$5() && gsap$5.registerPlugin(ScrollTrigger$1); gsapWithCSS.registerPlugin(ScrollTrigger$1); let App$a = class { constructor() { } init() { const F = document.querySelector("[data-parts-transition-cover]"), G = document.querySelector("[data-header-progress]"), Y = document.querySelectorAll("[data-line-vertical]"); ScrollTrigger$1.create({ trigger: "footer", start: () => getDeviceType() === "sp" ? "top top+=25%" : "top top+=15%", invalidateOnRefresh: !0, onEnter: () => { $$1("footer").setAttribute("data-footer-active", ""), F && (F.style.opacity = "1"), setColorVariables(getMode() === "dark" ? "#000000" : "#ffffff", getMode() === "dark" ? "#ffffff" : "#000000"), G && (G.style.color = "var(--color-sub)"), Y && gsapWithCSS.set(Y, { background: "var(--color-gray-dark)" }) }, onLeaveBack: () => { $$1("footer").removeAttribute("data-footer-active", "active"), F && (F.style.opacity = "0"), setColorVariables(getMode() === "dark" ? "#ffffff" : "#000000", getMode() === "dark" ? "#000000" : "#ffffff"), G && (G.style.color = "var(--color-main)"), Y && gsapWithCSS.set(Y, { background: "var(--color-sub)" }) } }); const X = () => { const K = new Date; K.setHours(K.getHours()); const J = te => String(te).padStart(2, "0"), Z = J(K.getHours()), Q = J(K.getMinutes()), ee = J(K.getSeconds()); $$1("[data-footer-timer]").textContent = `${Z}:${Q}:${ee}` }; X(), setInterval(X, 1e3) } };/*!
 * ScrollToPlugin 3.12.7
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/var gsap$4, _coreInitted$3, _window, _docEl, _body, _toArray$1, _config, ScrollTrigger, _windowExists$1 = function () { return typeof window < "u" }, _getGSAP$4 = function () { return gsap$4 || _windowExists$1() && (gsap$4 = window.gsap) && gsap$4.registerPlugin && gsap$4 }, _isString = function (F) { return typeof F == "string" }, _isFunction = function (F) { return typeof F == "function" }, _max = function (F, G) { var Y = G === "x" ? "Width" : "Height", X = "scroll" + Y, K = "client" + Y; return F === _window || F === _docEl || F === _body ? Math.max(_docEl[X], _body[X]) - (_window["inner" + Y] || _docEl[K] || _body[K]) : F[X] - F["offset" + Y] }, _buildGetter = function (F, G) { var Y = "scroll" + (G === "x" ? "Left" : "Top"); return F === _window && (F.pageXOffset != null ? Y = "page" + G.toUpperCase() + "Offset" : F = _docEl[Y] != null ? _docEl : _body), function () { return F[Y] } }, _clean = function (F, G, Y, X) { if (_isFunction(F) && (F = F(G, Y, X)), typeof F != "object") return _isString(F) && F !== "max" && F.charAt(1) !== "=" ? { x: F, y: F } : { y: F }; if (F.nodeType) return { y: F, x: F }; var K = {}, J; for (J in F) K[J] = J !== "onAutoKill" && _isFunction(F[J]) ? F[J](G, Y, X) : F[J]; return K }, _getOffset = function (F, G) { if (F = _toArray$1(F)[0], !F || !F.getBoundingClientRect) return console.warn("scrollTo target doesn't exist. Using 0") || { x: 0, y: 0 }; var Y = F.getBoundingClientRect(), X = !G || G === _window || G === _body, K = X ? { top: _docEl.clientTop - (_window.pageYOffset || _docEl.scrollTop || _body.scrollTop || 0), left: _docEl.clientLeft - (_window.pageXOffset || _docEl.scrollLeft || _body.scrollLeft || 0) } : G.getBoundingClientRect(), J = { x: Y.left - K.left, y: Y.top - K.top }; return !X && G && (J.x += _buildGetter(G, "x")(), J.y += _buildGetter(G, "y")()), J }, _parseVal = function (F, G, Y, X, K) { return !isNaN(F) && typeof F != "object" ? parseFloat(F) - K : _isString(F) && F.charAt(1) === "=" ? parseFloat(F.substr(2)) * (F.charAt(0) === "-" ? -1 : 1) + X - K : F === "max" ? _max(G, Y) - K : Math.min(_max(G, Y), _getOffset(F, G)[Y] - K) }, _initCore$3 = function () { gsap$4 = _getGSAP$4(), _windowExists$1() && gsap$4 && typeof document < "u" && document.body && (_window = window, _body = document.body, _docEl = document.documentElement, _toArray$1 = gsap$4.utils.toArray, gsap$4.config({ autoKillThreshold: 7 }), _config = gsap$4.config(), _coreInitted$3 = 1) }, ScrollToPlugin = { version: "3.12.7", name: "scrollTo", rawVars: 1, register: function (F) { gsap$4 = F, _initCore$3() }, init: function (F, G, Y, X, K) { _coreInitted$3 || _initCore$3(); var J = this, Z = gsap$4.getProperty(F, "scrollSnapType"); J.isWin = F === _window, J.target = F, J.tween = Y, G = _clean(G, X, F, K), J.vars = G, J.autoKill = !!("autoKill" in G ? G : _config).autoKill, J.getX = _buildGetter(F, "x"), J.getY = _buildGetter(F, "y"), J.x = J.xPrev = J.getX(), J.y = J.yPrev = J.getY(), ScrollTrigger || (ScrollTrigger = gsap$4.core.globals().ScrollTrigger), gsap$4.getProperty(F, "scrollBehavior") === "smooth" && gsap$4.set(F, { scrollBehavior: "auto" }), Z && Z !== "none" && (J.snap = 1, J.snapInline = F.style.scrollSnapType, F.style.scrollSnapType = "none"), G.x != null ? (J.add(J, "x", J.x, _parseVal(G.x, F, "x", J.x, G.offsetX || 0), X, K), J._props.push("scrollTo_x")) : J.skipX = 1, G.y != null ? (J.add(J, "y", J.y, _parseVal(G.y, F, "y", J.y, G.offsetY || 0), X, K), J._props.push("scrollTo_y")) : J.skipY = 1 }, render: function (F, G) { for (var Y = G._pt, X = G.target, K = G.tween, J = G.autoKill, Z = G.xPrev, Q = G.yPrev, ee = G.isWin, te = G.snap, oe = G.snapInline, ie, se, ne, re, fe; Y;)Y.r(F, Y.d), Y = Y._next; ie = ee || !G.skipX ? G.getX() : Z, se = ee || !G.skipY ? G.getY() : Q, ne = se - Q, re = ie - Z, fe = _config.autoKillThreshold, G.x < 0 && (G.x = 0), G.y < 0 && (G.y = 0), J && (!G.skipX && (re > fe || re < -fe) && ie < _max(X, "x") && (G.skipX = 1), !G.skipY && (ne > fe || ne < -fe) && se < _max(X, "y") && (G.skipY = 1), G.skipX && G.skipY && (K.kill(), G.vars.onAutoKill && G.vars.onAutoKill.apply(K, G.vars.onAutoKillParams || []))), ee ? _window.scrollTo(G.skipX ? ie : G.x, G.skipY ? se : G.y) : (G.skipY || (X.scrollTop = G.y), G.skipX || (X.scrollLeft = G.x)), te && (F === 1 || F === 0) && (se = X.scrollTop, ie = X.scrollLeft, oe ? X.style.scrollSnapType = oe : X.style.removeProperty("scroll-snap-type"), X.scrollTop = se + 1, X.scrollLeft = ie + 1, X.scrollTop = se, X.scrollLeft = ie), G.xPrev = G.x, G.yPrev = G.y, ScrollTrigger && ScrollTrigger.update() }, kill: function (F) { var G = F === "scrollTo", Y = this._props.indexOf(F); return (G || F === "scrollTo_x") && (this.skipX = 1), (G || F === "scrollTo_y") && (this.skipY = 1), Y > -1 && this._props.splice(Y, 1), !this._props.length } }; ScrollToPlugin.max = _max; ScrollToPlugin.getOffset = _getOffset; ScrollToPlugin.buildGetter = _buildGetter; ScrollToPlugin.config = function (z) { _config || _initCore$3() || (_config = gsap$4.config()); for (var F in z) _config[F] = z[F] }; _getGSAP$4() && gsap$4.registerPlugin(ScrollToPlugin);/*!
 * ScrambleTextPlugin 3.12.7
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/var CharSet = function () { function z(G) { this.chars = emojiSafeSplit(G), this.sets = [], this.length = 50; for (var Y = 0; Y < 20; Y++)this.sets[Y] = _scrambleText(80, this.chars) } var F = z.prototype; return F.grow = function (Y) { for (var X = 0; X < 20; X++)this.sets[X] += _scrambleText(Y - this.length, this.chars); this.length = Y }, z }(), gsap$3, _coreInitted$2, _getGSAP$3 = function () { return gsap$3 || typeof window < "u" && (gsap$3 = window.gsap) && gsap$3.registerPlugin && gsap$3 }, _bonusValidated$1 = 1, _spacesExp = /\s+/g, _scrambleText = function (F, G) { for (var Y = G.length, X = ""; --F > -1;)X += G[~~(Math.random() * Y)]; return X }, _upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ", _lower = _upper.toLowerCase(), _charsLookup = { upperCase: new CharSet(_upper), lowerCase: new CharSet(_lower), upperAndLowerCase: new CharSet(_upper + _lower) }, _initCore$2 = function () { _coreInitted$2 = gsap$3 = _getGSAP$3() }, ScrambleTextPlugin = { version: "3.12.7", name: "scrambleText", register: function (F, G, Y) { gsap$3 = F, _initCore$2() }, init: function (F, G, Y, X, K) { if (_coreInitted$2 || _initCore$2(), this.prop = "innerHTML" in F ? "innerHTML" : "textContent" in F ? "textContent" : 0, !!this.prop) { this.target = F, typeof G != "object" && (G = { text: G }); var J = G.text || G.value || "", Z = G.trim !== !1, Q = this, ee, te, oe, ie; return Q.delimiter = ee = G.delimiter || "", Q.original = emojiSafeSplit(getText(F).replace(_spacesExp, " ").split("&nbsp;").join(""), ee, Z), (J === "{original}" || J === !0 || J == null) && (J = Q.original.join(ee)), Q.text = emojiSafeSplit((J || "").replace(_spacesExp, " "), ee, Z), Q.hasClass = !!(G.newClass || G.oldClass), Q.newClass = G.newClass, Q.oldClass = G.oldClass, ie = ee === "", Q.textHasEmoji = ie && !!Q.text.emoji, Q.charsHaveEmoji = !!G.chars && !!emojiSafeSplit(G.chars).emoji, Q.length = ie ? Q.original.length : Q.original.join(ee).length, Q.lengthDif = (ie ? Q.text.length : Q.text.join(ee).length) - Q.length, Q.fillChar = G.fillChar || G.chars && ~G.chars.indexOf(" ") ? "&nbsp;" : "", Q.charSet = oe = _charsLookup[G.chars || "upperCase"] || new CharSet(G.chars), Q.speed = .05 / (G.speed || 1), Q.prevScrambleTime = 0, Q.setIndex = Math.random() * 20 | 0, te = Q.length + Math.max(Q.lengthDif, 0), te > oe.length && oe.grow(te), Q.chars = oe.sets[Q.setIndex], Q.revealDelay = G.revealDelay || 0, Q.tweenLength = G.tweenLength !== !1, Q.tween = Y, Q.rightToLeft = !!G.rightToLeft, Q._props.push("scrambleText", "text"), _bonusValidated$1 } }, render: function (F, G) { var Y = G.target, X = G.prop, K = G.text, J = G.delimiter, Z = G.tween, Q = G.prevScrambleTime, ee = G.revealDelay, te = G.setIndex, oe = G.chars, ie = G.charSet, se = G.length, ne = G.textHasEmoji, re = G.charsHaveEmoji, fe = G.lengthDif, ae = G.tweenLength, he = G.oldClass, le = G.newClass, ce = G.rightToLeft, ue = G.fillChar, me = G.speed, ge = G.original, ve = G.hasClass, Se = K.length, ke = Z._time, Ce = ke - Q, Ee, De, Pe, Te, ye, xe, pe, de, _e, be, Ae; ee && (Z._from && (ke = Z._dur - ke), F = ke === 0 ? 0 : ke < ee ? 1e-6 : ke === Z._dur ? 1 : Z._ease((ke - ee) / (Z._dur - ee))), F < 0 ? F = 0 : F > 1 && (F = 1), ce && (F = 1 - F), Ee = ~~(F * Se + .5), F ? ((Ce > me || Ce < -me) && (G.setIndex = te = (te + (Math.random() * 19 | 0)) % 20, G.chars = ie.sets[te], G.prevScrambleTime += Ce), Te = oe) : Te = ge.join(J), Ae = Z._from ? F : 1 - F, be = se + (ae ? Z._from ? Ae * Ae * Ae : 1 - Ae * Ae * Ae : 1) * fe, ce ? F === 1 && (Z._from || Z.data === "isFromStart") ? (Pe = "", Te = ge.join(J)) : (pe = K.slice(Ee).join(J), re ? Pe = emojiSafeSplit(Te).slice(0, be - (ne ? emojiSafeSplit(pe) : pe).length + .5 | 0).join("") : Pe = Te.substr(0, be - (ne ? emojiSafeSplit(pe) : pe).length + .5 | 0), Te = pe) : (Pe = K.slice(0, Ee).join(J), De = (ne ? emojiSafeSplit(Pe) : Pe).length, re ? Te = emojiSafeSplit(Te).slice(De, be + .5 | 0).join("") : Te = Te.substr(De, be - De + .5 | 0)), ve ? (de = ce ? he : le, _e = ce ? le : he, ye = de && Ee !== 0, xe = _e && Ee !== Se, pe = (ye ? "<span class='" + de + "'>" : "") + Pe + (ye ? "</span>" : "") + (xe ? "<span class='" + _e + "'>" : "") + J + Te + (xe ? "</span>" : "")) : pe = Pe + J + Te, Y[X] = ue === "&nbsp;" && ~pe.indexOf("  ") ? pe.split("  ").join("&nbsp;&nbsp;") : pe } }; ScrambleTextPlugin.emojiSafeSplit = emojiSafeSplit; ScrambleTextPlugin.getText = getText; _getGSAP$3() && gsap$3.registerPlugin(ScrambleTextPlugin); gsapWithCSS.registerPlugin(ScrollTrigger$1, ScrollToPlugin, ScrambleTextPlugin); let App$9 = class { appArray; constructor() { this.appArray = []; const F = new App$a; this.appArray.push(F) } init() { ScrollTrigger$1.config({ ignoreMobileResize: !0 }), this.anchorTo(), this.hoverDirection(), this.setOpacity(), this.appArray.forEach(F => { F.init() }) } hoverDirection() { const F = document.querySelector("[data-mouse]"), G = document.querySelector("[data-mouse-text]"), Y = document.querySelector("[data-mouse-bg]"); document.querySelectorAll("[data-mouse-target]").forEach(K => { if (getDeviceType() === "sp" || touchOnly()) return; const J = K.dataset.mouseTarget, Z = () => { getDeviceType() !== "sp" && (touchOnly() || (F?.setAttribute("data-mouse", "true"), gsapWithCSS.effects.inScrambleText(G, { text: J }), gsapWithCSS.to(Y, { scale: 1.4, duration: 1, ease: "expo.out" }))) }, Q = () => { F?.setAttribute("data-mouse", "false"), gsapWithCSS.effects.inScrambleText(G, { text: "＋" }), gsapWithCSS.to(Y, { scale: 1, duration: .8, ease: "expo.out", overwrite: !0 }) }; K.removeEventListener("mouseenter", Z), K.removeEventListener("mouseleave", Q), K.addEventListener("mouseenter", Z), K.addEventListener("mouseleave", Q) }) } anchorTo() { document.querySelectorAll("[data-to]").forEach(F => { const G = F.getAttribute("data-to"); F.addEventListener("click", () => { gsapWithCSS.to(window, { scrollTo: { y: `${G}` }, duration: 1, ease: "power2.inOut" }) }) }) } setOpacity() { $$1("[data-container='index']") || ($$1("header").classList.add("opacity-100"), $$1('[data-parts-transition-bg="light"]').classList.add("opacity-100")) } };/*!
 * paths 3.12.7
 * https://gsap.com
 *
 * Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/var _svgPathExp = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig, _scientific = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/ig, _DEG2RAD = Math.PI / 180, _sin = Math.sin, _cos = Math.cos, _abs = Math.abs, _sqrt$1 = Math.sqrt, _isNumber = function (F) { return typeof F == "number" }, _roundingNum = 1e5, _round$2 = function (F) { return Math.round(F * _roundingNum) / _roundingNum || 0 }; function transformRawPath(z, F, G, Y, X, K, J) { for (var Z = z.length, Q, ee, te, oe, ie; --Z > -1;)for (Q = z[Z], ee = Q.length, te = 0; te < ee; te += 2)oe = Q[te], ie = Q[te + 1], Q[te] = oe * F + ie * Y + K, Q[te + 1] = oe * G + ie * X + J; return z._dirty = 1, z } function arcToSegment(z, F, G, Y, X, K, J, Z, Q) { if (!(z === Z && F === Q)) { G = _abs(G), Y = _abs(Y); var ee = X % 360 * _DEG2RAD, te = _cos(ee), oe = _sin(ee), ie = Math.PI, se = ie * 2, ne = (z - Z) / 2, re = (F - Q) / 2, fe = te * ne + oe * re, ae = -oe * ne + te * re, he = fe * fe, le = ae * ae, ce = he / (G * G) + le / (Y * Y); ce > 1 && (G = _sqrt$1(ce) * G, Y = _sqrt$1(ce) * Y); var ue = G * G, me = Y * Y, ge = (ue * me - ue * le - me * he) / (ue * le + me * he); ge < 0 && (ge = 0); var ve = (K === J ? -1 : 1) * _sqrt$1(ge), Se = ve * (G * ae / Y), ke = ve * -(Y * fe / G), Ce = (z + Z) / 2, Ee = (F + Q) / 2, De = Ce + (te * Se - oe * ke), Pe = Ee + (oe * Se + te * ke), Te = (fe - Se) / G, ye = (ae - ke) / Y, xe = (-fe - Se) / G, pe = (-ae - ke) / Y, de = Te * Te + ye * ye, _e = (ye < 0 ? -1 : 1) * Math.acos(Te / _sqrt$1(de)), be = (Te * pe - ye * xe < 0 ? -1 : 1) * Math.acos((Te * xe + ye * pe) / _sqrt$1(de * (xe * xe + pe * pe))); isNaN(be) && (be = ie), !J && be > 0 ? be -= se : J && be < 0 && (be += se), _e %= se, be %= se; var Ae = Math.ceil(_abs(be) / (se / 4)), $e = [], Fe = be / Ae, Ie = 4 / 3 * _sin(Fe / 2) / (1 + _cos(Fe / 2)), Be = te * G, Ve = oe * G, Ze = oe * -Y, Qe = te * Y, Ue; for (Ue = 0; Ue < Ae; Ue++)X = _e + Ue * Fe, fe = _cos(X), ae = _sin(X), Te = _cos(X += Fe), ye = _sin(X), $e.push(fe - Ie * ae, ae + Ie * fe, Te + Ie * ye, ye - Ie * Te, Te, ye); for (Ue = 0; Ue < $e.length; Ue += 2)fe = $e[Ue], ae = $e[Ue + 1], $e[Ue] = fe * Be + ae * Ze + De, $e[Ue + 1] = fe * Ve + ae * Qe + Pe; return $e[Ue - 2] = Z, $e[Ue - 1] = Q, $e } } function stringToRawPath(z) { var F = (z + "").replace(_scientific, function (Se) { var ke = +Se; return ke < 1e-4 && ke > -1e-4 ? 0 : ke }).match(_svgPathExp) || [], G = [], Y = 0, X = 0, K = 2 / 3, J = F.length, Z = 0, Q = "ERROR: malformed path: " + z, ee, te, oe, ie, se, ne, re, fe, ae, he, le, ce, ue, me, ge, ve = function (ke, Ce, Ee, De) { he = (Ee - ke) / 3, le = (De - Ce) / 3, re.push(ke + he, Ce + le, Ee - he, De - le, Ee, De) }; if (!z || !isNaN(F[0]) || isNaN(F[1])) return console.log(Q), G; for (ee = 0; ee < J; ee++)if (ue = se, isNaN(F[ee]) ? (se = F[ee].toUpperCase(), ne = se !== F[ee]) : ee--, oe = +F[ee + 1], ie = +F[ee + 2], ne && (oe += Y, ie += X), ee || (fe = oe, ae = ie), se === "M") re && (re.length < 8 ? G.length -= 1 : Z += re.length), Y = fe = oe, X = ae = ie, re = [oe, ie], G.push(re), ee += 2, se = "L"; else if (se === "C") re || (re = [0, 0]), ne || (Y = X = 0), re.push(oe, ie, Y + F[ee + 3] * 1, X + F[ee + 4] * 1, Y += F[ee + 5] * 1, X += F[ee + 6] * 1), ee += 6; else if (se === "S") he = Y, le = X, (ue === "C" || ue === "S") && (he += Y - re[re.length - 4], le += X - re[re.length - 3]), ne || (Y = X = 0), re.push(he, le, oe, ie, Y += F[ee + 3] * 1, X += F[ee + 4] * 1), ee += 4; else if (se === "Q") he = Y + (oe - Y) * K, le = X + (ie - X) * K, ne || (Y = X = 0), Y += F[ee + 3] * 1, X += F[ee + 4] * 1, re.push(he, le, Y + (oe - Y) * K, X + (ie - X) * K, Y, X), ee += 4; else if (se === "T") he = Y - re[re.length - 4], le = X - re[re.length - 3], re.push(Y + he, X + le, oe + (Y + he * 1.5 - oe) * K, ie + (X + le * 1.5 - ie) * K, Y = oe, X = ie), ee += 2; else if (se === "H") ve(Y, X, Y = oe, X), ee += 1; else if (se === "V") ve(Y, X, Y, X = oe + (ne ? X - Y : 0)), ee += 1; else if (se === "L" || se === "Z") se === "Z" && (oe = fe, ie = ae, re.closed = !0), (se === "L" || _abs(Y - oe) > .5 || _abs(X - ie) > .5) && (ve(Y, X, oe, ie), se === "L" && (ee += 2)), Y = oe, X = ie; else if (se === "A") { if (me = F[ee + 4], ge = F[ee + 5], he = F[ee + 6], le = F[ee + 7], te = 7, me.length > 1 && (me.length < 3 ? (le = he, he = ge, te--) : (le = ge, he = me.substr(2), te -= 2), ge = me.charAt(1), me = me.charAt(0)), ce = arcToSegment(Y, X, +F[ee + 1], +F[ee + 2], +F[ee + 3], +me, +ge, (ne ? Y : 0) + he * 1, (ne ? X : 0) + le * 1), ee += te, ce) for (te = 0; te < ce.length; te++)re.push(ce[te]); Y = re[re.length - 2], X = re[re.length - 1] } else console.log(Q); return ee = re.length, ee < 6 ? (G.pop(), ee = 0) : re[0] === re[ee - 2] && re[1] === re[ee - 1] && (re.closed = !0), G.totalPoints = Z + ee, G } function rawPathToString(z) { _isNumber(z[0]) && (z = [z]); var F = "", G = z.length, Y, X, K, J; for (X = 0; X < G; X++) { for (J = z[X], F += "M" + _round$2(J[0]) + "," + _round$2(J[1]) + " C", Y = J.length, K = 2; K < Y; K++)F += _round$2(J[K++]) + "," + _round$2(J[K++]) + " " + _round$2(J[K++]) + "," + _round$2(J[K++]) + " " + _round$2(J[K++]) + "," + _round$2(J[K]) + " "; J.closed && (F += "z") } return F }/*!
 * CustomEase 3.12.7
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/var gsap$2, _coreInitted$1, _getGSAP$2 = function () { return gsap$2 || typeof window < "u" && (gsap$2 = window.gsap) && gsap$2.registerPlugin && gsap$2 }, _initCore$1 = function () { gsap$2 = _getGSAP$2(), gsap$2 ? (gsap$2.registerEase("_CE", CustomEase.create), _coreInitted$1 = 1) : console.warn("Please gsap.registerPlugin(CustomEase)") }, _bigNum = 1e20, _round$1 = function (F) { return ~~(F * 1e3 + (F < 0 ? -.5 : .5)) / 1e3 }, _numExp$1 = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/gi, _needsParsingExp = /[cLlsSaAhHvVtTqQ]/g, _findMinimum = function (F) { var G = F.length, Y = _bigNum, X; for (X = 1; X < G; X += 6)+F[X] < Y && (Y = +F[X]); return Y }, _normalize = function (F, G, Y) { !Y && Y !== 0 && (Y = Math.max(+F[F.length - 1], +F[1])); var X = +F[0] * -1, K = -Y, J = F.length, Z = 1 / (+F[J - 2] + X), Q = -G || (Math.abs(+F[J - 1] - +F[1]) < .01 * (+F[J - 2] - +F[0]) ? _findMinimum(F) + K : +F[J - 1] + K), ee; for (Q ? Q = 1 / Q : Q = -Z, ee = 0; ee < J; ee += 2)F[ee] = (+F[ee] + X) * Z, F[ee + 1] = (+F[ee + 1] + K) * Q }, _bezierToPoints = function z(F, G, Y, X, K, J, Z, Q, ee, te, oe) { var ie = (F + Y) / 2, se = (G + X) / 2, ne = (Y + K) / 2, re = (X + J) / 2, fe = (K + Z) / 2, ae = (J + Q) / 2, he = (ie + ne) / 2, le = (se + re) / 2, ce = (ne + fe) / 2, ue = (re + ae) / 2, me = (he + ce) / 2, ge = (le + ue) / 2, ve = Z - F, Se = Q - G, ke = Math.abs((Y - Z) * Se - (X - Q) * ve), Ce = Math.abs((K - Z) * Se - (J - Q) * ve), Ee; return te || (te = [{ x: F, y: G }, { x: Z, y: Q }], oe = 1), te.splice(oe || te.length - 1, 0, { x: me, y: ge }), (ke + Ce) * (ke + Ce) > ee * (ve * ve + Se * Se) && (Ee = te.length, z(F, G, ie, se, he, le, me, ge, ee, te, oe), z(me, ge, ce, ue, fe, ae, Z, Q, ee, te, oe + 1 + (te.length - Ee))), te }, CustomEase = function () { function z(G, Y, X) { _coreInitted$1 || _initCore$1(), this.id = G, this.setData(Y, X) } var F = z.prototype; return F.setData = function (Y, X) { X = X || {}, Y = Y || "0,0,1,1"; var K = Y.match(_numExp$1), J = 1, Z = [], Q = [], ee = X.precision || 1, te = ee <= 1, oe, ie, se, ne, re, fe, ae, he, le; if (this.data = Y, (_needsParsingExp.test(Y) || ~Y.indexOf("M") && Y.indexOf("C") < 0) && (K = stringToRawPath(Y)[0]), oe = K.length, oe === 4) K.unshift(0, 0), K.push(1, 1), oe = 8; else if ((oe - 2) % 6) throw "Invalid CustomEase"; for ((+K[0] != 0 || +K[oe - 2] != 1) && _normalize(K, X.height, X.originY), this.segment = K, ne = 2; ne < oe; ne += 6)ie = { x: +K[ne - 2], y: +K[ne - 1] }, se = { x: +K[ne + 4], y: +K[ne + 5] }, Z.push(ie, se), _bezierToPoints(ie.x, ie.y, +K[ne], +K[ne + 1], +K[ne + 2], +K[ne + 3], se.x, se.y, 1 / (ee * 2e5), Z, Z.length - 1); for (oe = Z.length, ne = 0; ne < oe; ne++)ae = Z[ne], he = Z[ne - 1] || ae, (ae.x > he.x || he.y !== ae.y && he.x === ae.x || ae === he) && ae.x <= 1 ? (he.cx = ae.x - he.x, he.cy = ae.y - he.y, he.n = ae, he.nx = ae.x, te && ne > 1 && Math.abs(he.cy / he.cx - Z[ne - 2].cy / Z[ne - 2].cx) > 2 && (te = 0), he.cx < J && (he.cx ? J = he.cx : (he.cx = .001, ne === oe - 1 && (he.x -= .001, J = Math.min(J, .001), te = 0)))) : (Z.splice(ne--, 1), oe--); if (oe = 1 / J + 1 | 0, re = 1 / oe, fe = 0, ae = Z[0], te) { for (ne = 0; ne < oe; ne++)le = ne * re, ae.nx < le && (ae = Z[++fe]), ie = ae.y + (le - ae.x) / ae.cx * ae.cy, Q[ne] = { x: le, cx: re, y: ie, cy: 0, nx: 9 }, ne && (Q[ne - 1].cy = ie - Q[ne - 1].y); fe = Z[Z.length - 1], Q[oe - 1].cy = fe.y - ie, Q[oe - 1].cx = fe.x - Q[Q.length - 1].x } else { for (ne = 0; ne < oe; ne++)ae.nx < ne * re && (ae = Z[++fe]), Q[ne] = ae; fe < Z.length - 1 && (Q[ne - 1] = Z[Z.length - 2]) } return this.ease = function (ce) { var ue = Q[ce * oe | 0] || Q[oe - 1]; return ue.nx < ce && (ue = ue.n), ue.y + (ce - ue.x) / ue.cx * ue.cy }, this.ease.custom = this, this.id && gsap$2 && gsap$2.registerEase(this.id, this.ease), this }, F.getSVGData = function (Y) { return z.getSVGData(this, Y) }, z.create = function (Y, X, K) { return new z(Y, X, K).ease }, z.register = function (Y) { gsap$2 = Y, _initCore$1() }, z.get = function (Y) { return gsap$2.parseEase(Y) }, z.getSVGData = function (Y, X) { X = X || {}; var K = X.width || 100, J = X.height || 100, Z = X.x || 0, Q = (X.y || 0) + J, ee = gsap$2.utils.toArray(X.path)[0], te, oe, ie, se, ne, re, fe, ae, he, le; if (X.invert && (J = -J, Q = 0), typeof Y == "string" && (Y = gsap$2.parseEase(Y)), Y.custom && (Y = Y.custom), Y instanceof z) te = rawPathToString(transformRawPath([Y.segment], K, 0, 0, -J, Z, Q)); else { for (te = [Z, Q], fe = Math.max(5, (X.precision || 1) * 200), se = 1 / fe, fe += 2, ae = 5 / fe, he = _round$1(Z + se * K), le = _round$1(Q + Y(se) * -J), oe = (le - Q) / (he - Z), ie = 2; ie < fe; ie++)ne = _round$1(Z + ie * se * K), re = _round$1(Q + Y(ie * se) * -J), (Math.abs((re - le) / (ne - he) - oe) > ae || ie === fe - 1) && (te.push(he, le), oe = (re - le) / (ne - he)), he = ne, le = re; te = "M" + te.join(",") } return ee && ee.setAttribute("d", te), te }, z }(); CustomEase.version = "3.12.7"; CustomEase.headless = !0; _getGSAP$2() && gsap$2.registerPlugin(CustomEase); gsapWithCSS.registerPlugin(ScrambleTextPlugin, CustomEase); const ease = { easeOutExpo: CustomEase.create("custom", "M0,0 C0,0.573 0.092,0.778 0.176,0.866 0.26,0.954 0.394,1 1,1 ") }, registerEffects = () => { gsapWithCSS.registerEffect({ name: "inScrambleText", extendTimeline: !0, effect: (z, F) => gsapWithCSS.to(z, { duration: F.duration, delay: F.delay, scrambleText: { text: F.text, chars: F.chars, speed: F.speed, revealDelay: F.revealDelay } }), defaults: { text: "", chars: "0123456789", speed: 1.5, duration: 1.5, delay: 0, revealDelay: 0 } }), gsapWithCSS.registerEffect({ name: "setTitle", extendTimeline: !0, effect: z => gsapWithCSS.set(z, { y: "100%" }) }), gsapWithCSS.registerEffect({ name: "inTitle", extendTimeline: !0, effect: (z, F) => gsapWithCSS.to(z, { duration: F.duration, y: 0, ease: CustomEase.create("custom", "M0,0 C0.068,0.007 0.105,0.014 0.14,0.117 0.174,0.219 0.198,0.353 0.214,0.502 0.225,0.614 0.268,0.772 0.341,0.86 0.448,0.99 0.704,1 1,1 "), stagger: F.stagger }), defaults: { stagger: .1, duration: 1.6 } }), gsapWithCSS.registerEffect({ name: "setText", extendTimeline: !0, effect: z => gsapWithCSS.set(z, { y: "100%" }) }), gsapWithCSS.registerEffect({ name: "inText", extendTimeline: !0, effect: (z, F) => gsapWithCSS.to(z, { duration: 2.4, y: 0, ease: ease.easeOutExpo, stagger: F.stagger, delay: F.delay }), defaults: { stagger: .2, delay: 0 } }), gsapWithCSS.registerEffect({ name: "setTextSerif", extendTimeline: !0, effect: z => gsapWithCSS.set(z, { opacity: 0, perspective: 500, rotateY: 90 }) }), gsapWithCSS.registerEffect({ name: "inTextSerif", extendTimeline: !0, effect: z => gsapWithCSS.to(z, { duration: 2, rotateY: 0, opacity: 1, ease: "expo.out", stagger: { amount: .6, from: "random" } }) }), gsapWithCSS.registerEffect({ name: "setLine", extendTimeline: !0, effect: z => gsapWithCSS.set(z, { scaleX: 0, transformOrigin: "left" }) }), gsapWithCSS.registerEffect({ name: "inLine", extendTimeline: !0, effect: (z, F) => gsapWithCSS.to(z, { duration: getDeviceType() === "sp" ? 1.5 : 2, scaleX: 1, ease: "power3.inOut", stagger: F.stagger }), defaults: { stagger: .25 } }), gsapWithCSS.registerEffect({ name: "setImageMask", extendTimeline: !0, effect: z => gsapWithCSS.set(z, { maskImage: "linear-gradient(to bottom, black 0%, black 100%)", webkitMaskImage: "linear-gradient(to bottom, black 0%, black 100%)", maskPosition: "100% top", webkitMaskPosition: "100% top", maskRepeat: "no-repeat", webkitMaskRepeat: "no-repeat", maskSize: "100% 0%", webkitMaskSize: "100% 0%", transformOrigin: "top left" }) }), gsapWithCSS.registerEffect({ name: "setImageMaskToRight", extendTimeline: !0, effect: z => gsapWithCSS.set(z, { maskImage: "linear-gradient(to right, black 0%, black 100%)", webkitMaskImage: "linear-gradient(to right, black 0%, black 100%)", maskPosition: "left 100%", webkitMaskPosition: "left 100%", maskRepeat: "no-repeat", webkitMaskRepeat: "no-repeat", maskSize: "0% 100%", webkitMaskSize: "0% 100%", transformOrigin: "left top" }) }), gsapWithCSS.registerEffect({ name: "setImage", extendTimeline: !0, effect: z => gsapWithCSS.set(z, { scale: 1.6 }) }), gsapWithCSS.registerEffect({ name: "inImageMask", extendTimeline: !0, effect: (z, F) => gsapWithCSS.to(z, { maskSize: "100% 100%", webkitMaskSize: "100% 100%", duration: F.duration, ease: F.ease, stagger: F.stagger }), defaults: { duration: 1.2, ease: "power3.out", stagger: 0 } }), gsapWithCSS.registerEffect({ name: "inImage", extendTimeline: !0, effect: z => gsapWithCSS.to(z, { scale: 1, duration: 2, ease: "power3.out" }) }) };/*!
 * DrawSVGPlugin 3.12.7
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/var gsap$1, _toArray, _win, _isEdge, _coreInitted, _warned, _getStyleSaver, _reverting, _windowExists = function () { return typeof window < "u" }, _getGSAP$1 = function () { return gsap$1 || _windowExists() && (gsap$1 = window.gsap) && gsap$1.registerPlugin && gsap$1 }, _numExp = /[-+=\.]*\d+[\.e\-\+]*\d*[e\-\+]*\d*/gi, _types = { rect: ["width", "height"], circle: ["r", "r"], ellipse: ["rx", "ry"], line: ["x2", "y2"] }, _round = function (F) { return Math.round(F * 1e4) / 1e4 }, _parseNum = function (F) { return parseFloat(F) || 0 }, _parseSingleVal = function (F, G) { var Y = _parseNum(F); return ~F.indexOf("%") ? Y / 100 * G : Y }, _getAttributeAsNumber = function (F, G) { return _parseNum(F.getAttribute(G)) }, _sqrt = Math.sqrt, _getDistance = function (F, G, Y, X, K, J) { return _sqrt(Math.pow((_parseNum(Y) - _parseNum(F)) * K, 2) + Math.pow((_parseNum(X) - _parseNum(G)) * J, 2)) }, _warn = function (F) { return console.warn(F) }, _hasNonScalingStroke = function (F) { return F.getAttribute("vector-effect") === "non-scaling-stroke" }, _bonusValidated = 1, _parse = function (F, G, Y) { var X = F.indexOf(" "), K, J; return X < 0 ? (K = Y !== void 0 ? Y + "" : F, J = F) : (K = F.substr(0, X), J = F.substr(X + 1)), K = _parseSingleVal(K, G), J = _parseSingleVal(J, G), K > J ? [J, K] : [K, J] }, _getLength = function (F) { if (F = _toArray(F)[0], !F) return 0; var G = F.tagName.toLowerCase(), Y = F.style, X = 1, K = 1, J, Z, Q, ee, te, oe, ie; _hasNonScalingStroke(F) && (K = F.getScreenCTM(), X = _sqrt(K.a * K.a + K.b * K.b), K = _sqrt(K.d * K.d + K.c * K.c)); try { Z = F.getBBox() } catch { _warn("Some browsers won't measure invisible elements (like display:none or masks inside defs).") } var se = Z || { x: 0, y: 0, width: 0, height: 0 }, ne = se.x, re = se.y, fe = se.width, ae = se.height; if ((!Z || !fe && !ae) && _types[G] && (fe = _getAttributeAsNumber(F, _types[G][0]), ae = _getAttributeAsNumber(F, _types[G][1]), G !== "rect" && G !== "line" && (fe *= 2, ae *= 2), G === "line" && (ne = _getAttributeAsNumber(F, "x1"), re = _getAttributeAsNumber(F, "y1"), fe = Math.abs(fe - ne), ae = Math.abs(ae - re))), G === "path") ee = Y.strokeDasharray, Y.strokeDasharray = "none", J = F.getTotalLength() || 0, _round(X) !== _round(K) && !_warned && (_warned = 1) && _warn("Warning: <path> length cannot be measured when vector-effect is non-scaling-stroke and the element isn't proportionally scaled."), J *= (X + K) / 2, Y.strokeDasharray = ee; else if (G === "rect") J = fe * 2 * X + ae * 2 * K; else if (G === "line") J = _getDistance(ne, re, ne + fe, re + ae, X, K); else if (G === "polyline" || G === "polygon") for (Q = F.getAttribute("points").match(_numExp) || [], G === "polygon" && Q.push(Q[0], Q[1]), J = 0, te = 2; te < Q.length; te += 2)J += _getDistance(Q[te - 2], Q[te - 1], Q[te], Q[te + 1], X, K) || 0; else (G === "circle" || G === "ellipse") && (oe = fe / 2 * X, ie = ae / 2 * K, J = Math.PI * (3 * (oe + ie) - _sqrt((3 * oe + ie) * (oe + 3 * ie)))); return J || 0 }, _getPosition = function (F, G) { if (F = _toArray(F)[0], !F) return [0, 0]; G || (G = _getLength(F) + 1); var Y = _win.getComputedStyle(F), X = Y.strokeDasharray || "", K = _parseNum(Y.strokeDashoffset), J = X.indexOf(","); return J < 0 && (J = X.indexOf(" ")), X = J < 0 ? G : _parseNum(X.substr(0, J)), X > G && (X = G), [-K || 0, X - K || 0] }, _initCore = function () { _windowExists() && (_win = window, _coreInitted = gsap$1 = _getGSAP$1(), _toArray = gsap$1.utils.toArray, _getStyleSaver = gsap$1.core.getStyleSaver, _reverting = gsap$1.core.reverting || function () { }, _isEdge = ((_win.navigator || {}).userAgent || "").indexOf("Edge") !== -1) }, DrawSVGPlugin = { version: "3.12.7", name: "drawSVG", register: function (F) { gsap$1 = F, _initCore() }, init: function (F, G, Y, X, K) { if (!F.getBBox) return !1; _coreInitted || _initCore(); var J = _getLength(F), Z, Q, ee; return this.styles = _getStyleSaver && _getStyleSaver(F, "strokeDashoffset,strokeDasharray,strokeMiterlimit"), this.tween = Y, this._style = F.style, this._target = F, G + "" == "true" ? G = "0 100%" : G ? (G + "").indexOf(" ") === -1 && (G = "0 " + G) : G = "0 0", Z = _getPosition(F, J), Q = _parse(G, J, Z[0]), this._length = _round(J), this._dash = _round(Z[1] - Z[0]), this._offset = _round(-Z[0]), this._dashPT = this.add(this, "_dash", this._dash, _round(Q[1] - Q[0]), 0, 0, 0, 0, 0, 1), this._offsetPT = this.add(this, "_offset", this._offset, _round(-Q[0]), 0, 0, 0, 0, 0, 1), _isEdge && (ee = _win.getComputedStyle(F), ee.strokeLinecap !== ee.strokeLinejoin && (Q = _parseNum(ee.strokeMiterlimit), this.add(F.style, "strokeMiterlimit", Q, Q + .01))), this._live = _hasNonScalingStroke(F) || ~(G + "").indexOf("live"), this._nowrap = ~(G + "").indexOf("nowrap"), this._props.push("drawSVG"), _bonusValidated }, render: function (F, G) { if (G.tween._time || !_reverting()) { var Y = G._pt, X = G._style, K, J, Z, Q; if (Y) { for (G._live && (K = _getLength(G._target), K !== G._length && (J = K / G._length, G._length = K, G._offsetPT && (G._offsetPT.s *= J, G._offsetPT.c *= J), G._dashPT ? (G._dashPT.s *= J, G._dashPT.c *= J) : G._dash *= J)); Y;)Y.r(F, Y.d), Y = Y._next; Z = G._dash || F && F !== 1 && 1e-4 || 0, K = G._length - Z + .1, Q = G._offset, Z && Q && Z + Math.abs(Q % G._length) > G._length - .2 && (Q += Q < 0 ? .1 : -.1) && (K += .1), X.strokeDashoffset = Z ? Q : Q + .001, X.strokeDasharray = K < .2 ? "none" : Z ? Z + "px," + (G._nowrap ? 999999 : K) + "px" : "0px, 999999px" } } else G.styles.revert() }, getLength: _getLength, getPosition: _getPosition }; _getGSAP$1() && gsap$1.registerPlugin(DrawSVGPlugin);/*!
 * TextPlugin 3.12.7
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/var gsap, _tempDiv, _getGSAP = function () { return gsap || typeof window < "u" && (gsap = window.gsap) && gsap.registerPlugin && gsap }, TextPlugin = { version: "3.12.7", name: "text", init: function (F, G, Y) { typeof G != "object" && (G = { value: G }); var X = F.nodeName.toUpperCase(), K = this, J = G, Z = J.newClass, Q = J.oldClass, ee = J.preserveSpaces, te = J.rtl, oe = K.delimiter = G.delimiter || "", ie = K.fillChar = G.fillChar || (G.padSpace ? "&nbsp;" : ""), se, ne, re, fe, ae, he, le, ce; if (K.svg = F.getBBox && (X === "TEXT" || X === "TSPAN"), !("innerHTML" in F) && !K.svg) return !1; if (K.target = F, !("value" in G)) { K.text = K.original = [""]; return } for (re = splitInnerHTML(F, oe, !1, ee, K.svg), _tempDiv || (_tempDiv = document.createElement("div")), _tempDiv.innerHTML = G.value, ne = splitInnerHTML(_tempDiv, oe, !1, ee, K.svg), K.from = Y._from, (K.from || te) && !(te && K.from) && (X = re, re = ne, ne = X), K.hasClass = !!(Z || Q), K.newClass = te ? Q : Z, K.oldClass = te ? Z : Q, X = re.length - ne.length, se = X < 0 ? re : ne, X < 0 && (X = -X); --X > -1;)se.push(ie); if (G.type === "diff") { for (fe = 0, ae = [], he = [], le = "", X = 0; X < ne.length; X++)ce = ne[X], ce === re[X] ? le += ce : (ae[fe] = le + ce, he[fe++] = le + re[X], le = ""); ne = ae, re = he, le && (ne.push(le), re.push(le)) } G.speed && Y.duration(Math.min(.05 / G.speed * se.length, G.maxDuration || 9999)), K.rtl = te, K.original = re, K.text = ne, K._props.push("text") }, render: function (F, G) { F > 1 ? F = 1 : F < 0 && (F = 0), G.from && (F = 1 - F); var Y = G.text, X = G.hasClass, K = G.newClass, J = G.oldClass, Z = G.delimiter, Q = G.target, ee = G.fillChar, te = G.original, oe = G.rtl, ie = Y.length, se = (oe ? 1 - F : F) * ie + .5 | 0, ne, re, fe; X && F ? (ne = K && se, re = J && se !== ie, fe = (ne ? "<span class='" + K + "'>" : "") + Y.slice(0, se).join(Z) + (ne ? "</span>" : "") + (re ? "<span class='" + J + "'>" : "") + Z + te.slice(se).join(Z) + (re ? "</span>" : "")) : fe = Y.slice(0, se).join(Z) + Z + te.slice(se).join(Z), G.svg ? Q.textContent = fe : Q.innerHTML = ee === "&nbsp;" && ~fe.indexOf("  ") ? fe.split("  ").join("&nbsp;&nbsp;") : fe } }; TextPlugin.splitInnerHTML = splitInnerHTML; TextPlugin.emojiSafeSplit = emojiSafeSplit; TextPlugin.getText = getText; _getGSAP() && gsap.registerPlugin(TextPlugin); var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}; function getDefaultExportFromCjs(z) { return z && z.__esModule && Object.prototype.hasOwnProperty.call(z, "default") ? z.default : z } var lottie$1 = { exports: {} }; (function (module, exports) {
    typeof navigator < "u" && function (z, F) { module.exports = F() }(commonjsGlobal, function () {
        var svgNS = "http://www.w3.org/2000/svg", locationHref = "", _useWebWorker = !1, initialDefaultFrame = -999999, setWebWorker = function (F) { _useWebWorker = !!F }, getWebWorker = function () { return _useWebWorker }, setLocationHref = function (F) { locationHref = F }, getLocationHref = function () { return locationHref }; function createTag(z) { return document.createElement(z) } function extendPrototype(z, F) { var G, Y = z.length, X; for (G = 0; G < Y; G += 1) { X = z[G].prototype; for (var K in X) Object.prototype.hasOwnProperty.call(X, K) && (F.prototype[K] = X[K]) } } function getDescriptor(z, F) { return Object.getOwnPropertyDescriptor(z, F) } function createProxyFunction(z) { function F() { } return F.prototype = z, F } var audioControllerFactory = function () { function z(F) { this.audios = [], this.audioFactory = F, this._volume = 1, this._isMuted = !1 } return z.prototype = { addAudio: function (G) { this.audios.push(G) }, pause: function () { var G, Y = this.audios.length; for (G = 0; G < Y; G += 1)this.audios[G].pause() }, resume: function () { var G, Y = this.audios.length; for (G = 0; G < Y; G += 1)this.audios[G].resume() }, setRate: function (G) { var Y, X = this.audios.length; for (Y = 0; Y < X; Y += 1)this.audios[Y].setRate(G) }, createAudio: function (G) { return this.audioFactory ? this.audioFactory(G) : window.Howl ? new window.Howl({ src: [G] }) : { isPlaying: !1, play: function () { this.isPlaying = !0 }, seek: function () { this.isPlaying = !1 }, playing: function () { }, rate: function () { }, setVolume: function () { } } }, setAudioFactory: function (G) { this.audioFactory = G }, setVolume: function (G) { this._volume = G, this._updateVolume() }, mute: function () { this._isMuted = !0, this._updateVolume() }, unmute: function () { this._isMuted = !1, this._updateVolume() }, getVolume: function () { return this._volume }, _updateVolume: function () { var G, Y = this.audios.length; for (G = 0; G < Y; G += 1)this.audios[G].volume(this._volume * (this._isMuted ? 0 : 1)) } }, function () { return new z } }(), createTypedArray = function () { function z(G, Y) { var X = 0, K = [], J; switch (G) { case "int16": case "uint8c": J = 1; break; default: J = 1.1; break }for (X = 0; X < Y; X += 1)K.push(J); return K } function F(G, Y) { return G === "float32" ? new Float32Array(Y) : G === "int16" ? new Int16Array(Y) : G === "uint8c" ? new Uint8ClampedArray(Y) : z(G, Y) } return typeof Uint8ClampedArray == "function" && typeof Float32Array == "function" ? F : z }(); function createSizedArray(z) { return Array.apply(null, { length: z }) } function _typeof$6(z) { "@babel/helpers - typeof"; return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$6 = function (G) { return typeof G } : _typeof$6 = function (G) { return G && typeof Symbol == "function" && G.constructor === Symbol && G !== Symbol.prototype ? "symbol" : typeof G }, _typeof$6(z) } var subframeEnabled = !0, expressionsPlugin = null, expressionsInterfaces = null, idPrefix$1 = "", isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent), bmPow = Math.pow, bmSqrt = Math.sqrt, bmFloor = Math.floor, bmMax = Math.max, bmMin = Math.min, BMMath = {}; (function () { var z = ["abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "ceil", "cbrt", "expm1", "clz32", "cos", "cosh", "exp", "floor", "fround", "hypot", "imul", "log", "log1p", "log2", "log10", "max", "min", "pow", "random", "round", "sign", "sin", "sinh", "sqrt", "tan", "tanh", "trunc", "E", "LN10", "LN2", "LOG10E", "LOG2E", "PI", "SQRT1_2", "SQRT2"], F, G = z.length; for (F = 0; F < G; F += 1)BMMath[z[F]] = Math[z[F]] })(), BMMath.random = Math.random, BMMath.abs = function (z) { var F = _typeof$6(z); if (F === "object" && z.length) { var G = createSizedArray(z.length), Y, X = z.length; for (Y = 0; Y < X; Y += 1)G[Y] = Math.abs(z[Y]); return G } return Math.abs(z) }; var defaultCurveSegments = 150, degToRads = Math.PI / 180, roundCorner = .5519; function styleDiv(z) { z.style.position = "absolute", z.style.top = 0, z.style.left = 0, z.style.display = "block", z.style.transformOrigin = "0 0", z.style.webkitTransformOrigin = "0 0", z.style.backfaceVisibility = "visible", z.style.webkitBackfaceVisibility = "visible", z.style.transformStyle = "preserve-3d", z.style.webkitTransformStyle = "preserve-3d", z.style.mozTransformStyle = "preserve-3d" } function BMEnterFrameEvent(z, F, G, Y) { this.type = z, this.currentTime = F, this.totalTime = G, this.direction = Y < 0 ? -1 : 1 } function BMCompleteEvent(z, F) { this.type = z, this.direction = F < 0 ? -1 : 1 } function BMCompleteLoopEvent(z, F, G, Y) { this.type = z, this.currentLoop = G, this.totalLoops = F, this.direction = Y < 0 ? -1 : 1 } function BMSegmentStartEvent(z, F, G) { this.type = z, this.firstFrame = F, this.totalFrames = G } function BMDestroyEvent(z, F) { this.type = z, this.target = F } function BMRenderFrameErrorEvent(z, F) { this.type = "renderFrameError", this.nativeError = z, this.currentTime = F } function BMConfigErrorEvent(z) { this.type = "configError", this.nativeError = z } var createElementID = function () { var z = 0; return function () { return z += 1, idPrefix$1 + "__lottie_element_" + z } }(); function HSVtoRGB(z, F, G) { var Y, X, K, J, Z, Q, ee, te; switch (J = Math.floor(z * 6), Z = z * 6 - J, Q = G * (1 - F), ee = G * (1 - Z * F), te = G * (1 - (1 - Z) * F), J % 6) { case 0: Y = G, X = te, K = Q; break; case 1: Y = ee, X = G, K = Q; break; case 2: Y = Q, X = G, K = te; break; case 3: Y = Q, X = ee, K = G; break; case 4: Y = te, X = Q, K = G; break; case 5: Y = G, X = Q, K = ee; break }return [Y, X, K] } function RGBtoHSV(z, F, G) { var Y = Math.max(z, F, G), X = Math.min(z, F, G), K = Y - X, J, Z = Y === 0 ? 0 : K / Y, Q = Y / 255; switch (Y) { case X: J = 0; break; case z: J = F - G + K * (F < G ? 6 : 0), J /= 6 * K; break; case F: J = G - z + K * 2, J /= 6 * K; break; case G: J = z - F + K * 4, J /= 6 * K; break }return [J, Z, Q] } function addSaturationToRGB(z, F) { var G = RGBtoHSV(z[0] * 255, z[1] * 255, z[2] * 255); return G[1] += F, G[1] > 1 ? G[1] = 1 : G[1] <= 0 && (G[1] = 0), HSVtoRGB(G[0], G[1], G[2]) } function addBrightnessToRGB(z, F) { var G = RGBtoHSV(z[0] * 255, z[1] * 255, z[2] * 255); return G[2] += F, G[2] > 1 ? G[2] = 1 : G[2] < 0 && (G[2] = 0), HSVtoRGB(G[0], G[1], G[2]) } function addHueToRGB(z, F) { var G = RGBtoHSV(z[0] * 255, z[1] * 255, z[2] * 255); return G[0] += F / 360, G[0] > 1 ? G[0] -= 1 : G[0] < 0 && (G[0] += 1), HSVtoRGB(G[0], G[1], G[2]) } var rgbToHex = function () { var z = [], F, G; for (F = 0; F < 256; F += 1)G = F.toString(16), z[F] = G.length === 1 ? "0" + G : G; return function (Y, X, K) { return Y < 0 && (Y = 0), X < 0 && (X = 0), K < 0 && (K = 0), "#" + z[Y] + z[X] + z[K] } }(), setSubframeEnabled = function (F) { subframeEnabled = !!F }, getSubframeEnabled = function () { return subframeEnabled }, setExpressionsPlugin = function (F) { expressionsPlugin = F }, getExpressionsPlugin = function () { return expressionsPlugin }, setExpressionInterfaces = function (F) { expressionsInterfaces = F }, getExpressionInterfaces = function () { return expressionsInterfaces }, setDefaultCurveSegments = function (F) { defaultCurveSegments = F }, getDefaultCurveSegments = function () { return defaultCurveSegments }, setIdPrefix = function (F) { idPrefix$1 = F }; function createNS(z) { return document.createElementNS(svgNS, z) } function _typeof$5(z) { "@babel/helpers - typeof"; return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$5 = function (G) { return typeof G } : _typeof$5 = function (G) { return G && typeof Symbol == "function" && G.constructor === Symbol && G !== Symbol.prototype ? "symbol" : typeof G }, _typeof$5(z) } var dataManager = function () { var z = 1, F = [], G, Y, X = { onmessage: function () { }, postMessage: function (se) { G({ data: se }) } }, K = { postMessage: function (se) { X.onmessage({ data: se }) } }; function J(ie) { if (window.Worker && window.Blob && getWebWorker()) { var se = new Blob(["var _workerSelf = self; self.onmessage = ", ie.toString()], { type: "text/javascript" }), ne = URL.createObjectURL(se); return new Worker(ne) } return G = ie, X } function Z() { Y || (Y = J(function (se) { function ne() { function fe(Te, ye) { var xe, pe, de = Te.length, _e, be, Ae, $e; for (pe = 0; pe < de; pe += 1)if (xe = Te[pe], "ks" in xe && !xe.completed) { if (xe.completed = !0, xe.hasMask) { var Fe = xe.masksProperties; for (be = Fe.length, _e = 0; _e < be; _e += 1)if (Fe[_e].pt.k.i) ue(Fe[_e].pt.k); else for ($e = Fe[_e].pt.k.length, Ae = 0; Ae < $e; Ae += 1)Fe[_e].pt.k[Ae].s && ue(Fe[_e].pt.k[Ae].s[0]), Fe[_e].pt.k[Ae].e && ue(Fe[_e].pt.k[Ae].e[0]) } xe.ty === 0 ? (xe.layers = le(xe.refId, ye), fe(xe.layers, ye)) : xe.ty === 4 ? ce(xe.shapes) : xe.ty === 5 && De(xe) } } function ae(Te, ye) { if (Te) { var xe = 0, pe = Te.length; for (xe = 0; xe < pe; xe += 1)Te[xe].t === 1 && (Te[xe].data.layers = le(Te[xe].data.refId, ye), fe(Te[xe].data.layers, ye)) } } function he(Te, ye) { for (var xe = 0, pe = ye.length; xe < pe;) { if (ye[xe].id === Te) return ye[xe]; xe += 1 } return null } function le(Te, ye) { var xe = he(Te, ye); return xe ? xe.layers.__used ? JSON.parse(JSON.stringify(xe.layers)) : (xe.layers.__used = !0, xe.layers) : null } function ce(Te) { var ye, xe = Te.length, pe, de; for (ye = xe - 1; ye >= 0; ye -= 1)if (Te[ye].ty === "sh") if (Te[ye].ks.k.i) ue(Te[ye].ks.k); else for (de = Te[ye].ks.k.length, pe = 0; pe < de; pe += 1)Te[ye].ks.k[pe].s && ue(Te[ye].ks.k[pe].s[0]), Te[ye].ks.k[pe].e && ue(Te[ye].ks.k[pe].e[0]); else Te[ye].ty === "gr" && ce(Te[ye].it) } function ue(Te) { var ye, xe = Te.i.length; for (ye = 0; ye < xe; ye += 1)Te.i[ye][0] += Te.v[ye][0], Te.i[ye][1] += Te.v[ye][1], Te.o[ye][0] += Te.v[ye][0], Te.o[ye][1] += Te.v[ye][1] } function me(Te, ye) { var xe = ye ? ye.split(".") : [100, 100, 100]; return Te[0] > xe[0] ? !0 : xe[0] > Te[0] ? !1 : Te[1] > xe[1] ? !0 : xe[1] > Te[1] ? !1 : Te[2] > xe[2] ? !0 : xe[2] > Te[2] ? !1 : null } var ge = function () { var Te = [4, 4, 14]; function ye(pe) { var de = pe.t.d; pe.t.d = { k: [{ s: de, t: 0 }] } } function xe(pe) { var de, _e = pe.length; for (de = 0; de < _e; de += 1)pe[de].ty === 5 && ye(pe[de]) } return function (pe) { if (me(Te, pe.v) && (xe(pe.layers), pe.assets)) { var de, _e = pe.assets.length; for (de = 0; de < _e; de += 1)pe.assets[de].layers && xe(pe.assets[de].layers) } } }(), ve = function () { var Te = [4, 7, 99]; return function (ye) { if (ye.chars && !me(Te, ye.v)) { var xe, pe = ye.chars.length; for (xe = 0; xe < pe; xe += 1) { var de = ye.chars[xe]; de.data && de.data.shapes && (ce(de.data.shapes), de.data.ip = 0, de.data.op = 99999, de.data.st = 0, de.data.sr = 1, de.data.ks = { p: { k: [0, 0], a: 0 }, s: { k: [100, 100], a: 0 }, a: { k: [0, 0], a: 0 }, r: { k: 0, a: 0 }, o: { k: 100, a: 0 } }, ye.chars[xe].t || (de.data.shapes.push({ ty: "no" }), de.data.shapes[0].it.push({ p: { k: [0, 0], a: 0 }, s: { k: [100, 100], a: 0 }, a: { k: [0, 0], a: 0 }, r: { k: 0, a: 0 }, o: { k: 100, a: 0 }, sk: { k: 0, a: 0 }, sa: { k: 0, a: 0 }, ty: "tr" }))) } } } }(), Se = function () { var Te = [5, 7, 15]; function ye(pe) { var de = pe.t.p; typeof de.a == "number" && (de.a = { a: 0, k: de.a }), typeof de.p == "number" && (de.p = { a: 0, k: de.p }), typeof de.r == "number" && (de.r = { a: 0, k: de.r }) } function xe(pe) { var de, _e = pe.length; for (de = 0; de < _e; de += 1)pe[de].ty === 5 && ye(pe[de]) } return function (pe) { if (me(Te, pe.v) && (xe(pe.layers), pe.assets)) { var de, _e = pe.assets.length; for (de = 0; de < _e; de += 1)pe.assets[de].layers && xe(pe.assets[de].layers) } } }(), ke = function () { var Te = [4, 1, 9]; function ye(pe) { var de, _e = pe.length, be, Ae; for (de = 0; de < _e; de += 1)if (pe[de].ty === "gr") ye(pe[de].it); else if (pe[de].ty === "fl" || pe[de].ty === "st") if (pe[de].c.k && pe[de].c.k[0].i) for (Ae = pe[de].c.k.length, be = 0; be < Ae; be += 1)pe[de].c.k[be].s && (pe[de].c.k[be].s[0] /= 255, pe[de].c.k[be].s[1] /= 255, pe[de].c.k[be].s[2] /= 255, pe[de].c.k[be].s[3] /= 255), pe[de].c.k[be].e && (pe[de].c.k[be].e[0] /= 255, pe[de].c.k[be].e[1] /= 255, pe[de].c.k[be].e[2] /= 255, pe[de].c.k[be].e[3] /= 255); else pe[de].c.k[0] /= 255, pe[de].c.k[1] /= 255, pe[de].c.k[2] /= 255, pe[de].c.k[3] /= 255 } function xe(pe) { var de, _e = pe.length; for (de = 0; de < _e; de += 1)pe[de].ty === 4 && ye(pe[de].shapes) } return function (pe) { if (me(Te, pe.v) && (xe(pe.layers), pe.assets)) { var de, _e = pe.assets.length; for (de = 0; de < _e; de += 1)pe.assets[de].layers && xe(pe.assets[de].layers) } } }(), Ce = function () { var Te = [4, 4, 18]; function ye(pe) { var de, _e = pe.length, be, Ae; for (de = _e - 1; de >= 0; de -= 1)if (pe[de].ty === "sh") if (pe[de].ks.k.i) pe[de].ks.k.c = pe[de].closed; else for (Ae = pe[de].ks.k.length, be = 0; be < Ae; be += 1)pe[de].ks.k[be].s && (pe[de].ks.k[be].s[0].c = pe[de].closed), pe[de].ks.k[be].e && (pe[de].ks.k[be].e[0].c = pe[de].closed); else pe[de].ty === "gr" && ye(pe[de].it) } function xe(pe) { var de, _e, be = pe.length, Ae, $e, Fe, Ie; for (_e = 0; _e < be; _e += 1) { if (de = pe[_e], de.hasMask) { var Be = de.masksProperties; for ($e = Be.length, Ae = 0; Ae < $e; Ae += 1)if (Be[Ae].pt.k.i) Be[Ae].pt.k.c = Be[Ae].cl; else for (Ie = Be[Ae].pt.k.length, Fe = 0; Fe < Ie; Fe += 1)Be[Ae].pt.k[Fe].s && (Be[Ae].pt.k[Fe].s[0].c = Be[Ae].cl), Be[Ae].pt.k[Fe].e && (Be[Ae].pt.k[Fe].e[0].c = Be[Ae].cl) } de.ty === 4 && ye(de.shapes) } } return function (pe) { if (me(Te, pe.v) && (xe(pe.layers), pe.assets)) { var de, _e = pe.assets.length; for (de = 0; de < _e; de += 1)pe.assets[de].layers && xe(pe.assets[de].layers) } } }(); function Ee(Te) { Te.__complete || (ke(Te), ge(Te), ve(Te), Se(Te), Ce(Te), fe(Te.layers, Te.assets), ae(Te.chars, Te.assets), Te.__complete = !0) } function De(Te) { Te.t.a.length === 0 && "m" in Te.t.p } var Pe = {}; return Pe.completeData = Ee, Pe.checkColors = ke, Pe.checkChars = ve, Pe.checkPathProperties = Se, Pe.checkShapes = Ce, Pe.completeLayers = fe, Pe } if (K.dataManager || (K.dataManager = ne()), K.assetLoader || (K.assetLoader = function () { function fe(he) { var le = he.getResponseHeader("content-type"); return le && he.responseType === "json" && le.indexOf("json") !== -1 || he.response && _typeof$5(he.response) === "object" ? he.response : he.response && typeof he.response == "string" ? JSON.parse(he.response) : he.responseText ? JSON.parse(he.responseText) : null } function ae(he, le, ce, ue) { var me, ge = new XMLHttpRequest; try { ge.responseType = "json" } catch { } ge.onreadystatechange = function () { if (ge.readyState === 4) if (ge.status === 200) me = fe(ge), ce(me); else try { me = fe(ge), ce(me) } catch (ve) { ue && ue(ve) } }; try { ge.open(["G", "E", "T"].join(""), he, !0) } catch { ge.open(["G", "E", "T"].join(""), le + "/" + he, !0) } ge.send() } return { load: ae } }()), se.data.type === "loadAnimation") K.assetLoader.load(se.data.path, se.data.fullPath, function (fe) { K.dataManager.completeData(fe), K.postMessage({ id: se.data.id, payload: fe, status: "success" }) }, function () { K.postMessage({ id: se.data.id, status: "error" }) }); else if (se.data.type === "complete") { var re = se.data.animation; K.dataManager.completeData(re), K.postMessage({ id: se.data.id, payload: re, status: "success" }) } else se.data.type === "loadData" && K.assetLoader.load(se.data.path, se.data.fullPath, function (fe) { K.postMessage({ id: se.data.id, payload: fe, status: "success" }) }, function () { K.postMessage({ id: se.data.id, status: "error" }) }) }), Y.onmessage = function (ie) { var se = ie.data, ne = se.id, re = F[ne]; F[ne] = null, se.status === "success" ? re.onComplete(se.payload) : re.onError && re.onError() }) } function Q(ie, se) { z += 1; var ne = "processId_" + z; return F[ne] = { onComplete: ie, onError: se }, ne } function ee(ie, se, ne) { Z(); var re = Q(se, ne); Y.postMessage({ type: "loadAnimation", path: ie, fullPath: window.location.origin + window.location.pathname, id: re }) } function te(ie, se, ne) { Z(); var re = Q(se, ne); Y.postMessage({ type: "loadData", path: ie, fullPath: window.location.origin + window.location.pathname, id: re }) } function oe(ie, se, ne) { Z(); var re = Q(se, ne); Y.postMessage({ type: "complete", animation: ie, id: re }) } return { loadAnimation: ee, loadData: te, completeAnimation: oe } }(), ImagePreloader = function () { var z = function () { var ae = createTag("canvas"); ae.width = 1, ae.height = 1; var he = ae.getContext("2d"); return he.fillStyle = "rgba(0,0,0,0)", he.fillRect(0, 0, 1, 1), ae }(); function F() { this.loadedAssets += 1, this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages && this.imagesLoadedCb && this.imagesLoadedCb(null) } function G() { this.loadedFootagesCount += 1, this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages && this.imagesLoadedCb && this.imagesLoadedCb(null) } function Y(ae, he, le) { var ce = ""; if (ae.e) ce = ae.p; else if (he) { var ue = ae.p; ue.indexOf("images/") !== -1 && (ue = ue.split("/")[1]), ce = he + ue } else ce = le, ce += ae.u ? ae.u : "", ce += ae.p; return ce } function X(ae) { var he = 0, le = setInterval(function () { var ce = ae.getBBox(); (ce.width || he > 500) && (this._imageLoaded(), clearInterval(le)), he += 1 }.bind(this), 50) } function K(ae) { var he = Y(ae, this.assetsPath, this.path), le = createNS("image"); isSafari ? this.testImageLoaded(le) : le.addEventListener("load", this._imageLoaded, !1), le.addEventListener("error", function () { ce.img = z, this._imageLoaded() }.bind(this), !1), le.setAttributeNS("http://www.w3.org/1999/xlink", "href", he), this._elementHelper.append ? this._elementHelper.append(le) : this._elementHelper.appendChild(le); var ce = { img: le, assetData: ae }; return ce } function J(ae) { var he = Y(ae, this.assetsPath, this.path), le = createTag("img"); le.crossOrigin = "anonymous", le.addEventListener("load", this._imageLoaded, !1), le.addEventListener("error", function () { ce.img = z, this._imageLoaded() }.bind(this), !1), le.src = he; var ce = { img: le, assetData: ae }; return ce } function Z(ae) { var he = { assetData: ae }, le = Y(ae, this.assetsPath, this.path); return dataManager.loadData(le, function (ce) { he.img = ce, this._footageLoaded() }.bind(this), function () { he.img = {}, this._footageLoaded() }.bind(this)), he } function Q(ae, he) { this.imagesLoadedCb = he; var le, ce = ae.length; for (le = 0; le < ce; le += 1)ae[le].layers || (!ae[le].t || ae[le].t === "seq" ? (this.totalImages += 1, this.images.push(this._createImageData(ae[le]))) : ae[le].t === 3 && (this.totalFootages += 1, this.images.push(this.createFootageData(ae[le])))) } function ee(ae) { this.path = ae || "" } function te(ae) { this.assetsPath = ae || "" } function oe(ae) { for (var he = 0, le = this.images.length; he < le;) { if (this.images[he].assetData === ae) return this.images[he].img; he += 1 } return null } function ie() { this.imagesLoadedCb = null, this.images.length = 0 } function se() { return this.totalImages === this.loadedAssets } function ne() { return this.totalFootages === this.loadedFootagesCount } function re(ae, he) { ae === "svg" ? (this._elementHelper = he, this._createImageData = this.createImageData.bind(this)) : this._createImageData = this.createImgData.bind(this) } function fe() { this._imageLoaded = F.bind(this), this._footageLoaded = G.bind(this), this.testImageLoaded = X.bind(this), this.createFootageData = Z.bind(this), this.assetsPath = "", this.path = "", this.totalImages = 0, this.totalFootages = 0, this.loadedAssets = 0, this.loadedFootagesCount = 0, this.imagesLoadedCb = null, this.images = [] } return fe.prototype = { loadAssets: Q, setAssetsPath: te, setPath: ee, loadedImages: se, loadedFootages: ne, destroy: ie, getAsset: oe, createImgData: J, createImageData: K, imageLoaded: F, footageLoaded: G, setCacheType: re }, fe }(); function BaseEvent() { } BaseEvent.prototype = { triggerEvent: function (F, G) { if (this._cbs[F]) for (var Y = this._cbs[F], X = 0; X < Y.length; X += 1)Y[X](G) }, addEventListener: function (F, G) { return this._cbs[F] || (this._cbs[F] = []), this._cbs[F].push(G), function () { this.removeEventListener(F, G) }.bind(this) }, removeEventListener: function (F, G) { if (!G) this._cbs[F] = null; else if (this._cbs[F]) { for (var Y = 0, X = this._cbs[F].length; Y < X;)this._cbs[F][Y] === G && (this._cbs[F].splice(Y, 1), Y -= 1, X -= 1), Y += 1; this._cbs[F].length || (this._cbs[F] = null) } } }; var markerParser = function () {
            function z(F) {
                for (var G = F.split(`\r
`), Y = {}, X, K = 0, J = 0; J < G.length; J += 1)X = G[J].split(":"), X.length === 2 && (Y[X[0]] = X[1].trim(), K += 1); if (K === 0) throw new Error; return Y
            } return function (F) { for (var G = [], Y = 0; Y < F.length; Y += 1) { var X = F[Y], K = { time: X.tm, duration: X.dr }; try { K.payload = JSON.parse(F[Y].cm) } catch { try { K.payload = z(F[Y].cm) } catch { K.payload = { name: F[Y].cm } } } G.push(K) } return G }
        }(), ProjectInterface = function () { function z(F) { this.compositions.push(F) } return function () { function F(G) { for (var Y = 0, X = this.compositions.length; Y < X;) { if (this.compositions[Y].data && this.compositions[Y].data.nm === G) return this.compositions[Y].prepareFrame && this.compositions[Y].data.xt && this.compositions[Y].prepareFrame(this.currentFrame), this.compositions[Y].compInterface; Y += 1 } return null } return F.compositions = [], F.currentFrame = 0, F.registerComposition = z, F } }(), renderers = {}, registerRenderer = function (F, G) { renderers[F] = G }; function getRenderer(z) { return renderers[z] } function getRegisteredRenderer() { if (renderers.canvas) return "canvas"; for (var z in renderers) if (renderers[z]) return z; return "" } function _typeof$4(z) { "@babel/helpers - typeof"; return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$4 = function (G) { return typeof G } : _typeof$4 = function (G) { return G && typeof Symbol == "function" && G.constructor === Symbol && G !== Symbol.prototype ? "symbol" : typeof G }, _typeof$4(z) } var AnimationItem = function () { this._cbs = [], this.name = "", this.path = "", this.isLoaded = !1, this.currentFrame = 0, this.currentRawFrame = 0, this.firstFrame = 0, this.totalFrames = 0, this.frameRate = 0, this.frameMult = 0, this.playSpeed = 1, this.playDirection = 1, this.playCount = 0, this.animationData = {}, this.assets = [], this.isPaused = !0, this.autoplay = !1, this.loop = !0, this.renderer = null, this.animationID = createElementID(), this.assetsPath = "", this.timeCompleted = 0, this.segmentPos = 0, this.isSubframeEnabled = getSubframeEnabled(), this.segments = [], this._idle = !0, this._completedLoop = !1, this.projectInterface = ProjectInterface(), this.imagePreloader = new ImagePreloader, this.audioController = audioControllerFactory(), this.markers = [], this.configAnimation = this.configAnimation.bind(this), this.onSetupError = this.onSetupError.bind(this), this.onSegmentComplete = this.onSegmentComplete.bind(this), this.drawnFrameEvent = new BMEnterFrameEvent("drawnFrame", 0, 0, 0), this.expressionsPlugin = getExpressionsPlugin() }; extendPrototype([BaseEvent], AnimationItem), AnimationItem.prototype.setParams = function (z) { (z.wrapper || z.container) && (this.wrapper = z.wrapper || z.container); var F = "svg"; z.animType ? F = z.animType : z.renderer && (F = z.renderer); var G = getRenderer(F); this.renderer = new G(this, z.rendererSettings), this.imagePreloader.setCacheType(F, this.renderer.globalData.defs), this.renderer.setProjectInterface(this.projectInterface), this.animType = F, z.loop === "" || z.loop === null || z.loop === void 0 || z.loop === !0 ? this.loop = !0 : z.loop === !1 ? this.loop = !1 : this.loop = parseInt(z.loop, 10), this.autoplay = "autoplay" in z ? z.autoplay : !0, this.name = z.name ? z.name : "", this.autoloadSegments = Object.prototype.hasOwnProperty.call(z, "autoloadSegments") ? z.autoloadSegments : !0, this.assetsPath = z.assetsPath, this.initialSegment = z.initialSegment, z.audioFactory && this.audioController.setAudioFactory(z.audioFactory), z.animationData ? this.setupAnimation(z.animationData) : z.path && (z.path.lastIndexOf("\\") !== -1 ? this.path = z.path.substr(0, z.path.lastIndexOf("\\") + 1) : this.path = z.path.substr(0, z.path.lastIndexOf("/") + 1), this.fileName = z.path.substr(z.path.lastIndexOf("/") + 1), this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf(".json")), dataManager.loadAnimation(z.path, this.configAnimation, this.onSetupError)) }, AnimationItem.prototype.onSetupError = function () { this.trigger("data_failed") }, AnimationItem.prototype.setupAnimation = function (z) { dataManager.completeAnimation(z, this.configAnimation) }, AnimationItem.prototype.setData = function (z, F) { F && _typeof$4(F) !== "object" && (F = JSON.parse(F)); var G = { wrapper: z, animationData: F }, Y = z.attributes; G.path = Y.getNamedItem("data-animation-path") ? Y.getNamedItem("data-animation-path").value : Y.getNamedItem("data-bm-path") ? Y.getNamedItem("data-bm-path").value : Y.getNamedItem("bm-path") ? Y.getNamedItem("bm-path").value : "", G.animType = Y.getNamedItem("data-anim-type") ? Y.getNamedItem("data-anim-type").value : Y.getNamedItem("data-bm-type") ? Y.getNamedItem("data-bm-type").value : Y.getNamedItem("bm-type") ? Y.getNamedItem("bm-type").value : Y.getNamedItem("data-bm-renderer") ? Y.getNamedItem("data-bm-renderer").value : Y.getNamedItem("bm-renderer") ? Y.getNamedItem("bm-renderer").value : getRegisteredRenderer() || "canvas"; var X = Y.getNamedItem("data-anim-loop") ? Y.getNamedItem("data-anim-loop").value : Y.getNamedItem("data-bm-loop") ? Y.getNamedItem("data-bm-loop").value : Y.getNamedItem("bm-loop") ? Y.getNamedItem("bm-loop").value : ""; X === "false" ? G.loop = !1 : X === "true" ? G.loop = !0 : X !== "" && (G.loop = parseInt(X, 10)); var K = Y.getNamedItem("data-anim-autoplay") ? Y.getNamedItem("data-anim-autoplay").value : Y.getNamedItem("data-bm-autoplay") ? Y.getNamedItem("data-bm-autoplay").value : Y.getNamedItem("bm-autoplay") ? Y.getNamedItem("bm-autoplay").value : !0; G.autoplay = K !== "false", G.name = Y.getNamedItem("data-name") ? Y.getNamedItem("data-name").value : Y.getNamedItem("data-bm-name") ? Y.getNamedItem("data-bm-name").value : Y.getNamedItem("bm-name") ? Y.getNamedItem("bm-name").value : ""; var J = Y.getNamedItem("data-anim-prerender") ? Y.getNamedItem("data-anim-prerender").value : Y.getNamedItem("data-bm-prerender") ? Y.getNamedItem("data-bm-prerender").value : Y.getNamedItem("bm-prerender") ? Y.getNamedItem("bm-prerender").value : ""; J === "false" && (G.prerender = !1), G.path ? this.setParams(G) : this.trigger("destroy") }, AnimationItem.prototype.includeLayers = function (z) { z.op > this.animationData.op && (this.animationData.op = z.op, this.totalFrames = Math.floor(z.op - this.animationData.ip)); var F = this.animationData.layers, G, Y = F.length, X = z.layers, K, J = X.length; for (K = 0; K < J; K += 1)for (G = 0; G < Y;) { if (F[G].id === X[K].id) { F[G] = X[K]; break } G += 1 } if ((z.chars || z.fonts) && (this.renderer.globalData.fontManager.addChars(z.chars), this.renderer.globalData.fontManager.addFonts(z.fonts, this.renderer.globalData.defs)), z.assets) for (Y = z.assets.length, G = 0; G < Y; G += 1)this.animationData.assets.push(z.assets[G]); this.animationData.__complete = !1, dataManager.completeAnimation(this.animationData, this.onSegmentComplete) }, AnimationItem.prototype.onSegmentComplete = function (z) { this.animationData = z; var F = getExpressionsPlugin(); F && F.initExpressions(this), this.loadNextSegment() }, AnimationItem.prototype.loadNextSegment = function () { var z = this.animationData.segments; if (!z || z.length === 0 || !this.autoloadSegments) { this.trigger("data_ready"), this.timeCompleted = this.totalFrames; return } var F = z.shift(); this.timeCompleted = F.time * this.frameRate; var G = this.path + this.fileName + "_" + this.segmentPos + ".json"; this.segmentPos += 1, dataManager.loadData(G, this.includeLayers.bind(this), function () { this.trigger("data_failed") }.bind(this)) }, AnimationItem.prototype.loadSegments = function () { var z = this.animationData.segments; z || (this.timeCompleted = this.totalFrames), this.loadNextSegment() }, AnimationItem.prototype.imagesLoaded = function () { this.trigger("loaded_images"), this.checkLoaded() }, AnimationItem.prototype.preloadImages = function () { this.imagePreloader.setAssetsPath(this.assetsPath), this.imagePreloader.setPath(this.path), this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this)) }, AnimationItem.prototype.configAnimation = function (z) { if (this.renderer) try { this.animationData = z, this.initialSegment ? (this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]), this.firstFrame = Math.round(this.initialSegment[0])) : (this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip), this.firstFrame = Math.round(this.animationData.ip)), this.renderer.configAnimation(z), z.assets || (z.assets = []), this.assets = this.animationData.assets, this.frameRate = this.animationData.fr, this.frameMult = this.animationData.fr / 1e3, this.renderer.searchExtraCompositions(z.assets), this.markers = markerParser(z.markers || []), this.trigger("config_ready"), this.preloadImages(), this.loadSegments(), this.updaFrameModifier(), this.waitForFontsLoaded(), this.isPaused && this.audioController.pause() } catch (F) { this.triggerConfigError(F) } }, AnimationItem.prototype.waitForFontsLoaded = function () { this.renderer && (this.renderer.globalData.fontManager.isLoaded ? this.checkLoaded() : setTimeout(this.waitForFontsLoaded.bind(this), 20)) }, AnimationItem.prototype.checkLoaded = function () { if (!this.isLoaded && this.renderer.globalData.fontManager.isLoaded && (this.imagePreloader.loadedImages() || this.renderer.rendererType !== "canvas") && this.imagePreloader.loadedFootages()) { this.isLoaded = !0; var z = getExpressionsPlugin(); z && z.initExpressions(this), this.renderer.initItems(), setTimeout(function () { this.trigger("DOMLoaded") }.bind(this), 0), this.gotoFrame(), this.autoplay && this.play() } }, AnimationItem.prototype.resize = function (z, F) { var G = typeof z == "number" ? z : void 0, Y = typeof F == "number" ? F : void 0; this.renderer.updateContainerSize(G, Y) }, AnimationItem.prototype.setSubframe = function (z) { this.isSubframeEnabled = !!z }, AnimationItem.prototype.gotoFrame = function () { this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame, this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted && (this.currentFrame = this.timeCompleted), this.trigger("enterFrame"), this.renderFrame(), this.trigger("drawnFrame") }, AnimationItem.prototype.renderFrame = function () { if (!(this.isLoaded === !1 || !this.renderer)) try { this.expressionsPlugin && this.expressionsPlugin.resetFrame(), this.renderer.renderFrame(this.currentFrame + this.firstFrame) } catch (z) { this.triggerRenderFrameError(z) } }, AnimationItem.prototype.play = function (z) { z && this.name !== z || this.isPaused === !0 && (this.isPaused = !1, this.trigger("_play"), this.audioController.resume(), this._idle && (this._idle = !1, this.trigger("_active"))) }, AnimationItem.prototype.pause = function (z) { z && this.name !== z || this.isPaused === !1 && (this.isPaused = !0, this.trigger("_pause"), this._idle = !0, this.trigger("_idle"), this.audioController.pause()) }, AnimationItem.prototype.togglePause = function (z) { z && this.name !== z || (this.isPaused === !0 ? this.play() : this.pause()) }, AnimationItem.prototype.stop = function (z) { z && this.name !== z || (this.pause(), this.playCount = 0, this._completedLoop = !1, this.setCurrentRawFrameValue(0)) }, AnimationItem.prototype.getMarkerData = function (z) { for (var F, G = 0; G < this.markers.length; G += 1)if (F = this.markers[G], F.payload && F.payload.name === z) return F; return null }, AnimationItem.prototype.goToAndStop = function (z, F, G) { if (!(G && this.name !== G)) { var Y = Number(z); if (isNaN(Y)) { var X = this.getMarkerData(z); X && this.goToAndStop(X.time, !0) } else F ? this.setCurrentRawFrameValue(z) : this.setCurrentRawFrameValue(z * this.frameModifier); this.pause() } }, AnimationItem.prototype.goToAndPlay = function (z, F, G) { if (!(G && this.name !== G)) { var Y = Number(z); if (isNaN(Y)) { var X = this.getMarkerData(z); X && (X.duration ? this.playSegments([X.time, X.time + X.duration], !0) : this.goToAndStop(X.time, !0)) } else this.goToAndStop(Y, F, G); this.play() } }, AnimationItem.prototype.advanceTime = function (z) { if (!(this.isPaused === !0 || this.isLoaded === !1)) { var F = this.currentRawFrame + z * this.frameModifier, G = !1; F >= this.totalFrames - 1 && this.frameModifier > 0 ? !this.loop || this.playCount === this.loop ? this.checkSegments(F > this.totalFrames ? F % this.totalFrames : 0) || (G = !0, F = this.totalFrames - 1) : F >= this.totalFrames ? (this.playCount += 1, this.checkSegments(F % this.totalFrames) || (this.setCurrentRawFrameValue(F % this.totalFrames), this._completedLoop = !0, this.trigger("loopComplete"))) : this.setCurrentRawFrameValue(F) : F < 0 ? this.checkSegments(F % this.totalFrames) || (this.loop && !(this.playCount-- <= 0 && this.loop !== !0) ? (this.setCurrentRawFrameValue(this.totalFrames + F % this.totalFrames), this._completedLoop ? this.trigger("loopComplete") : this._completedLoop = !0) : (G = !0, F = 0)) : this.setCurrentRawFrameValue(F), G && (this.setCurrentRawFrameValue(F), this.pause(), this.trigger("complete")) } }, AnimationItem.prototype.adjustSegment = function (z, F) { this.playCount = 0, z[1] < z[0] ? (this.frameModifier > 0 && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(-1)), this.totalFrames = z[0] - z[1], this.timeCompleted = this.totalFrames, this.firstFrame = z[1], this.setCurrentRawFrameValue(this.totalFrames - .001 - F)) : z[1] > z[0] && (this.frameModifier < 0 && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(1)), this.totalFrames = z[1] - z[0], this.timeCompleted = this.totalFrames, this.firstFrame = z[0], this.setCurrentRawFrameValue(.001 + F)), this.trigger("segmentStart") }, AnimationItem.prototype.setSegment = function (z, F) { var G = -1; this.isPaused && (this.currentRawFrame + this.firstFrame < z ? G = z : this.currentRawFrame + this.firstFrame > F && (G = F - z)), this.firstFrame = z, this.totalFrames = F - z, this.timeCompleted = this.totalFrames, G !== -1 && this.goToAndStop(G, !0) }, AnimationItem.prototype.playSegments = function (z, F) { if (F && (this.segments.length = 0), _typeof$4(z[0]) === "object") { var G, Y = z.length; for (G = 0; G < Y; G += 1)this.segments.push(z[G]) } else this.segments.push(z); this.segments.length && F && this.adjustSegment(this.segments.shift(), 0), this.isPaused && this.play() }, AnimationItem.prototype.resetSegments = function (z) { this.segments.length = 0, this.segments.push([this.animationData.ip, this.animationData.op]), z && this.checkSegments(0) }, AnimationItem.prototype.checkSegments = function (z) { return this.segments.length ? (this.adjustSegment(this.segments.shift(), z), !0) : !1 }, AnimationItem.prototype.destroy = function (z) { z && this.name !== z || !this.renderer || (this.renderer.destroy(), this.imagePreloader.destroy(), this.trigger("destroy"), this._cbs = null, this.onEnterFrame = null, this.onLoopComplete = null, this.onComplete = null, this.onSegmentStart = null, this.onDestroy = null, this.renderer = null, this.expressionsPlugin = null, this.imagePreloader = null, this.projectInterface = null) }, AnimationItem.prototype.setCurrentRawFrameValue = function (z) { this.currentRawFrame = z, this.gotoFrame() }, AnimationItem.prototype.setSpeed = function (z) { this.playSpeed = z, this.updaFrameModifier() }, AnimationItem.prototype.setDirection = function (z) { this.playDirection = z < 0 ? -1 : 1, this.updaFrameModifier() }, AnimationItem.prototype.setLoop = function (z) { this.loop = z }, AnimationItem.prototype.setVolume = function (z, F) { F && this.name !== F || this.audioController.setVolume(z) }, AnimationItem.prototype.getVolume = function () { return this.audioController.getVolume() }, AnimationItem.prototype.mute = function (z) { z && this.name !== z || this.audioController.mute() }, AnimationItem.prototype.unmute = function (z) { z && this.name !== z || this.audioController.unmute() }, AnimationItem.prototype.updaFrameModifier = function () { this.frameModifier = this.frameMult * this.playSpeed * this.playDirection, this.audioController.setRate(this.playSpeed * this.playDirection) }, AnimationItem.prototype.getPath = function () { return this.path }, AnimationItem.prototype.getAssetsPath = function (z) { var F = ""; if (z.e) F = z.p; else if (this.assetsPath) { var G = z.p; G.indexOf("images/") !== -1 && (G = G.split("/")[1]), F = this.assetsPath + G } else F = this.path, F += z.u ? z.u : "", F += z.p; return F }, AnimationItem.prototype.getAssetData = function (z) { for (var F = 0, G = this.assets.length; F < G;) { if (z === this.assets[F].id) return this.assets[F]; F += 1 } return null }, AnimationItem.prototype.hide = function () { this.renderer.hide() }, AnimationItem.prototype.show = function () { this.renderer.show() }, AnimationItem.prototype.getDuration = function (z) { return z ? this.totalFrames : this.totalFrames / this.frameRate }, AnimationItem.prototype.updateDocumentData = function (z, F, G) { try { var Y = this.renderer.getElementByPath(z); Y.updateDocumentData(F, G) } catch { } }, AnimationItem.prototype.trigger = function (z) { if (this._cbs && this._cbs[z]) switch (z) { case "enterFrame": this.triggerEvent(z, new BMEnterFrameEvent(z, this.currentFrame, this.totalFrames, this.frameModifier)); break; case "drawnFrame": this.drawnFrameEvent.currentTime = this.currentFrame, this.drawnFrameEvent.totalTime = this.totalFrames, this.drawnFrameEvent.direction = this.frameModifier, this.triggerEvent(z, this.drawnFrameEvent); break; case "loopComplete": this.triggerEvent(z, new BMCompleteLoopEvent(z, this.loop, this.playCount, this.frameMult)); break; case "complete": this.triggerEvent(z, new BMCompleteEvent(z, this.frameMult)); break; case "segmentStart": this.triggerEvent(z, new BMSegmentStartEvent(z, this.firstFrame, this.totalFrames)); break; case "destroy": this.triggerEvent(z, new BMDestroyEvent(z, this)); break; default: this.triggerEvent(z) }z === "enterFrame" && this.onEnterFrame && this.onEnterFrame.call(this, new BMEnterFrameEvent(z, this.currentFrame, this.totalFrames, this.frameMult)), z === "loopComplete" && this.onLoopComplete && this.onLoopComplete.call(this, new BMCompleteLoopEvent(z, this.loop, this.playCount, this.frameMult)), z === "complete" && this.onComplete && this.onComplete.call(this, new BMCompleteEvent(z, this.frameMult)), z === "segmentStart" && this.onSegmentStart && this.onSegmentStart.call(this, new BMSegmentStartEvent(z, this.firstFrame, this.totalFrames)), z === "destroy" && this.onDestroy && this.onDestroy.call(this, new BMDestroyEvent(z, this)) }, AnimationItem.prototype.triggerRenderFrameError = function (z) { var F = new BMRenderFrameErrorEvent(z, this.currentFrame); this.triggerEvent("error", F), this.onError && this.onError.call(this, F) }, AnimationItem.prototype.triggerConfigError = function (z) { var F = new BMConfigErrorEvent(z, this.currentFrame); this.triggerEvent("error", F), this.onError && this.onError.call(this, F) }; var animationManager = function () { var z = {}, F = [], G = 0, Y = 0, X = 0, K = !0, J = !1; function Z(ye) { for (var xe = 0, pe = ye.target; xe < Y;)F[xe].animation === pe && (F.splice(xe, 1), xe -= 1, Y -= 1, pe.isPaused || oe()), xe += 1 } function Q(ye, xe) { if (!ye) return null; for (var pe = 0; pe < Y;) { if (F[pe].elem === ye && F[pe].elem !== null) return F[pe].animation; pe += 1 } var de = new AnimationItem; return ie(de, ye), de.setData(ye, xe), de } function ee() { var ye, xe = F.length, pe = []; for (ye = 0; ye < xe; ye += 1)pe.push(F[ye].animation); return pe } function te() { X += 1, ke() } function oe() { X -= 1 } function ie(ye, xe) { ye.addEventListener("destroy", Z), ye.addEventListener("_active", te), ye.addEventListener("_idle", oe), F.push({ elem: xe, animation: ye }), Y += 1 } function se(ye) { var xe = new AnimationItem; return ie(xe, null), xe.setParams(ye), xe } function ne(ye, xe) { var pe; for (pe = 0; pe < Y; pe += 1)F[pe].animation.setSpeed(ye, xe) } function re(ye, xe) { var pe; for (pe = 0; pe < Y; pe += 1)F[pe].animation.setDirection(ye, xe) } function fe(ye) { var xe; for (xe = 0; xe < Y; xe += 1)F[xe].animation.play(ye) } function ae(ye) { var xe = ye - G, pe; for (pe = 0; pe < Y; pe += 1)F[pe].animation.advanceTime(xe); G = ye, X && !J ? window.requestAnimationFrame(ae) : K = !0 } function he(ye) { G = ye, window.requestAnimationFrame(ae) } function le(ye) { var xe; for (xe = 0; xe < Y; xe += 1)F[xe].animation.pause(ye) } function ce(ye, xe, pe) { var de; for (de = 0; de < Y; de += 1)F[de].animation.goToAndStop(ye, xe, pe) } function ue(ye) { var xe; for (xe = 0; xe < Y; xe += 1)F[xe].animation.stop(ye) } function me(ye) { var xe; for (xe = 0; xe < Y; xe += 1)F[xe].animation.togglePause(ye) } function ge(ye) { var xe; for (xe = Y - 1; xe >= 0; xe -= 1)F[xe].animation.destroy(ye) } function ve(ye, xe, pe) { var de = [].concat([].slice.call(document.getElementsByClassName("lottie")), [].slice.call(document.getElementsByClassName("bodymovin"))), _e, be = de.length; for (_e = 0; _e < be; _e += 1)pe && de[_e].setAttribute("data-bm-type", pe), Q(de[_e], ye); if (xe && be === 0) { pe || (pe = "svg"); var Ae = document.getElementsByTagName("body")[0]; Ae.innerText = ""; var $e = createTag("div"); $e.style.width = "100%", $e.style.height = "100%", $e.setAttribute("data-bm-type", pe), Ae.appendChild($e), Q($e, ye) } } function Se() { var ye; for (ye = 0; ye < Y; ye += 1)F[ye].animation.resize() } function ke() { !J && X && K && (window.requestAnimationFrame(he), K = !1) } function Ce() { J = !0 } function Ee() { J = !1, ke() } function De(ye, xe) { var pe; for (pe = 0; pe < Y; pe += 1)F[pe].animation.setVolume(ye, xe) } function Pe(ye) { var xe; for (xe = 0; xe < Y; xe += 1)F[xe].animation.mute(ye) } function Te(ye) { var xe; for (xe = 0; xe < Y; xe += 1)F[xe].animation.unmute(ye) } return z.registerAnimation = Q, z.loadAnimation = se, z.setSpeed = ne, z.setDirection = re, z.play = fe, z.pause = le, z.stop = ue, z.togglePause = me, z.searchAnimations = ve, z.resize = Se, z.goToAndStop = ce, z.destroy = ge, z.freeze = Ce, z.unfreeze = Ee, z.setVolume = De, z.mute = Pe, z.unmute = Te, z.getRegisteredAnimations = ee, z }(), BezierFactory = function () { var z = {}; z.getBezierEasing = G; var F = {}; function G(he, le, ce, ue, me) { var ge = me || ("bez_" + he + "_" + le + "_" + ce + "_" + ue).replace(/\./g, "p"); if (F[ge]) return F[ge]; var ve = new ae([he, le, ce, ue]); return F[ge] = ve, ve } var Y = 4, X = .001, K = 1e-7, J = 10, Z = 11, Q = 1 / (Z - 1), ee = typeof Float32Array == "function"; function te(he, le) { return 1 - 3 * le + 3 * he } function oe(he, le) { return 3 * le - 6 * he } function ie(he) { return 3 * he } function se(he, le, ce) { return ((te(le, ce) * he + oe(le, ce)) * he + ie(le)) * he } function ne(he, le, ce) { return 3 * te(le, ce) * he * he + 2 * oe(le, ce) * he + ie(le) } function re(he, le, ce, ue, me) { var ge, ve, Se = 0; do ve = le + (ce - le) / 2, ge = se(ve, ue, me) - he, ge > 0 ? ce = ve : le = ve; while (Math.abs(ge) > K && ++Se < J); return ve } function fe(he, le, ce, ue) { for (var me = 0; me < Y; ++me) { var ge = ne(le, ce, ue); if (ge === 0) return le; var ve = se(le, ce, ue) - he; le -= ve / ge } return le } function ae(he) { this._p = he, this._mSampleValues = ee ? new Float32Array(Z) : new Array(Z), this._precomputed = !1, this.get = this.get.bind(this) } return ae.prototype = { get: function (le) { var ce = this._p[0], ue = this._p[1], me = this._p[2], ge = this._p[3]; return this._precomputed || this._precompute(), ce === ue && me === ge ? le : le === 0 ? 0 : le === 1 ? 1 : se(this._getTForX(le), ue, ge) }, _precompute: function () { var le = this._p[0], ce = this._p[1], ue = this._p[2], me = this._p[3]; this._precomputed = !0, (le !== ce || ue !== me) && this._calcSampleValues() }, _calcSampleValues: function () { for (var le = this._p[0], ce = this._p[2], ue = 0; ue < Z; ++ue)this._mSampleValues[ue] = se(ue * Q, le, ce) }, _getTForX: function (le) { for (var ce = this._p[0], ue = this._p[2], me = this._mSampleValues, ge = 0, ve = 1, Se = Z - 1; ve !== Se && me[ve] <= le; ++ve)ge += Q; --ve; var ke = (le - me[ve]) / (me[ve + 1] - me[ve]), Ce = ge + ke * Q, Ee = ne(Ce, ce, ue); return Ee >= X ? fe(le, Ce, ce, ue) : Ee === 0 ? Ce : re(le, ge, ge + Q, ce, ue) } }, z }(), pooling = function () { function z(F) { return F.concat(createSizedArray(F.length)) } return { double: z } }(), poolFactory = function () { return function (z, F, G) { var Y = 0, X = z, K = createSizedArray(X), J = { newElement: Z, release: Q }; function Z() { var ee; return Y ? (Y -= 1, ee = K[Y]) : ee = F(), ee } function Q(ee) { Y === X && (K = pooling.double(K), X *= 2), G && G(ee), K[Y] = ee, Y += 1 } return J } }(), bezierLengthPool = function () { function z() { return { addedLength: 0, percents: createTypedArray("float32", getDefaultCurveSegments()), lengths: createTypedArray("float32", getDefaultCurveSegments()) } } return poolFactory(8, z) }(), segmentsLengthPool = function () { function z() { return { lengths: [], totalLength: 0 } } function F(G) { var Y, X = G.lengths.length; for (Y = 0; Y < X; Y += 1)bezierLengthPool.release(G.lengths[Y]); G.lengths.length = 0 } return poolFactory(8, z, F) }(); function bezFunction() { var z = Math; function F(ie, se, ne, re, fe, ae) { var he = ie * re + se * fe + ne * ae - fe * re - ae * ie - ne * se; return he > -.001 && he < .001 } function G(ie, se, ne, re, fe, ae, he, le, ce) { if (ne === 0 && ae === 0 && ce === 0) return F(ie, se, re, fe, he, le); var ue = z.sqrt(z.pow(re - ie, 2) + z.pow(fe - se, 2) + z.pow(ae - ne, 2)), me = z.sqrt(z.pow(he - ie, 2) + z.pow(le - se, 2) + z.pow(ce - ne, 2)), ge = z.sqrt(z.pow(he - re, 2) + z.pow(le - fe, 2) + z.pow(ce - ae, 2)), ve; return ue > me ? ue > ge ? ve = ue - me - ge : ve = ge - me - ue : ge > me ? ve = ge - me - ue : ve = me - ue - ge, ve > -1e-4 && ve < 1e-4 } var Y = function () { return function (ie, se, ne, re) { var fe = getDefaultCurveSegments(), ae, he, le, ce, ue, me = 0, ge, ve = [], Se = [], ke = bezierLengthPool.newElement(); for (le = ne.length, ae = 0; ae < fe; ae += 1) { for (ue = ae / (fe - 1), ge = 0, he = 0; he < le; he += 1)ce = bmPow(1 - ue, 3) * ie[he] + 3 * bmPow(1 - ue, 2) * ue * ne[he] + 3 * (1 - ue) * bmPow(ue, 2) * re[he] + bmPow(ue, 3) * se[he], ve[he] = ce, Se[he] !== null && (ge += bmPow(ve[he] - Se[he], 2)), Se[he] = ve[he]; ge && (ge = bmSqrt(ge), me += ge), ke.percents[ae] = ue, ke.lengths[ae] = me } return ke.addedLength = me, ke } }(); function X(ie) { var se = segmentsLengthPool.newElement(), ne = ie.c, re = ie.v, fe = ie.o, ae = ie.i, he, le = ie._length, ce = se.lengths, ue = 0; for (he = 0; he < le - 1; he += 1)ce[he] = Y(re[he], re[he + 1], fe[he], ae[he + 1]), ue += ce[he].addedLength; return ne && le && (ce[he] = Y(re[he], re[0], fe[he], ae[0]), ue += ce[he].addedLength), se.totalLength = ue, se } function K(ie) { this.segmentLength = 0, this.points = new Array(ie) } function J(ie, se) { this.partialLength = ie, this.point = se } var Z = function () { var ie = {}; return function (se, ne, re, fe) { var ae = (se[0] + "_" + se[1] + "_" + ne[0] + "_" + ne[1] + "_" + re[0] + "_" + re[1] + "_" + fe[0] + "_" + fe[1]).replace(/\./g, "p"); if (!ie[ae]) { var he = getDefaultCurveSegments(), le, ce, ue, me, ge, ve = 0, Se, ke, Ce = null; se.length === 2 && (se[0] !== ne[0] || se[1] !== ne[1]) && F(se[0], se[1], ne[0], ne[1], se[0] + re[0], se[1] + re[1]) && F(se[0], se[1], ne[0], ne[1], ne[0] + fe[0], ne[1] + fe[1]) && (he = 2); var Ee = new K(he); for (ue = re.length, le = 0; le < he; le += 1) { for (ke = createSizedArray(ue), ge = le / (he - 1), Se = 0, ce = 0; ce < ue; ce += 1)me = bmPow(1 - ge, 3) * se[ce] + 3 * bmPow(1 - ge, 2) * ge * (se[ce] + re[ce]) + 3 * (1 - ge) * bmPow(ge, 2) * (ne[ce] + fe[ce]) + bmPow(ge, 3) * ne[ce], ke[ce] = me, Ce !== null && (Se += bmPow(ke[ce] - Ce[ce], 2)); Se = bmSqrt(Se), ve += Se, Ee.points[le] = new J(Se, ke), Ce = ke } Ee.segmentLength = ve, ie[ae] = Ee } return ie[ae] } }(); function Q(ie, se) { var ne = se.percents, re = se.lengths, fe = ne.length, ae = bmFloor((fe - 1) * ie), he = ie * se.addedLength, le = 0; if (ae === fe - 1 || ae === 0 || he === re[ae]) return ne[ae]; for (var ce = re[ae] > he ? -1 : 1, ue = !0; ue;)if (re[ae] <= he && re[ae + 1] > he ? (le = (he - re[ae]) / (re[ae + 1] - re[ae]), ue = !1) : ae += ce, ae < 0 || ae >= fe - 1) { if (ae === fe - 1) return ne[ae]; ue = !1 } return ne[ae] + (ne[ae + 1] - ne[ae]) * le } function ee(ie, se, ne, re, fe, ae) { var he = Q(fe, ae), le = 1 - he, ce = z.round((le * le * le * ie[0] + (he * le * le + le * he * le + le * le * he) * ne[0] + (he * he * le + le * he * he + he * le * he) * re[0] + he * he * he * se[0]) * 1e3) / 1e3, ue = z.round((le * le * le * ie[1] + (he * le * le + le * he * le + le * le * he) * ne[1] + (he * he * le + le * he * he + he * le * he) * re[1] + he * he * he * se[1]) * 1e3) / 1e3; return [ce, ue] } var te = createTypedArray("float32", 8); function oe(ie, se, ne, re, fe, ae, he) { fe < 0 ? fe = 0 : fe > 1 && (fe = 1); var le = Q(fe, he); ae = ae > 1 ? 1 : ae; var ce = Q(ae, he), ue, me = ie.length, ge = 1 - le, ve = 1 - ce, Se = ge * ge * ge, ke = le * ge * ge * 3, Ce = le * le * ge * 3, Ee = le * le * le, De = ge * ge * ve, Pe = le * ge * ve + ge * le * ve + ge * ge * ce, Te = le * le * ve + ge * le * ce + le * ge * ce, ye = le * le * ce, xe = ge * ve * ve, pe = le * ve * ve + ge * ce * ve + ge * ve * ce, de = le * ce * ve + ge * ce * ce + le * ve * ce, _e = le * ce * ce, be = ve * ve * ve, Ae = ce * ve * ve + ve * ce * ve + ve * ve * ce, $e = ce * ce * ve + ve * ce * ce + ce * ve * ce, Fe = ce * ce * ce; for (ue = 0; ue < me; ue += 1)te[ue * 4] = z.round((Se * ie[ue] + ke * ne[ue] + Ce * re[ue] + Ee * se[ue]) * 1e3) / 1e3, te[ue * 4 + 1] = z.round((De * ie[ue] + Pe * ne[ue] + Te * re[ue] + ye * se[ue]) * 1e3) / 1e3, te[ue * 4 + 2] = z.round((xe * ie[ue] + pe * ne[ue] + de * re[ue] + _e * se[ue]) * 1e3) / 1e3, te[ue * 4 + 3] = z.round((be * ie[ue] + Ae * ne[ue] + $e * re[ue] + Fe * se[ue]) * 1e3) / 1e3; return te } return { getSegmentsLength: X, getNewSegment: oe, getPointInSegment: ee, buildBezierData: Z, pointOnLine2D: F, pointOnLine3D: G } } var bez = bezFunction(), initFrame = initialDefaultFrame, mathAbs = Math.abs; function interpolateValue(z, F) { var G = this.offsetTime, Y; this.propType === "multidimensional" && (Y = createTypedArray("float32", this.pv.length)); for (var X = F.lastIndex, K = X, J = this.keyframes.length - 1, Z = !0, Q, ee, te; Z;) { if (Q = this.keyframes[K], ee = this.keyframes[K + 1], K === J - 1 && z >= ee.t - G) { Q.h && (Q = ee), X = 0; break } if (ee.t - G > z) { X = K; break } K < J - 1 ? K += 1 : (X = 0, Z = !1) } te = this.keyframesMetadata[K] || {}; var oe, ie, se, ne, re, fe, ae = ee.t - G, he = Q.t - G, le; if (Q.to) { te.bezierData || (te.bezierData = bez.buildBezierData(Q.s, ee.s || Q.e, Q.to, Q.ti)); var ce = te.bezierData; if (z >= ae || z < he) { var ue = z >= ae ? ce.points.length - 1 : 0; for (ie = ce.points[ue].point.length, oe = 0; oe < ie; oe += 1)Y[oe] = ce.points[ue].point[oe] } else { te.__fnct ? fe = te.__fnct : (fe = BezierFactory.getBezierEasing(Q.o.x, Q.o.y, Q.i.x, Q.i.y, Q.n).get, te.__fnct = fe), se = fe((z - he) / (ae - he)); var me = ce.segmentLength * se, ge, ve = F.lastFrame < z && F._lastKeyframeIndex === K ? F._lastAddedLength : 0; for (re = F.lastFrame < z && F._lastKeyframeIndex === K ? F._lastPoint : 0, Z = !0, ne = ce.points.length; Z;) { if (ve += ce.points[re].partialLength, me === 0 || se === 0 || re === ce.points.length - 1) { for (ie = ce.points[re].point.length, oe = 0; oe < ie; oe += 1)Y[oe] = ce.points[re].point[oe]; break } else if (me >= ve && me < ve + ce.points[re + 1].partialLength) { for (ge = (me - ve) / ce.points[re + 1].partialLength, ie = ce.points[re].point.length, oe = 0; oe < ie; oe += 1)Y[oe] = ce.points[re].point[oe] + (ce.points[re + 1].point[oe] - ce.points[re].point[oe]) * ge; break } re < ne - 1 ? re += 1 : Z = !1 } F._lastPoint = re, F._lastAddedLength = ve - ce.points[re].partialLength, F._lastKeyframeIndex = K } } else { var Se, ke, Ce, Ee, De; if (J = Q.s.length, le = ee.s || Q.e, this.sh && Q.h !== 1) if (z >= ae) Y[0] = le[0], Y[1] = le[1], Y[2] = le[2]; else if (z <= he) Y[0] = Q.s[0], Y[1] = Q.s[1], Y[2] = Q.s[2]; else { var Pe = createQuaternion(Q.s), Te = createQuaternion(le), ye = (z - he) / (ae - he); quaternionToEuler(Y, slerp(Pe, Te, ye)) } else for (K = 0; K < J; K += 1)Q.h !== 1 && (z >= ae ? se = 1 : z < he ? se = 0 : (Q.o.x.constructor === Array ? (te.__fnct || (te.__fnct = []), te.__fnct[K] ? fe = te.__fnct[K] : (Se = Q.o.x[K] === void 0 ? Q.o.x[0] : Q.o.x[K], ke = Q.o.y[K] === void 0 ? Q.o.y[0] : Q.o.y[K], Ce = Q.i.x[K] === void 0 ? Q.i.x[0] : Q.i.x[K], Ee = Q.i.y[K] === void 0 ? Q.i.y[0] : Q.i.y[K], fe = BezierFactory.getBezierEasing(Se, ke, Ce, Ee).get, te.__fnct[K] = fe)) : te.__fnct ? fe = te.__fnct : (Se = Q.o.x, ke = Q.o.y, Ce = Q.i.x, Ee = Q.i.y, fe = BezierFactory.getBezierEasing(Se, ke, Ce, Ee).get, Q.keyframeMetadata = fe), se = fe((z - he) / (ae - he)))), le = ee.s || Q.e, De = Q.h === 1 ? Q.s[K] : Q.s[K] + (le[K] - Q.s[K]) * se, this.propType === "multidimensional" ? Y[K] = De : Y = De } return F.lastIndex = X, Y } function slerp(z, F, G) { var Y = [], X = z[0], K = z[1], J = z[2], Z = z[3], Q = F[0], ee = F[1], te = F[2], oe = F[3], ie, se, ne, re, fe; return se = X * Q + K * ee + J * te + Z * oe, se < 0 && (se = -se, Q = -Q, ee = -ee, te = -te, oe = -oe), 1 - se > 1e-6 ? (ie = Math.acos(se), ne = Math.sin(ie), re = Math.sin((1 - G) * ie) / ne, fe = Math.sin(G * ie) / ne) : (re = 1 - G, fe = G), Y[0] = re * X + fe * Q, Y[1] = re * K + fe * ee, Y[2] = re * J + fe * te, Y[3] = re * Z + fe * oe, Y } function quaternionToEuler(z, F) { var G = F[0], Y = F[1], X = F[2], K = F[3], J = Math.atan2(2 * Y * K - 2 * G * X, 1 - 2 * Y * Y - 2 * X * X), Z = Math.asin(2 * G * Y + 2 * X * K), Q = Math.atan2(2 * G * K - 2 * Y * X, 1 - 2 * G * G - 2 * X * X); z[0] = J / degToRads, z[1] = Z / degToRads, z[2] = Q / degToRads } function createQuaternion(z) { var F = z[0] * degToRads, G = z[1] * degToRads, Y = z[2] * degToRads, X = Math.cos(F / 2), K = Math.cos(G / 2), J = Math.cos(Y / 2), Z = Math.sin(F / 2), Q = Math.sin(G / 2), ee = Math.sin(Y / 2), te = X * K * J - Z * Q * ee, oe = Z * Q * J + X * K * ee, ie = Z * K * J + X * Q * ee, se = X * Q * J - Z * K * ee; return [oe, ie, se, te] } function getValueAtCurrentTime() { var z = this.comp.renderedFrame - this.offsetTime, F = this.keyframes[0].t - this.offsetTime, G = this.keyframes[this.keyframes.length - 1].t - this.offsetTime; if (!(z === this._caching.lastFrame || this._caching.lastFrame !== initFrame && (this._caching.lastFrame >= G && z >= G || this._caching.lastFrame < F && z < F))) { this._caching.lastFrame >= z && (this._caching._lastKeyframeIndex = -1, this._caching.lastIndex = 0); var Y = this.interpolateValue(z, this._caching); this.pv = Y } return this._caching.lastFrame = z, this.pv } function setVValue(z) { var F; if (this.propType === "unidimensional") F = z * this.mult, mathAbs(this.v - F) > 1e-5 && (this.v = F, this._mdf = !0); else for (var G = 0, Y = this.v.length; G < Y;)F = z[G] * this.mult, mathAbs(this.v[G] - F) > 1e-5 && (this.v[G] = F, this._mdf = !0), G += 1 } function processEffectsSequence() { if (!(this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length)) { if (this.lock) { this.setVValue(this.pv); return } this.lock = !0, this._mdf = this._isFirstFrame; var z, F = this.effectsSequence.length, G = this.kf ? this.pv : this.data.k; for (z = 0; z < F; z += 1)G = this.effectsSequence[z](G); this.setVValue(G), this._isFirstFrame = !1, this.lock = !1, this.frameId = this.elem.globalData.frameId } } function addEffect(z) { this.effectsSequence.push(z), this.container.addDynamicProperty(this) } function ValueProperty(z, F, G, Y) { this.propType = "unidimensional", this.mult = G || 1, this.data = F, this.v = G ? F.k * G : F.k, this.pv = F.k, this._mdf = !1, this.elem = z, this.container = Y, this.comp = z.comp, this.k = !1, this.kf = !1, this.vel = 0, this.effectsSequence = [], this._isFirstFrame = !0, this.getValue = processEffectsSequence, this.setVValue = setVValue, this.addEffect = addEffect } function MultiDimensionalProperty(z, F, G, Y) { this.propType = "multidimensional", this.mult = G || 1, this.data = F, this._mdf = !1, this.elem = z, this.container = Y, this.comp = z.comp, this.k = !1, this.kf = !1, this.frameId = -1; var X, K = F.k.length; for (this.v = createTypedArray("float32", K), this.pv = createTypedArray("float32", K), this.vel = createTypedArray("float32", K), X = 0; X < K; X += 1)this.v[X] = F.k[X] * this.mult, this.pv[X] = F.k[X]; this._isFirstFrame = !0, this.effectsSequence = [], this.getValue = processEffectsSequence, this.setVValue = setVValue, this.addEffect = addEffect } function KeyframedValueProperty(z, F, G, Y) { this.propType = "unidimensional", this.keyframes = F.k, this.keyframesMetadata = [], this.offsetTime = z.data.st, this.frameId = -1, this._caching = { lastFrame: initFrame, lastIndex: 0, value: 0, _lastKeyframeIndex: -1 }, this.k = !0, this.kf = !0, this.data = F, this.mult = G || 1, this.elem = z, this.container = Y, this.comp = z.comp, this.v = initFrame, this.pv = initFrame, this._isFirstFrame = !0, this.getValue = processEffectsSequence, this.setVValue = setVValue, this.interpolateValue = interpolateValue, this.effectsSequence = [getValueAtCurrentTime.bind(this)], this.addEffect = addEffect } function KeyframedMultidimensionalProperty(z, F, G, Y) { this.propType = "multidimensional"; var X, K = F.k.length, J, Z, Q, ee; for (X = 0; X < K - 1; X += 1)F.k[X].to && F.k[X].s && F.k[X + 1] && F.k[X + 1].s && (J = F.k[X].s, Z = F.k[X + 1].s, Q = F.k[X].to, ee = F.k[X].ti, (J.length === 2 && !(J[0] === Z[0] && J[1] === Z[1]) && bez.pointOnLine2D(J[0], J[1], Z[0], Z[1], J[0] + Q[0], J[1] + Q[1]) && bez.pointOnLine2D(J[0], J[1], Z[0], Z[1], Z[0] + ee[0], Z[1] + ee[1]) || J.length === 3 && !(J[0] === Z[0] && J[1] === Z[1] && J[2] === Z[2]) && bez.pointOnLine3D(J[0], J[1], J[2], Z[0], Z[1], Z[2], J[0] + Q[0], J[1] + Q[1], J[2] + Q[2]) && bez.pointOnLine3D(J[0], J[1], J[2], Z[0], Z[1], Z[2], Z[0] + ee[0], Z[1] + ee[1], Z[2] + ee[2])) && (F.k[X].to = null, F.k[X].ti = null), J[0] === Z[0] && J[1] === Z[1] && Q[0] === 0 && Q[1] === 0 && ee[0] === 0 && ee[1] === 0 && (J.length === 2 || J[2] === Z[2] && Q[2] === 0 && ee[2] === 0) && (F.k[X].to = null, F.k[X].ti = null)); this.effectsSequence = [getValueAtCurrentTime.bind(this)], this.data = F, this.keyframes = F.k, this.keyframesMetadata = [], this.offsetTime = z.data.st, this.k = !0, this.kf = !0, this._isFirstFrame = !0, this.mult = G || 1, this.elem = z, this.container = Y, this.comp = z.comp, this.getValue = processEffectsSequence, this.setVValue = setVValue, this.interpolateValue = interpolateValue, this.frameId = -1; var te = F.k[0].s.length; for (this.v = createTypedArray("float32", te), this.pv = createTypedArray("float32", te), X = 0; X < te; X += 1)this.v[X] = initFrame, this.pv[X] = initFrame; this._caching = { lastFrame: initFrame, lastIndex: 0, value: createTypedArray("float32", te) }, this.addEffect = addEffect } var PropertyFactory = function () { function z(G, Y, X, K, J) { Y.sid && (Y = G.globalData.slotManager.getProp(Y)); var Z; if (!Y.k.length) Z = new ValueProperty(G, Y, K, J); else if (typeof Y.k[0] == "number") Z = new MultiDimensionalProperty(G, Y, K, J); else switch (X) { case 0: Z = new KeyframedValueProperty(G, Y, K, J); break; case 1: Z = new KeyframedMultidimensionalProperty(G, Y, K, J); break }return Z.effectsSequence.length && J.addDynamicProperty(Z), Z } var F = { getProp: z }; return F }(); function DynamicPropertyContainer() { } DynamicPropertyContainer.prototype = { addDynamicProperty: function (F) { this.dynamicProperties.indexOf(F) === -1 && (this.dynamicProperties.push(F), this.container.addDynamicProperty(this), this._isAnimated = !0) }, iterateDynamicProperties: function () { this._mdf = !1; var F, G = this.dynamicProperties.length; for (F = 0; F < G; F += 1)this.dynamicProperties[F].getValue(), this.dynamicProperties[F]._mdf && (this._mdf = !0) }, initDynamicPropertyContainer: function (F) { this.container = F, this.dynamicProperties = [], this._mdf = !1, this._isAnimated = !1 } }; var pointPool = function () { function z() { return createTypedArray("float32", 2) } return poolFactory(8, z) }(); function ShapePath() { this.c = !1, this._length = 0, this._maxLength = 8, this.v = createSizedArray(this._maxLength), this.o = createSizedArray(this._maxLength), this.i = createSizedArray(this._maxLength) } ShapePath.prototype.setPathData = function (z, F) { this.c = z, this.setLength(F); for (var G = 0; G < F;)this.v[G] = pointPool.newElement(), this.o[G] = pointPool.newElement(), this.i[G] = pointPool.newElement(), G += 1 }, ShapePath.prototype.setLength = function (z) { for (; this._maxLength < z;)this.doubleArrayLength(); this._length = z }, ShapePath.prototype.doubleArrayLength = function () { this.v = this.v.concat(createSizedArray(this._maxLength)), this.i = this.i.concat(createSizedArray(this._maxLength)), this.o = this.o.concat(createSizedArray(this._maxLength)), this._maxLength *= 2 }, ShapePath.prototype.setXYAt = function (z, F, G, Y, X) { var K; switch (this._length = Math.max(this._length, Y + 1), this._length >= this._maxLength && this.doubleArrayLength(), G) { case "v": K = this.v; break; case "i": K = this.i; break; case "o": K = this.o; break; default: K = []; break }(!K[Y] || K[Y] && !X) && (K[Y] = pointPool.newElement()), K[Y][0] = z, K[Y][1] = F }, ShapePath.prototype.setTripleAt = function (z, F, G, Y, X, K, J, Z) { this.setXYAt(z, F, "v", J, Z), this.setXYAt(G, Y, "o", J, Z), this.setXYAt(X, K, "i", J, Z) }, ShapePath.prototype.reverse = function () { var z = new ShapePath; z.setPathData(this.c, this._length); var F = this.v, G = this.o, Y = this.i, X = 0; this.c && (z.setTripleAt(F[0][0], F[0][1], Y[0][0], Y[0][1], G[0][0], G[0][1], 0, !1), X = 1); var K = this._length - 1, J = this._length, Z; for (Z = X; Z < J; Z += 1)z.setTripleAt(F[K][0], F[K][1], Y[K][0], Y[K][1], G[K][0], G[K][1], Z, !1), K -= 1; return z }, ShapePath.prototype.length = function () { return this._length }; var shapePool = function () { function z() { return new ShapePath } function F(X) { var K = X._length, J; for (J = 0; J < K; J += 1)pointPool.release(X.v[J]), pointPool.release(X.i[J]), pointPool.release(X.o[J]), X.v[J] = null, X.i[J] = null, X.o[J] = null; X._length = 0, X.c = !1 } function G(X) { var K = Y.newElement(), J, Z = X._length === void 0 ? X.v.length : X._length; for (K.setLength(Z), K.c = X.c, J = 0; J < Z; J += 1)K.setTripleAt(X.v[J][0], X.v[J][1], X.o[J][0], X.o[J][1], X.i[J][0], X.i[J][1], J); return K } var Y = poolFactory(4, z, F); return Y.clone = G, Y }(); function ShapeCollection() { this._length = 0, this._maxLength = 4, this.shapes = createSizedArray(this._maxLength) } ShapeCollection.prototype.addShape = function (z) { this._length === this._maxLength && (this.shapes = this.shapes.concat(createSizedArray(this._maxLength)), this._maxLength *= 2), this.shapes[this._length] = z, this._length += 1 }, ShapeCollection.prototype.releaseShapes = function () { var z; for (z = 0; z < this._length; z += 1)shapePool.release(this.shapes[z]); this._length = 0 }; var shapeCollectionPool = function () { var z = { newShapeCollection: X, release: K }, F = 0, G = 4, Y = createSizedArray(G); function X() { var J; return F ? (F -= 1, J = Y[F]) : J = new ShapeCollection, J } function K(J) { var Z, Q = J._length; for (Z = 0; Z < Q; Z += 1)shapePool.release(J.shapes[Z]); J._length = 0, F === G && (Y = pooling.double(Y), G *= 2), Y[F] = J, F += 1 } return z }(), ShapePropertyFactory = function () { var z = -999999; function F(ae, he, le) { var ce = le.lastIndex, ue, me, ge, ve, Se, ke, Ce, Ee, De, Pe = this.keyframes; if (ae < Pe[0].t - this.offsetTime) ue = Pe[0].s[0], ge = !0, ce = 0; else if (ae >= Pe[Pe.length - 1].t - this.offsetTime) ue = Pe[Pe.length - 1].s ? Pe[Pe.length - 1].s[0] : Pe[Pe.length - 2].e[0], ge = !0; else { for (var Te = ce, ye = Pe.length - 1, xe = !0, pe, de, _e; xe && (pe = Pe[Te], de = Pe[Te + 1], !(de.t - this.offsetTime > ae));)Te < ye - 1 ? Te += 1 : xe = !1; if (_e = this.keyframesMetadata[Te] || {}, ge = pe.h === 1, ce = Te, !ge) { if (ae >= de.t - this.offsetTime) Ee = 1; else if (ae < pe.t - this.offsetTime) Ee = 0; else { var be; _e.__fnct ? be = _e.__fnct : (be = BezierFactory.getBezierEasing(pe.o.x, pe.o.y, pe.i.x, pe.i.y).get, _e.__fnct = be), Ee = be((ae - (pe.t - this.offsetTime)) / (de.t - this.offsetTime - (pe.t - this.offsetTime))) } me = de.s ? de.s[0] : pe.e[0] } ue = pe.s[0] } for (ke = he._length, Ce = ue.i[0].length, le.lastIndex = ce, ve = 0; ve < ke; ve += 1)for (Se = 0; Se < Ce; Se += 1)De = ge ? ue.i[ve][Se] : ue.i[ve][Se] + (me.i[ve][Se] - ue.i[ve][Se]) * Ee, he.i[ve][Se] = De, De = ge ? ue.o[ve][Se] : ue.o[ve][Se] + (me.o[ve][Se] - ue.o[ve][Se]) * Ee, he.o[ve][Se] = De, De = ge ? ue.v[ve][Se] : ue.v[ve][Se] + (me.v[ve][Se] - ue.v[ve][Se]) * Ee, he.v[ve][Se] = De } function G() { var ae = this.comp.renderedFrame - this.offsetTime, he = this.keyframes[0].t - this.offsetTime, le = this.keyframes[this.keyframes.length - 1].t - this.offsetTime, ce = this._caching.lastFrame; return ce !== z && (ce < he && ae < he || ce > le && ae > le) || (this._caching.lastIndex = ce < ae ? this._caching.lastIndex : 0, this.interpolateShape(ae, this.pv, this._caching)), this._caching.lastFrame = ae, this.pv } function Y() { this.paths = this.localShapeCollection } function X(ae, he) { if (ae._length !== he._length || ae.c !== he.c) return !1; var le, ce = ae._length; for (le = 0; le < ce; le += 1)if (ae.v[le][0] !== he.v[le][0] || ae.v[le][1] !== he.v[le][1] || ae.o[le][0] !== he.o[le][0] || ae.o[le][1] !== he.o[le][1] || ae.i[le][0] !== he.i[le][0] || ae.i[le][1] !== he.i[le][1]) return !1; return !0 } function K(ae) { X(this.v, ae) || (this.v = shapePool.clone(ae), this.localShapeCollection.releaseShapes(), this.localShapeCollection.addShape(this.v), this._mdf = !0, this.paths = this.localShapeCollection) } function J() { if (this.elem.globalData.frameId !== this.frameId) { if (!this.effectsSequence.length) { this._mdf = !1; return } if (this.lock) { this.setVValue(this.pv); return } this.lock = !0, this._mdf = !1; var ae; this.kf ? ae = this.pv : this.data.ks ? ae = this.data.ks.k : ae = this.data.pt.k; var he, le = this.effectsSequence.length; for (he = 0; he < le; he += 1)ae = this.effectsSequence[he](ae); this.setVValue(ae), this.lock = !1, this.frameId = this.elem.globalData.frameId } } function Z(ae, he, le) { this.propType = "shape", this.comp = ae.comp, this.container = ae, this.elem = ae, this.data = he, this.k = !1, this.kf = !1, this._mdf = !1; var ce = le === 3 ? he.pt.k : he.ks.k; this.v = shapePool.clone(ce), this.pv = shapePool.clone(this.v), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.paths = this.localShapeCollection, this.paths.addShape(this.v), this.reset = Y, this.effectsSequence = [] } function Q(ae) { this.effectsSequence.push(ae), this.container.addDynamicProperty(this) } Z.prototype.interpolateShape = F, Z.prototype.getValue = J, Z.prototype.setVValue = K, Z.prototype.addEffect = Q; function ee(ae, he, le) { this.propType = "shape", this.comp = ae.comp, this.elem = ae, this.container = ae, this.offsetTime = ae.data.st, this.keyframes = le === 3 ? he.pt.k : he.ks.k, this.keyframesMetadata = [], this.k = !0, this.kf = !0; var ce = this.keyframes[0].s[0].i.length; this.v = shapePool.newElement(), this.v.setPathData(this.keyframes[0].s[0].c, ce), this.pv = shapePool.clone(this.v), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.paths = this.localShapeCollection, this.paths.addShape(this.v), this.lastFrame = z, this.reset = Y, this._caching = { lastFrame: z, lastIndex: 0 }, this.effectsSequence = [G.bind(this)] } ee.prototype.getValue = J, ee.prototype.interpolateShape = F, ee.prototype.setVValue = K, ee.prototype.addEffect = Q; var te = function () { var ae = roundCorner; function he(le, ce) { this.v = shapePool.newElement(), this.v.setPathData(!0, 4), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.paths = this.localShapeCollection, this.localShapeCollection.addShape(this.v), this.d = ce.d, this.elem = le, this.comp = le.comp, this.frameId = -1, this.initDynamicPropertyContainer(le), this.p = PropertyFactory.getProp(le, ce.p, 1, 0, this), this.s = PropertyFactory.getProp(le, ce.s, 1, 0, this), this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertEllToPath()) } return he.prototype = { reset: Y, getValue: function () { this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertEllToPath()) }, convertEllToPath: function () { var ce = this.p.v[0], ue = this.p.v[1], me = this.s.v[0] / 2, ge = this.s.v[1] / 2, ve = this.d !== 3, Se = this.v; Se.v[0][0] = ce, Se.v[0][1] = ue - ge, Se.v[1][0] = ve ? ce + me : ce - me, Se.v[1][1] = ue, Se.v[2][0] = ce, Se.v[2][1] = ue + ge, Se.v[3][0] = ve ? ce - me : ce + me, Se.v[3][1] = ue, Se.i[0][0] = ve ? ce - me * ae : ce + me * ae, Se.i[0][1] = ue - ge, Se.i[1][0] = ve ? ce + me : ce - me, Se.i[1][1] = ue - ge * ae, Se.i[2][0] = ve ? ce + me * ae : ce - me * ae, Se.i[2][1] = ue + ge, Se.i[3][0] = ve ? ce - me : ce + me, Se.i[3][1] = ue + ge * ae, Se.o[0][0] = ve ? ce + me * ae : ce - me * ae, Se.o[0][1] = ue - ge, Se.o[1][0] = ve ? ce + me : ce - me, Se.o[1][1] = ue + ge * ae, Se.o[2][0] = ve ? ce - me * ae : ce + me * ae, Se.o[2][1] = ue + ge, Se.o[3][0] = ve ? ce - me : ce + me, Se.o[3][1] = ue - ge * ae } }, extendPrototype([DynamicPropertyContainer], he), he }(), oe = function () { function ae(he, le) { this.v = shapePool.newElement(), this.v.setPathData(!0, 0), this.elem = he, this.comp = he.comp, this.data = le, this.frameId = -1, this.d = le.d, this.initDynamicPropertyContainer(he), le.sy === 1 ? (this.ir = PropertyFactory.getProp(he, le.ir, 0, 0, this), this.is = PropertyFactory.getProp(he, le.is, 0, .01, this), this.convertToPath = this.convertStarToPath) : this.convertToPath = this.convertPolygonToPath, this.pt = PropertyFactory.getProp(he, le.pt, 0, 0, this), this.p = PropertyFactory.getProp(he, le.p, 1, 0, this), this.r = PropertyFactory.getProp(he, le.r, 0, degToRads, this), this.or = PropertyFactory.getProp(he, le.or, 0, 0, this), this.os = PropertyFactory.getProp(he, le.os, 0, .01, this), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.localShapeCollection.addShape(this.v), this.paths = this.localShapeCollection, this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertToPath()) } return ae.prototype = { reset: Y, getValue: function () { this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertToPath()) }, convertStarToPath: function () { var le = Math.floor(this.pt.v) * 2, ce = Math.PI * 2 / le, ue = !0, me = this.or.v, ge = this.ir.v, ve = this.os.v, Se = this.is.v, ke = 2 * Math.PI * me / (le * 2), Ce = 2 * Math.PI * ge / (le * 2), Ee, De, Pe, Te, ye = -Math.PI / 2; ye += this.r.v; var xe = this.data.d === 3 ? -1 : 1; for (this.v._length = 0, Ee = 0; Ee < le; Ee += 1) { De = ue ? me : ge, Pe = ue ? ve : Se, Te = ue ? ke : Ce; var pe = De * Math.cos(ye), de = De * Math.sin(ye), _e = pe === 0 && de === 0 ? 0 : de / Math.sqrt(pe * pe + de * de), be = pe === 0 && de === 0 ? 0 : -pe / Math.sqrt(pe * pe + de * de); pe += +this.p.v[0], de += +this.p.v[1], this.v.setTripleAt(pe, de, pe - _e * Te * Pe * xe, de - be * Te * Pe * xe, pe + _e * Te * Pe * xe, de + be * Te * Pe * xe, Ee, !0), ue = !ue, ye += ce * xe } }, convertPolygonToPath: function () { var le = Math.floor(this.pt.v), ce = Math.PI * 2 / le, ue = this.or.v, me = this.os.v, ge = 2 * Math.PI * ue / (le * 4), ve, Se = -Math.PI * .5, ke = this.data.d === 3 ? -1 : 1; for (Se += this.r.v, this.v._length = 0, ve = 0; ve < le; ve += 1) { var Ce = ue * Math.cos(Se), Ee = ue * Math.sin(Se), De = Ce === 0 && Ee === 0 ? 0 : Ee / Math.sqrt(Ce * Ce + Ee * Ee), Pe = Ce === 0 && Ee === 0 ? 0 : -Ce / Math.sqrt(Ce * Ce + Ee * Ee); Ce += +this.p.v[0], Ee += +this.p.v[1], this.v.setTripleAt(Ce, Ee, Ce - De * ge * me * ke, Ee - Pe * ge * me * ke, Ce + De * ge * me * ke, Ee + Pe * ge * me * ke, ve, !0), Se += ce * ke } this.paths.length = 0, this.paths[0] = this.v } }, extendPrototype([DynamicPropertyContainer], ae), ae }(), ie = function () { function ae(he, le) { this.v = shapePool.newElement(), this.v.c = !0, this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.localShapeCollection.addShape(this.v), this.paths = this.localShapeCollection, this.elem = he, this.comp = he.comp, this.frameId = -1, this.d = le.d, this.initDynamicPropertyContainer(he), this.p = PropertyFactory.getProp(he, le.p, 1, 0, this), this.s = PropertyFactory.getProp(he, le.s, 1, 0, this), this.r = PropertyFactory.getProp(he, le.r, 0, 0, this), this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertRectToPath()) } return ae.prototype = { convertRectToPath: function () { var le = this.p.v[0], ce = this.p.v[1], ue = this.s.v[0] / 2, me = this.s.v[1] / 2, ge = bmMin(ue, me, this.r.v), ve = ge * (1 - roundCorner); this.v._length = 0, this.d === 2 || this.d === 1 ? (this.v.setTripleAt(le + ue, ce - me + ge, le + ue, ce - me + ge, le + ue, ce - me + ve, 0, !0), this.v.setTripleAt(le + ue, ce + me - ge, le + ue, ce + me - ve, le + ue, ce + me - ge, 1, !0), ge !== 0 ? (this.v.setTripleAt(le + ue - ge, ce + me, le + ue - ge, ce + me, le + ue - ve, ce + me, 2, !0), this.v.setTripleAt(le - ue + ge, ce + me, le - ue + ve, ce + me, le - ue + ge, ce + me, 3, !0), this.v.setTripleAt(le - ue, ce + me - ge, le - ue, ce + me - ge, le - ue, ce + me - ve, 4, !0), this.v.setTripleAt(le - ue, ce - me + ge, le - ue, ce - me + ve, le - ue, ce - me + ge, 5, !0), this.v.setTripleAt(le - ue + ge, ce - me, le - ue + ge, ce - me, le - ue + ve, ce - me, 6, !0), this.v.setTripleAt(le + ue - ge, ce - me, le + ue - ve, ce - me, le + ue - ge, ce - me, 7, !0)) : (this.v.setTripleAt(le - ue, ce + me, le - ue + ve, ce + me, le - ue, ce + me, 2), this.v.setTripleAt(le - ue, ce - me, le - ue, ce - me + ve, le - ue, ce - me, 3))) : (this.v.setTripleAt(le + ue, ce - me + ge, le + ue, ce - me + ve, le + ue, ce - me + ge, 0, !0), ge !== 0 ? (this.v.setTripleAt(le + ue - ge, ce - me, le + ue - ge, ce - me, le + ue - ve, ce - me, 1, !0), this.v.setTripleAt(le - ue + ge, ce - me, le - ue + ve, ce - me, le - ue + ge, ce - me, 2, !0), this.v.setTripleAt(le - ue, ce - me + ge, le - ue, ce - me + ge, le - ue, ce - me + ve, 3, !0), this.v.setTripleAt(le - ue, ce + me - ge, le - ue, ce + me - ve, le - ue, ce + me - ge, 4, !0), this.v.setTripleAt(le - ue + ge, ce + me, le - ue + ge, ce + me, le - ue + ve, ce + me, 5, !0), this.v.setTripleAt(le + ue - ge, ce + me, le + ue - ve, ce + me, le + ue - ge, ce + me, 6, !0), this.v.setTripleAt(le + ue, ce + me - ge, le + ue, ce + me - ge, le + ue, ce + me - ve, 7, !0)) : (this.v.setTripleAt(le - ue, ce - me, le - ue + ve, ce - me, le - ue, ce - me, 1, !0), this.v.setTripleAt(le - ue, ce + me, le - ue, ce + me - ve, le - ue, ce + me, 2, !0), this.v.setTripleAt(le + ue, ce + me, le + ue - ve, ce + me, le + ue, ce + me, 3, !0))) }, getValue: function () { this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertRectToPath()) }, reset: Y }, extendPrototype([DynamicPropertyContainer], ae), ae }(); function se(ae, he, le) { var ce; if (le === 3 || le === 4) { var ue = le === 3 ? he.pt : he.ks, me = ue.k; me.length ? ce = new ee(ae, he, le) : ce = new Z(ae, he, le) } else le === 5 ? ce = new ie(ae, he) : le === 6 ? ce = new te(ae, he) : le === 7 && (ce = new oe(ae, he)); return ce.k && ae.addDynamicProperty(ce), ce } function ne() { return Z } function re() { return ee } var fe = {}; return fe.getShapeProp = se, fe.getConstructorFunction = ne, fe.getKeyframedConstructorFunction = re, fe }();/*!
 Transformation Matrix v2.0
 (c) Epistemex 2014-2015
 www.epistemex.com
 By Ken Fyrstenberg
 Contributions by leeoniya.
 License: MIT, header required.
 */var Matrix = function () { var z = Math.cos, F = Math.sin, G = Math.tan, Y = Math.round; function X() { return this.props[0] = 1, this.props[1] = 0, this.props[2] = 0, this.props[3] = 0, this.props[4] = 0, this.props[5] = 1, this.props[6] = 0, this.props[7] = 0, this.props[8] = 0, this.props[9] = 0, this.props[10] = 1, this.props[11] = 0, this.props[12] = 0, this.props[13] = 0, this.props[14] = 0, this.props[15] = 1, this } function K(pe) { if (pe === 0) return this; var de = z(pe), _e = F(pe); return this._t(de, -_e, 0, 0, _e, de, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1) } function J(pe) { if (pe === 0) return this; var de = z(pe), _e = F(pe); return this._t(1, 0, 0, 0, 0, de, -_e, 0, 0, _e, de, 0, 0, 0, 0, 1) } function Z(pe) { if (pe === 0) return this; var de = z(pe), _e = F(pe); return this._t(de, 0, _e, 0, 0, 1, 0, 0, -_e, 0, de, 0, 0, 0, 0, 1) } function Q(pe) { if (pe === 0) return this; var de = z(pe), _e = F(pe); return this._t(de, -_e, 0, 0, _e, de, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1) } function ee(pe, de) { return this._t(1, de, pe, 1, 0, 0) } function te(pe, de) { return this.shear(G(pe), G(de)) } function oe(pe, de) { var _e = z(de), be = F(de); return this._t(_e, be, 0, 0, -be, _e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, G(pe), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(_e, -be, 0, 0, be, _e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1) } function ie(pe, de, _e) { return !_e && _e !== 0 && (_e = 1), pe === 1 && de === 1 && _e === 1 ? this : this._t(pe, 0, 0, 0, 0, de, 0, 0, 0, 0, _e, 0, 0, 0, 0, 1) } function se(pe, de, _e, be, Ae, $e, Fe, Ie, Be, Ve, Ze, Qe, Ue, Ye, Xe, Re) { return this.props[0] = pe, this.props[1] = de, this.props[2] = _e, this.props[3] = be, this.props[4] = Ae, this.props[5] = $e, this.props[6] = Fe, this.props[7] = Ie, this.props[8] = Be, this.props[9] = Ve, this.props[10] = Ze, this.props[11] = Qe, this.props[12] = Ue, this.props[13] = Ye, this.props[14] = Xe, this.props[15] = Re, this } function ne(pe, de, _e) { return _e = _e || 0, pe !== 0 || de !== 0 || _e !== 0 ? this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, pe, de, _e, 1) : this } function re(pe, de, _e, be, Ae, $e, Fe, Ie, Be, Ve, Ze, Qe, Ue, Ye, Xe, Re) { var Me = this.props; if (pe === 1 && de === 0 && _e === 0 && be === 0 && Ae === 0 && $e === 1 && Fe === 0 && Ie === 0 && Be === 0 && Ve === 0 && Ze === 1 && Qe === 0) return Me[12] = Me[12] * pe + Me[15] * Ue, Me[13] = Me[13] * $e + Me[15] * Ye, Me[14] = Me[14] * Ze + Me[15] * Xe, Me[15] *= Re, this._identityCalculated = !1, this; var it = Me[0], nt = Me[1], we = Me[2], Ge = Me[3], Oe = Me[4], at = Me[5], We = Me[6], ot = Me[7], dt = Me[8], mt = Me[9], rt = Me[10], ut = Me[11], tt = Me[12], St = Me[13], _t = Me[14], Tt = Me[15]; return Me[0] = it * pe + nt * Ae + we * Be + Ge * Ue, Me[1] = it * de + nt * $e + we * Ve + Ge * Ye, Me[2] = it * _e + nt * Fe + we * Ze + Ge * Xe, Me[3] = it * be + nt * Ie + we * Qe + Ge * Re, Me[4] = Oe * pe + at * Ae + We * Be + ot * Ue, Me[5] = Oe * de + at * $e + We * Ve + ot * Ye, Me[6] = Oe * _e + at * Fe + We * Ze + ot * Xe, Me[7] = Oe * be + at * Ie + We * Qe + ot * Re, Me[8] = dt * pe + mt * Ae + rt * Be + ut * Ue, Me[9] = dt * de + mt * $e + rt * Ve + ut * Ye, Me[10] = dt * _e + mt * Fe + rt * Ze + ut * Xe, Me[11] = dt * be + mt * Ie + rt * Qe + ut * Re, Me[12] = tt * pe + St * Ae + _t * Be + Tt * Ue, Me[13] = tt * de + St * $e + _t * Ve + Tt * Ye, Me[14] = tt * _e + St * Fe + _t * Ze + Tt * Xe, Me[15] = tt * be + St * Ie + _t * Qe + Tt * Re, this._identityCalculated = !1, this } function fe(pe) { var de = pe.props; return this.transform(de[0], de[1], de[2], de[3], de[4], de[5], de[6], de[7], de[8], de[9], de[10], de[11], de[12], de[13], de[14], de[15]) } function ae() { return this._identityCalculated || (this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0 || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0 || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0 || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1), this._identityCalculated = !0), this._identity } function he(pe) { for (var de = 0; de < 16;) { if (pe.props[de] !== this.props[de]) return !1; de += 1 } return !0 } function le(pe) { var de; for (de = 0; de < 16; de += 1)pe.props[de] = this.props[de]; return pe } function ce(pe) { var de; for (de = 0; de < 16; de += 1)this.props[de] = pe[de] } function ue(pe, de, _e) { return { x: pe * this.props[0] + de * this.props[4] + _e * this.props[8] + this.props[12], y: pe * this.props[1] + de * this.props[5] + _e * this.props[9] + this.props[13], z: pe * this.props[2] + de * this.props[6] + _e * this.props[10] + this.props[14] } } function me(pe, de, _e) { return pe * this.props[0] + de * this.props[4] + _e * this.props[8] + this.props[12] } function ge(pe, de, _e) { return pe * this.props[1] + de * this.props[5] + _e * this.props[9] + this.props[13] } function ve(pe, de, _e) { return pe * this.props[2] + de * this.props[6] + _e * this.props[10] + this.props[14] } function Se() { var pe = this.props[0] * this.props[5] - this.props[1] * this.props[4], de = this.props[5] / pe, _e = -this.props[1] / pe, be = -this.props[4] / pe, Ae = this.props[0] / pe, $e = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / pe, Fe = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / pe, Ie = new Matrix; return Ie.props[0] = de, Ie.props[1] = _e, Ie.props[4] = be, Ie.props[5] = Ae, Ie.props[12] = $e, Ie.props[13] = Fe, Ie } function ke(pe) { var de = this.getInverseMatrix(); return de.applyToPointArray(pe[0], pe[1], pe[2] || 0) } function Ce(pe) { var de, _e = pe.length, be = []; for (de = 0; de < _e; de += 1)be[de] = ke(pe[de]); return be } function Ee(pe, de, _e) { var be = createTypedArray("float32", 6); if (this.isIdentity()) be[0] = pe[0], be[1] = pe[1], be[2] = de[0], be[3] = de[1], be[4] = _e[0], be[5] = _e[1]; else { var Ae = this.props[0], $e = this.props[1], Fe = this.props[4], Ie = this.props[5], Be = this.props[12], Ve = this.props[13]; be[0] = pe[0] * Ae + pe[1] * Fe + Be, be[1] = pe[0] * $e + pe[1] * Ie + Ve, be[2] = de[0] * Ae + de[1] * Fe + Be, be[3] = de[0] * $e + de[1] * Ie + Ve, be[4] = _e[0] * Ae + _e[1] * Fe + Be, be[5] = _e[0] * $e + _e[1] * Ie + Ve } return be } function De(pe, de, _e) { var be; return this.isIdentity() ? be = [pe, de, _e] : be = [pe * this.props[0] + de * this.props[4] + _e * this.props[8] + this.props[12], pe * this.props[1] + de * this.props[5] + _e * this.props[9] + this.props[13], pe * this.props[2] + de * this.props[6] + _e * this.props[10] + this.props[14]], be } function Pe(pe, de) { if (this.isIdentity()) return pe + "," + de; var _e = this.props; return Math.round((pe * _e[0] + de * _e[4] + _e[12]) * 100) / 100 + "," + Math.round((pe * _e[1] + de * _e[5] + _e[13]) * 100) / 100 } function Te() { for (var pe = 0, de = this.props, _e = "matrix3d(", be = 1e4; pe < 16;)_e += Y(de[pe] * be) / be, _e += pe === 15 ? ")" : ",", pe += 1; return _e } function ye(pe) { var de = 1e4; return pe < 1e-6 && pe > 0 || pe > -1e-6 && pe < 0 ? Y(pe * de) / de : pe } function xe() { var pe = this.props, de = ye(pe[0]), _e = ye(pe[1]), be = ye(pe[4]), Ae = ye(pe[5]), $e = ye(pe[12]), Fe = ye(pe[13]); return "matrix(" + de + "," + _e + "," + be + "," + Ae + "," + $e + "," + Fe + ")" } return function () { this.reset = X, this.rotate = K, this.rotateX = J, this.rotateY = Z, this.rotateZ = Q, this.skew = te, this.skewFromAxis = oe, this.shear = ee, this.scale = ie, this.setTransform = se, this.translate = ne, this.transform = re, this.multiply = fe, this.applyToPoint = ue, this.applyToX = me, this.applyToY = ge, this.applyToZ = ve, this.applyToPointArray = De, this.applyToTriplePoints = Ee, this.applyToPointStringified = Pe, this.toCSS = Te, this.to2dCSS = xe, this.clone = le, this.cloneFromProps = ce, this.equals = he, this.inversePoints = Ce, this.inversePoint = ke, this.getInverseMatrix = Se, this._t = this.transform, this.isIdentity = ae, this._identity = !0, this._identityCalculated = !1, this.props = createTypedArray("float32", 16), this.reset() } }(); function _typeof$3(z) { "@babel/helpers - typeof"; return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$3 = function (G) { return typeof G } : _typeof$3 = function (G) { return G && typeof Symbol == "function" && G.constructor === Symbol && G !== Symbol.prototype ? "symbol" : typeof G }, _typeof$3(z) } var lottie = {}; function setLocation(z) { setLocationHref(z) } function searchAnimations() { animationManager.searchAnimations() } function setSubframeRendering(z) { setSubframeEnabled(z) } function setPrefix(z) { setIdPrefix(z) } function loadAnimation(z) { return animationManager.loadAnimation(z) } function setQuality(z) { if (typeof z == "string") switch (z) { case "high": setDefaultCurveSegments(200); break; default: case "medium": setDefaultCurveSegments(50); break; case "low": setDefaultCurveSegments(10); break } else !isNaN(z) && z > 1 && setDefaultCurveSegments(z) } function inBrowser() { return typeof navigator < "u" } function installPlugin(z, F) { z === "expressions" && setExpressionsPlugin(F) } function getFactory(z) { switch (z) { case "propertyFactory": return PropertyFactory; case "shapePropertyFactory": return ShapePropertyFactory; case "matrix": return Matrix; default: return null } } lottie.play = animationManager.play, lottie.pause = animationManager.pause, lottie.setLocationHref = setLocation, lottie.togglePause = animationManager.togglePause, lottie.setSpeed = animationManager.setSpeed, lottie.setDirection = animationManager.setDirection, lottie.stop = animationManager.stop, lottie.searchAnimations = searchAnimations, lottie.registerAnimation = animationManager.registerAnimation, lottie.loadAnimation = loadAnimation, lottie.setSubframeRendering = setSubframeRendering, lottie.resize = animationManager.resize, lottie.goToAndStop = animationManager.goToAndStop, lottie.destroy = animationManager.destroy, lottie.setQuality = setQuality, lottie.inBrowser = inBrowser, lottie.installPlugin = installPlugin, lottie.freeze = animationManager.freeze, lottie.unfreeze = animationManager.unfreeze, lottie.setVolume = animationManager.setVolume, lottie.mute = animationManager.mute, lottie.unmute = animationManager.unmute, lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations, lottie.useWebWorker = setWebWorker, lottie.setIDPrefix = setPrefix, lottie.__getFactory = getFactory, lottie.version = "5.12.2"; function checkReady() { document.readyState === "complete" && (clearInterval(readyStateCheckInterval), searchAnimations()) } function getQueryVariable(z) { for (var F = queryString.split("&"), G = 0; G < F.length; G += 1) { var Y = F[G].split("="); if (decodeURIComponent(Y[0]) == z) return decodeURIComponent(Y[1]) } return null } var queryString = ""; { var scripts = document.getElementsByTagName("script"), index = scripts.length - 1, myScript = scripts[index] || { src: "" }; queryString = myScript.src ? myScript.src.replace(/^[^\?]+\??/, "") : "", getQueryVariable("renderer") } var readyStateCheckInterval = setInterval(checkReady, 100); try { _typeof$3(exports) !== "object" && (window.bodymovin = lottie) } catch (z) { } var ShapeModifiers = function () { var z = {}, F = {}; z.registerModifier = G, z.getModifier = Y; function G(X, K) { F[X] || (F[X] = K) } function Y(X, K, J) { return new F[X](K, J) } return z }(); function ShapeModifier() { } ShapeModifier.prototype.initModifierProperties = function () { }, ShapeModifier.prototype.addShapeToModifier = function () { }, ShapeModifier.prototype.addShape = function (z) { if (!this.closed) { z.sh.container.addDynamicProperty(z.sh); var F = { shape: z.sh, data: z, localShapeCollection: shapeCollectionPool.newShapeCollection() }; this.shapes.push(F), this.addShapeToModifier(F), this._isAnimated && z.setAsAnimated() } }, ShapeModifier.prototype.init = function (z, F) { this.shapes = [], this.elem = z, this.initDynamicPropertyContainer(z), this.initModifierProperties(z, F), this.frameId = initialDefaultFrame, this.closed = !1, this.k = !1, this.dynamicProperties.length ? this.k = !0 : this.getValue(!0) }, ShapeModifier.prototype.processKeys = function () { this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties()) }, extendPrototype([DynamicPropertyContainer], ShapeModifier); function TrimModifier() { } extendPrototype([ShapeModifier], TrimModifier), TrimModifier.prototype.initModifierProperties = function (z, F) { this.s = PropertyFactory.getProp(z, F.s, 0, .01, this), this.e = PropertyFactory.getProp(z, F.e, 0, .01, this), this.o = PropertyFactory.getProp(z, F.o, 0, 0, this), this.sValue = 0, this.eValue = 0, this.getValue = this.processKeys, this.m = F.m, this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length }, TrimModifier.prototype.addShapeToModifier = function (z) { z.pathsData = [] }, TrimModifier.prototype.calculateShapeEdges = function (z, F, G, Y, X) { var K = []; F <= 1 ? K.push({ s: z, e: F }) : z >= 1 ? K.push({ s: z - 1, e: F - 1 }) : (K.push({ s: z, e: 1 }), K.push({ s: 0, e: F - 1 })); var J = [], Z, Q = K.length, ee; for (Z = 0; Z < Q; Z += 1)if (ee = K[Z], !(ee.e * X < Y || ee.s * X > Y + G)) { var te, oe; ee.s * X <= Y ? te = 0 : te = (ee.s * X - Y) / G, ee.e * X >= Y + G ? oe = 1 : oe = (ee.e * X - Y) / G, J.push([te, oe]) } return J.length || J.push([0, 0]), J }, TrimModifier.prototype.releasePathsData = function (z) { var F, G = z.length; for (F = 0; F < G; F += 1)segmentsLengthPool.release(z[F]); return z.length = 0, z }, TrimModifier.prototype.processShapes = function (z) { var F, G; if (this._mdf || z) { var Y = this.o.v % 360 / 360; if (Y < 0 && (Y += 1), this.s.v > 1 ? F = 1 + Y : this.s.v < 0 ? F = 0 + Y : F = this.s.v + Y, this.e.v > 1 ? G = 1 + Y : this.e.v < 0 ? G = 0 + Y : G = this.e.v + Y, F > G) { var X = F; F = G, G = X } F = Math.round(F * 1e4) * 1e-4, G = Math.round(G * 1e4) * 1e-4, this.sValue = F, this.eValue = G } else F = this.sValue, G = this.eValue; var K, J, Z = this.shapes.length, Q, ee, te, oe, ie, se = 0; if (G === F) for (J = 0; J < Z; J += 1)this.shapes[J].localShapeCollection.releaseShapes(), this.shapes[J].shape._mdf = !0, this.shapes[J].shape.paths = this.shapes[J].localShapeCollection, this._mdf && (this.shapes[J].pathsData.length = 0); else if (G === 1 && F === 0 || G === 0 && F === 1) { if (this._mdf) for (J = 0; J < Z; J += 1)this.shapes[J].pathsData.length = 0, this.shapes[J].shape._mdf = !0 } else { var ne = [], re, fe; for (J = 0; J < Z; J += 1)if (re = this.shapes[J], !re.shape._mdf && !this._mdf && !z && this.m !== 2) re.shape.paths = re.localShapeCollection; else { if (K = re.shape.paths, ee = K._length, ie = 0, !re.shape._mdf && re.pathsData.length) ie = re.totalShapeLength; else { for (te = this.releasePathsData(re.pathsData), Q = 0; Q < ee; Q += 1)oe = bez.getSegmentsLength(K.shapes[Q]), te.push(oe), ie += oe.totalLength; re.totalShapeLength = ie, re.pathsData = te } se += ie, re.shape._mdf = !0 } var ae = F, he = G, le = 0, ce; for (J = Z - 1; J >= 0; J -= 1)if (re = this.shapes[J], re.shape._mdf) { for (fe = re.localShapeCollection, fe.releaseShapes(), this.m === 2 && Z > 1 ? (ce = this.calculateShapeEdges(F, G, re.totalShapeLength, le, se), le += re.totalShapeLength) : ce = [[ae, he]], ee = ce.length, Q = 0; Q < ee; Q += 1) { ae = ce[Q][0], he = ce[Q][1], ne.length = 0, he <= 1 ? ne.push({ s: re.totalShapeLength * ae, e: re.totalShapeLength * he }) : ae >= 1 ? ne.push({ s: re.totalShapeLength * (ae - 1), e: re.totalShapeLength * (he - 1) }) : (ne.push({ s: re.totalShapeLength * ae, e: re.totalShapeLength }), ne.push({ s: 0, e: re.totalShapeLength * (he - 1) })); var ue = this.addShapes(re, ne[0]); if (ne[0].s !== ne[0].e) { if (ne.length > 1) { var me = re.shape.paths.shapes[re.shape.paths._length - 1]; if (me.c) { var ge = ue.pop(); this.addPaths(ue, fe), ue = this.addShapes(re, ne[1], ge) } else this.addPaths(ue, fe), ue = this.addShapes(re, ne[1]) } this.addPaths(ue, fe) } } re.shape.paths = fe } } }, TrimModifier.prototype.addPaths = function (z, F) { var G, Y = z.length; for (G = 0; G < Y; G += 1)F.addShape(z[G]) }, TrimModifier.prototype.addSegment = function (z, F, G, Y, X, K, J) { X.setXYAt(F[0], F[1], "o", K), X.setXYAt(G[0], G[1], "i", K + 1), J && X.setXYAt(z[0], z[1], "v", K), X.setXYAt(Y[0], Y[1], "v", K + 1) }, TrimModifier.prototype.addSegmentFromArray = function (z, F, G, Y) { F.setXYAt(z[1], z[5], "o", G), F.setXYAt(z[2], z[6], "i", G + 1), Y && F.setXYAt(z[0], z[4], "v", G), F.setXYAt(z[3], z[7], "v", G + 1) }, TrimModifier.prototype.addShapes = function (z, F, G) { var Y = z.pathsData, X = z.shape.paths.shapes, K, J = z.shape.paths._length, Z, Q, ee = 0, te, oe, ie, se, ne = [], re, fe = !0; for (G ? (oe = G._length, re = G._length) : (G = shapePool.newElement(), oe = 0, re = 0), ne.push(G), K = 0; K < J; K += 1) { for (ie = Y[K].lengths, G.c = X[K].c, Q = X[K].c ? ie.length : ie.length + 1, Z = 1; Z < Q; Z += 1)if (te = ie[Z - 1], ee + te.addedLength < F.s) ee += te.addedLength, G.c = !1; else if (ee > F.e) { G.c = !1; break } else F.s <= ee && F.e >= ee + te.addedLength ? (this.addSegment(X[K].v[Z - 1], X[K].o[Z - 1], X[K].i[Z], X[K].v[Z], G, oe, fe), fe = !1) : (se = bez.getNewSegment(X[K].v[Z - 1], X[K].v[Z], X[K].o[Z - 1], X[K].i[Z], (F.s - ee) / te.addedLength, (F.e - ee) / te.addedLength, ie[Z - 1]), this.addSegmentFromArray(se, G, oe, fe), fe = !1, G.c = !1), ee += te.addedLength, oe += 1; if (X[K].c && ie.length) { if (te = ie[Z - 1], ee <= F.e) { var ae = ie[Z - 1].addedLength; F.s <= ee && F.e >= ee + ae ? (this.addSegment(X[K].v[Z - 1], X[K].o[Z - 1], X[K].i[0], X[K].v[0], G, oe, fe), fe = !1) : (se = bez.getNewSegment(X[K].v[Z - 1], X[K].v[0], X[K].o[Z - 1], X[K].i[0], (F.s - ee) / ae, (F.e - ee) / ae, ie[Z - 1]), this.addSegmentFromArray(se, G, oe, fe), fe = !1, G.c = !1) } else G.c = !1; ee += te.addedLength, oe += 1 } if (G._length && (G.setXYAt(G.v[re][0], G.v[re][1], "i", re), G.setXYAt(G.v[G._length - 1][0], G.v[G._length - 1][1], "o", G._length - 1)), ee > F.e) break; K < J - 1 && (G = shapePool.newElement(), fe = !0, ne.push(G), oe = 0) } return ne }; function PuckerAndBloatModifier() { } extendPrototype([ShapeModifier], PuckerAndBloatModifier), PuckerAndBloatModifier.prototype.initModifierProperties = function (z, F) { this.getValue = this.processKeys, this.amount = PropertyFactory.getProp(z, F.a, 0, null, this), this._isAnimated = !!this.amount.effectsSequence.length }, PuckerAndBloatModifier.prototype.processPath = function (z, F) { var G = F / 100, Y = [0, 0], X = z._length, K = 0; for (K = 0; K < X; K += 1)Y[0] += z.v[K][0], Y[1] += z.v[K][1]; Y[0] /= X, Y[1] /= X; var J = shapePool.newElement(); J.c = z.c; var Z, Q, ee, te, oe, ie; for (K = 0; K < X; K += 1)Z = z.v[K][0] + (Y[0] - z.v[K][0]) * G, Q = z.v[K][1] + (Y[1] - z.v[K][1]) * G, ee = z.o[K][0] + (Y[0] - z.o[K][0]) * -G, te = z.o[K][1] + (Y[1] - z.o[K][1]) * -G, oe = z.i[K][0] + (Y[0] - z.i[K][0]) * -G, ie = z.i[K][1] + (Y[1] - z.i[K][1]) * -G, J.setTripleAt(Z, Q, ee, te, oe, ie, K); return J }, PuckerAndBloatModifier.prototype.processShapes = function (z) { var F, G, Y = this.shapes.length, X, K, J = this.amount.v; if (J !== 0) { var Z, Q; for (G = 0; G < Y; G += 1) { if (Z = this.shapes[G], Q = Z.localShapeCollection, !(!Z.shape._mdf && !this._mdf && !z)) for (Q.releaseShapes(), Z.shape._mdf = !0, F = Z.shape.paths.shapes, K = Z.shape.paths._length, X = 0; X < K; X += 1)Q.addShape(this.processPath(F[X], J)); Z.shape.paths = Z.localShapeCollection } } this.dynamicProperties.length || (this._mdf = !1) }; var TransformPropertyFactory = function () { var z = [0, 0]; function F(Q) { var ee = this._mdf; this.iterateDynamicProperties(), this._mdf = this._mdf || ee, this.a && Q.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.s && Q.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.sk && Q.skewFromAxis(-this.sk.v, this.sa.v), this.r ? Q.rotate(-this.r.v) : Q.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.data.p.s ? this.data.p.z ? Q.translate(this.px.v, this.py.v, -this.pz.v) : Q.translate(this.px.v, this.py.v, 0) : Q.translate(this.p.v[0], this.p.v[1], -this.p.v[2]) } function G(Q) { if (this.elem.globalData.frameId !== this.frameId) { if (this._isDirty && (this.precalculateMatrix(), this._isDirty = !1), this.iterateDynamicProperties(), this._mdf || Q) { var ee; if (this.v.cloneFromProps(this.pre.props), this.appliedTransformations < 1 && this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.appliedTransformations < 2 && this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.sk && this.appliedTransformations < 3 && this.v.skewFromAxis(-this.sk.v, this.sa.v), this.r && this.appliedTransformations < 4 ? this.v.rotate(-this.r.v) : !this.r && this.appliedTransformations < 4 && this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.autoOriented) { var te, oe; if (ee = this.elem.globalData.frameRate, this.p && this.p.keyframes && this.p.getValueAtTime) this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t ? (te = this.p.getValueAtTime((this.p.keyframes[0].t + .01) / ee, 0), oe = this.p.getValueAtTime(this.p.keyframes[0].t / ee, 0)) : this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t ? (te = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / ee, 0), oe = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - .05) / ee, 0)) : (te = this.p.pv, oe = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - .01) / ee, this.p.offsetTime)); else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) { te = [], oe = []; var ie = this.px, se = this.py; ie._caching.lastFrame + ie.offsetTime <= ie.keyframes[0].t ? (te[0] = ie.getValueAtTime((ie.keyframes[0].t + .01) / ee, 0), te[1] = se.getValueAtTime((se.keyframes[0].t + .01) / ee, 0), oe[0] = ie.getValueAtTime(ie.keyframes[0].t / ee, 0), oe[1] = se.getValueAtTime(se.keyframes[0].t / ee, 0)) : ie._caching.lastFrame + ie.offsetTime >= ie.keyframes[ie.keyframes.length - 1].t ? (te[0] = ie.getValueAtTime(ie.keyframes[ie.keyframes.length - 1].t / ee, 0), te[1] = se.getValueAtTime(se.keyframes[se.keyframes.length - 1].t / ee, 0), oe[0] = ie.getValueAtTime((ie.keyframes[ie.keyframes.length - 1].t - .01) / ee, 0), oe[1] = se.getValueAtTime((se.keyframes[se.keyframes.length - 1].t - .01) / ee, 0)) : (te = [ie.pv, se.pv], oe[0] = ie.getValueAtTime((ie._caching.lastFrame + ie.offsetTime - .01) / ee, ie.offsetTime), oe[1] = se.getValueAtTime((se._caching.lastFrame + se.offsetTime - .01) / ee, se.offsetTime)) } else oe = z, te = oe; this.v.rotate(-Math.atan2(te[1] - oe[1], te[0] - oe[0])) } this.data.p && this.data.p.s ? this.data.p.z ? this.v.translate(this.px.v, this.py.v, -this.pz.v) : this.v.translate(this.px.v, this.py.v, 0) : this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2]) } this.frameId = this.elem.globalData.frameId } } function Y() { if (this.appliedTransformations = 0, this.pre.reset(), !this.a.effectsSequence.length) this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.appliedTransformations = 1; else return; if (!this.s.effectsSequence.length) this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.appliedTransformations = 2; else return; if (this.sk) if (!this.sk.effectsSequence.length && !this.sa.effectsSequence.length) this.pre.skewFromAxis(-this.sk.v, this.sa.v), this.appliedTransformations = 3; else return; this.r ? this.r.effectsSequence.length || (this.pre.rotate(-this.r.v), this.appliedTransformations = 4) : !this.rz.effectsSequence.length && !this.ry.effectsSequence.length && !this.rx.effectsSequence.length && !this.or.effectsSequence.length && (this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.appliedTransformations = 4) } function X() { } function K(Q) { this._addDynamicProperty(Q), this.elem.addDynamicProperty(Q), this._isDirty = !0 } function J(Q, ee, te) { if (this.elem = Q, this.frameId = -1, this.propType = "transform", this.data = ee, this.v = new Matrix, this.pre = new Matrix, this.appliedTransformations = 0, this.initDynamicPropertyContainer(te || Q), ee.p && ee.p.s ? (this.px = PropertyFactory.getProp(Q, ee.p.x, 0, 0, this), this.py = PropertyFactory.getProp(Q, ee.p.y, 0, 0, this), ee.p.z && (this.pz = PropertyFactory.getProp(Q, ee.p.z, 0, 0, this))) : this.p = PropertyFactory.getProp(Q, ee.p || { k: [0, 0, 0] }, 1, 0, this), ee.rx) { if (this.rx = PropertyFactory.getProp(Q, ee.rx, 0, degToRads, this), this.ry = PropertyFactory.getProp(Q, ee.ry, 0, degToRads, this), this.rz = PropertyFactory.getProp(Q, ee.rz, 0, degToRads, this), ee.or.k[0].ti) { var oe, ie = ee.or.k.length; for (oe = 0; oe < ie; oe += 1)ee.or.k[oe].to = null, ee.or.k[oe].ti = null } this.or = PropertyFactory.getProp(Q, ee.or, 1, degToRads, this), this.or.sh = !0 } else this.r = PropertyFactory.getProp(Q, ee.r || { k: 0 }, 0, degToRads, this); ee.sk && (this.sk = PropertyFactory.getProp(Q, ee.sk, 0, degToRads, this), this.sa = PropertyFactory.getProp(Q, ee.sa, 0, degToRads, this)), this.a = PropertyFactory.getProp(Q, ee.a || { k: [0, 0, 0] }, 1, 0, this), this.s = PropertyFactory.getProp(Q, ee.s || { k: [100, 100, 100] }, 1, .01, this), ee.o ? this.o = PropertyFactory.getProp(Q, ee.o, 0, .01, Q) : this.o = { _mdf: !1, v: 1 }, this._isDirty = !0, this.dynamicProperties.length || this.getValue(!0) } J.prototype = { applyToMatrix: F, getValue: G, precalculateMatrix: Y, autoOrient: X }, extendPrototype([DynamicPropertyContainer], J), J.prototype.addDynamicProperty = K, J.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty; function Z(Q, ee, te) { return new J(Q, ee, te) } return { getTransformProperty: Z } }(); function RepeaterModifier() { } extendPrototype([ShapeModifier], RepeaterModifier), RepeaterModifier.prototype.initModifierProperties = function (z, F) { this.getValue = this.processKeys, this.c = PropertyFactory.getProp(z, F.c, 0, null, this), this.o = PropertyFactory.getProp(z, F.o, 0, null, this), this.tr = TransformPropertyFactory.getTransformProperty(z, F.tr, this), this.so = PropertyFactory.getProp(z, F.tr.so, 0, .01, this), this.eo = PropertyFactory.getProp(z, F.tr.eo, 0, .01, this), this.data = F, this.dynamicProperties.length || this.getValue(!0), this._isAnimated = !!this.dynamicProperties.length, this.pMatrix = new Matrix, this.rMatrix = new Matrix, this.sMatrix = new Matrix, this.tMatrix = new Matrix, this.matrix = new Matrix }, RepeaterModifier.prototype.applyTransforms = function (z, F, G, Y, X, K) { var J = K ? -1 : 1, Z = Y.s.v[0] + (1 - Y.s.v[0]) * (1 - X), Q = Y.s.v[1] + (1 - Y.s.v[1]) * (1 - X); z.translate(Y.p.v[0] * J * X, Y.p.v[1] * J * X, Y.p.v[2]), F.translate(-Y.a.v[0], -Y.a.v[1], Y.a.v[2]), F.rotate(-Y.r.v * J * X), F.translate(Y.a.v[0], Y.a.v[1], Y.a.v[2]), G.translate(-Y.a.v[0], -Y.a.v[1], Y.a.v[2]), G.scale(K ? 1 / Z : Z, K ? 1 / Q : Q), G.translate(Y.a.v[0], Y.a.v[1], Y.a.v[2]) }, RepeaterModifier.prototype.init = function (z, F, G, Y) { for (this.elem = z, this.arr = F, this.pos = G, this.elemsData = Y, this._currentCopies = 0, this._elements = [], this._groups = [], this.frameId = -1, this.initDynamicPropertyContainer(z), this.initModifierProperties(z, F[G]); G > 0;)G -= 1, this._elements.unshift(F[G]); this.dynamicProperties.length ? this.k = !0 : this.getValue(!0) }, RepeaterModifier.prototype.resetElements = function (z) { var F, G = z.length; for (F = 0; F < G; F += 1)z[F]._processed = !1, z[F].ty === "gr" && this.resetElements(z[F].it) }, RepeaterModifier.prototype.cloneElements = function (z) { var F = JSON.parse(JSON.stringify(z)); return this.resetElements(F), F }, RepeaterModifier.prototype.changeGroupRender = function (z, F) { var G, Y = z.length; for (G = 0; G < Y; G += 1)z[G]._render = F, z[G].ty === "gr" && this.changeGroupRender(z[G].it, F) }, RepeaterModifier.prototype.processShapes = function (z) { var F, G, Y, X, K, J = !1; if (this._mdf || z) { var Z = Math.ceil(this.c.v); if (this._groups.length < Z) { for (; this._groups.length < Z;) { var Q = { it: this.cloneElements(this._elements), ty: "gr" }; Q.it.push({ a: { a: 0, ix: 1, k: [0, 0] }, nm: "Transform", o: { a: 0, ix: 7, k: 100 }, p: { a: 0, ix: 2, k: [0, 0] }, r: { a: 1, ix: 6, k: [{ s: 0, e: 0, t: 0 }, { s: 0, e: 0, t: 1 }] }, s: { a: 0, ix: 3, k: [100, 100] }, sa: { a: 0, ix: 5, k: 0 }, sk: { a: 0, ix: 4, k: 0 }, ty: "tr" }), this.arr.splice(0, 0, Q), this._groups.splice(0, 0, Q), this._currentCopies += 1 } this.elem.reloadShapes(), J = !0 } K = 0; var ee; for (Y = 0; Y <= this._groups.length - 1; Y += 1) { if (ee = K < Z, this._groups[Y]._render = ee, this.changeGroupRender(this._groups[Y].it, ee), !ee) { var te = this.elemsData[Y].it, oe = te[te.length - 1]; oe.transform.op.v !== 0 ? (oe.transform.op._mdf = !0, oe.transform.op.v = 0) : oe.transform.op._mdf = !1 } K += 1 } this._currentCopies = Z; var ie = this.o.v, se = ie % 1, ne = ie > 0 ? Math.floor(ie) : Math.ceil(ie), re = this.pMatrix.props, fe = this.rMatrix.props, ae = this.sMatrix.props; this.pMatrix.reset(), this.rMatrix.reset(), this.sMatrix.reset(), this.tMatrix.reset(), this.matrix.reset(); var he = 0; if (ie > 0) { for (; he < ne;)this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1), he += 1; se && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, se, !1), he += se) } else if (ie < 0) { for (; he > ne;)this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !0), he -= 1; se && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -se, !0), he -= se) } Y = this.data.m === 1 ? 0 : this._currentCopies - 1, X = this.data.m === 1 ? 1 : -1, K = this._currentCopies; for (var le, ce; K;) { if (F = this.elemsData[Y].it, G = F[F.length - 1].transform.mProps.v.props, ce = G.length, F[F.length - 1].transform.mProps._mdf = !0, F[F.length - 1].transform.op._mdf = !0, F[F.length - 1].transform.op.v = this._currentCopies === 1 ? this.so.v : this.so.v + (this.eo.v - this.so.v) * (Y / (this._currentCopies - 1)), he !== 0) { for ((Y !== 0 && X === 1 || Y !== this._currentCopies - 1 && X === -1) && this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1), this.matrix.transform(fe[0], fe[1], fe[2], fe[3], fe[4], fe[5], fe[6], fe[7], fe[8], fe[9], fe[10], fe[11], fe[12], fe[13], fe[14], fe[15]), this.matrix.transform(ae[0], ae[1], ae[2], ae[3], ae[4], ae[5], ae[6], ae[7], ae[8], ae[9], ae[10], ae[11], ae[12], ae[13], ae[14], ae[15]), this.matrix.transform(re[0], re[1], re[2], re[3], re[4], re[5], re[6], re[7], re[8], re[9], re[10], re[11], re[12], re[13], re[14], re[15]), le = 0; le < ce; le += 1)G[le] = this.matrix.props[le]; this.matrix.reset() } else for (this.matrix.reset(), le = 0; le < ce; le += 1)G[le] = this.matrix.props[le]; he += 1, K -= 1, Y += X } } else for (K = this._currentCopies, Y = 0, X = 1; K;)F = this.elemsData[Y].it, G = F[F.length - 1].transform.mProps.v.props, F[F.length - 1].transform.mProps._mdf = !1, F[F.length - 1].transform.op._mdf = !1, K -= 1, Y += X; return J }, RepeaterModifier.prototype.addShape = function () { }; function RoundCornersModifier() { } extendPrototype([ShapeModifier], RoundCornersModifier), RoundCornersModifier.prototype.initModifierProperties = function (z, F) { this.getValue = this.processKeys, this.rd = PropertyFactory.getProp(z, F.r, 0, null, this), this._isAnimated = !!this.rd.effectsSequence.length }, RoundCornersModifier.prototype.processPath = function (z, F) { var G = shapePool.newElement(); G.c = z.c; var Y, X = z._length, K, J, Z, Q, ee, te, oe = 0, ie, se, ne, re, fe, ae; for (Y = 0; Y < X; Y += 1)K = z.v[Y], Z = z.o[Y], J = z.i[Y], K[0] === Z[0] && K[1] === Z[1] && K[0] === J[0] && K[1] === J[1] ? (Y === 0 || Y === X - 1) && !z.c ? (G.setTripleAt(K[0], K[1], Z[0], Z[1], J[0], J[1], oe), oe += 1) : (Y === 0 ? Q = z.v[X - 1] : Q = z.v[Y - 1], ee = Math.sqrt(Math.pow(K[0] - Q[0], 2) + Math.pow(K[1] - Q[1], 2)), te = ee ? Math.min(ee / 2, F) / ee : 0, fe = K[0] + (Q[0] - K[0]) * te, ie = fe, ae = K[1] - (K[1] - Q[1]) * te, se = ae, ne = ie - (ie - K[0]) * roundCorner, re = se - (se - K[1]) * roundCorner, G.setTripleAt(ie, se, ne, re, fe, ae, oe), oe += 1, Y === X - 1 ? Q = z.v[0] : Q = z.v[Y + 1], ee = Math.sqrt(Math.pow(K[0] - Q[0], 2) + Math.pow(K[1] - Q[1], 2)), te = ee ? Math.min(ee / 2, F) / ee : 0, ne = K[0] + (Q[0] - K[0]) * te, ie = ne, re = K[1] + (Q[1] - K[1]) * te, se = re, fe = ie - (ie - K[0]) * roundCorner, ae = se - (se - K[1]) * roundCorner, G.setTripleAt(ie, se, ne, re, fe, ae, oe), oe += 1) : (G.setTripleAt(z.v[Y][0], z.v[Y][1], z.o[Y][0], z.o[Y][1], z.i[Y][0], z.i[Y][1], oe), oe += 1); return G }, RoundCornersModifier.prototype.processShapes = function (z) { var F, G, Y = this.shapes.length, X, K, J = this.rd.v; if (J !== 0) { var Z, Q; for (G = 0; G < Y; G += 1) { if (Z = this.shapes[G], Q = Z.localShapeCollection, !(!Z.shape._mdf && !this._mdf && !z)) for (Q.releaseShapes(), Z.shape._mdf = !0, F = Z.shape.paths.shapes, K = Z.shape.paths._length, X = 0; X < K; X += 1)Q.addShape(this.processPath(F[X], J)); Z.shape.paths = Z.localShapeCollection } } this.dynamicProperties.length || (this._mdf = !1) }; function floatEqual(z, F) { return Math.abs(z - F) * 1e5 <= Math.min(Math.abs(z), Math.abs(F)) } function floatZero(z) { return Math.abs(z) <= 1e-5 } function lerp(z, F, G) { return z * (1 - G) + F * G } function lerpPoint(z, F, G) { return [lerp(z[0], F[0], G), lerp(z[1], F[1], G)] } function quadRoots(z, F, G) { if (z === 0) return []; var Y = F * F - 4 * z * G; if (Y < 0) return []; var X = -F / (2 * z); if (Y === 0) return [X]; var K = Math.sqrt(Y) / (2 * z); return [X - K, X + K] } function polynomialCoefficients(z, F, G, Y) { return [-z + 3 * F - 3 * G + Y, 3 * z - 6 * F + 3 * G, -3 * z + 3 * F, z] } function singlePoint(z) { return new PolynomialBezier(z, z, z, z, !1) } function PolynomialBezier(z, F, G, Y, X) { X && pointEqual(z, F) && (F = lerpPoint(z, Y, 1 / 3)), X && pointEqual(G, Y) && (G = lerpPoint(z, Y, 2 / 3)); var K = polynomialCoefficients(z[0], F[0], G[0], Y[0]), J = polynomialCoefficients(z[1], F[1], G[1], Y[1]); this.a = [K[0], J[0]], this.b = [K[1], J[1]], this.c = [K[2], J[2]], this.d = [K[3], J[3]], this.points = [z, F, G, Y] } PolynomialBezier.prototype.point = function (z) { return [((this.a[0] * z + this.b[0]) * z + this.c[0]) * z + this.d[0], ((this.a[1] * z + this.b[1]) * z + this.c[1]) * z + this.d[1]] }, PolynomialBezier.prototype.derivative = function (z) { return [(3 * z * this.a[0] + 2 * this.b[0]) * z + this.c[0], (3 * z * this.a[1] + 2 * this.b[1]) * z + this.c[1]] }, PolynomialBezier.prototype.tangentAngle = function (z) { var F = this.derivative(z); return Math.atan2(F[1], F[0]) }, PolynomialBezier.prototype.normalAngle = function (z) { var F = this.derivative(z); return Math.atan2(F[0], F[1]) }, PolynomialBezier.prototype.inflectionPoints = function () { var z = this.a[1] * this.b[0] - this.a[0] * this.b[1]; if (floatZero(z)) return []; var F = -.5 * (this.a[1] * this.c[0] - this.a[0] * this.c[1]) / z, G = F * F - 1 / 3 * (this.b[1] * this.c[0] - this.b[0] * this.c[1]) / z; if (G < 0) return []; var Y = Math.sqrt(G); return floatZero(Y) ? Y > 0 && Y < 1 ? [F] : [] : [F - Y, F + Y].filter(function (X) { return X > 0 && X < 1 }) }, PolynomialBezier.prototype.split = function (z) { if (z <= 0) return [singlePoint(this.points[0]), this]; if (z >= 1) return [this, singlePoint(this.points[this.points.length - 1])]; var F = lerpPoint(this.points[0], this.points[1], z), G = lerpPoint(this.points[1], this.points[2], z), Y = lerpPoint(this.points[2], this.points[3], z), X = lerpPoint(F, G, z), K = lerpPoint(G, Y, z), J = lerpPoint(X, K, z); return [new PolynomialBezier(this.points[0], F, X, J, !0), new PolynomialBezier(J, K, Y, this.points[3], !0)] }; function extrema(z, F) { var G = z.points[0][F], Y = z.points[z.points.length - 1][F]; if (G > Y) { var X = Y; Y = G, G = X } for (var K = quadRoots(3 * z.a[F], 2 * z.b[F], z.c[F]), J = 0; J < K.length; J += 1)if (K[J] > 0 && K[J] < 1) { var Z = z.point(K[J])[F]; Z < G ? G = Z : Z > Y && (Y = Z) } return { min: G, max: Y } } PolynomialBezier.prototype.bounds = function () { return { x: extrema(this, 0), y: extrema(this, 1) } }, PolynomialBezier.prototype.boundingBox = function () { var z = this.bounds(); return { left: z.x.min, right: z.x.max, top: z.y.min, bottom: z.y.max, width: z.x.max - z.x.min, height: z.y.max - z.y.min, cx: (z.x.max + z.x.min) / 2, cy: (z.y.max + z.y.min) / 2 } }; function intersectData(z, F, G) { var Y = z.boundingBox(); return { cx: Y.cx, cy: Y.cy, width: Y.width, height: Y.height, bez: z, t: (F + G) / 2, t1: F, t2: G } } function splitData(z) { var F = z.bez.split(.5); return [intersectData(F[0], z.t1, z.t), intersectData(F[1], z.t, z.t2)] } function boxIntersect(z, F) { return Math.abs(z.cx - F.cx) * 2 < z.width + F.width && Math.abs(z.cy - F.cy) * 2 < z.height + F.height } function intersectsImpl(z, F, G, Y, X, K) { if (boxIntersect(z, F)) { if (G >= K || z.width <= Y && z.height <= Y && F.width <= Y && F.height <= Y) { X.push([z.t, F.t]); return } var J = splitData(z), Z = splitData(F); intersectsImpl(J[0], Z[0], G + 1, Y, X, K), intersectsImpl(J[0], Z[1], G + 1, Y, X, K), intersectsImpl(J[1], Z[0], G + 1, Y, X, K), intersectsImpl(J[1], Z[1], G + 1, Y, X, K) } } PolynomialBezier.prototype.intersections = function (z, F, G) { F === void 0 && (F = 2), G === void 0 && (G = 7); var Y = []; return intersectsImpl(intersectData(this, 0, 1), intersectData(z, 0, 1), 0, F, Y, G), Y }, PolynomialBezier.shapeSegment = function (z, F) { var G = (F + 1) % z.length(); return new PolynomialBezier(z.v[F], z.o[F], z.i[G], z.v[G], !0) }, PolynomialBezier.shapeSegmentInverted = function (z, F) { var G = (F + 1) % z.length(); return new PolynomialBezier(z.v[G], z.i[G], z.o[F], z.v[F], !0) }; function crossProduct(z, F) { return [z[1] * F[2] - z[2] * F[1], z[2] * F[0] - z[0] * F[2], z[0] * F[1] - z[1] * F[0]] } function lineIntersection(z, F, G, Y) { var X = [z[0], z[1], 1], K = [F[0], F[1], 1], J = [G[0], G[1], 1], Z = [Y[0], Y[1], 1], Q = crossProduct(crossProduct(X, K), crossProduct(J, Z)); return floatZero(Q[2]) ? null : [Q[0] / Q[2], Q[1] / Q[2]] } function polarOffset(z, F, G) { return [z[0] + Math.cos(F) * G, z[1] - Math.sin(F) * G] } function pointDistance(z, F) { return Math.hypot(z[0] - F[0], z[1] - F[1]) } function pointEqual(z, F) { return floatEqual(z[0], F[0]) && floatEqual(z[1], F[1]) } function ZigZagModifier() { } extendPrototype([ShapeModifier], ZigZagModifier), ZigZagModifier.prototype.initModifierProperties = function (z, F) { this.getValue = this.processKeys, this.amplitude = PropertyFactory.getProp(z, F.s, 0, null, this), this.frequency = PropertyFactory.getProp(z, F.r, 0, null, this), this.pointsType = PropertyFactory.getProp(z, F.pt, 0, null, this), this._isAnimated = this.amplitude.effectsSequence.length !== 0 || this.frequency.effectsSequence.length !== 0 || this.pointsType.effectsSequence.length !== 0 }; function setPoint(z, F, G, Y, X, K, J) { var Z = G - Math.PI / 2, Q = G + Math.PI / 2, ee = F[0] + Math.cos(G) * Y * X, te = F[1] - Math.sin(G) * Y * X; z.setTripleAt(ee, te, ee + Math.cos(Z) * K, te - Math.sin(Z) * K, ee + Math.cos(Q) * J, te - Math.sin(Q) * J, z.length()) } function getPerpendicularVector(z, F) { var G = [F[0] - z[0], F[1] - z[1]], Y = -Math.PI * .5, X = [Math.cos(Y) * G[0] - Math.sin(Y) * G[1], Math.sin(Y) * G[0] + Math.cos(Y) * G[1]]; return X } function getProjectingAngle(z, F) { var G = F === 0 ? z.length() - 1 : F - 1, Y = (F + 1) % z.length(), X = z.v[G], K = z.v[Y], J = getPerpendicularVector(X, K); return Math.atan2(0, 1) - Math.atan2(J[1], J[0]) } function zigZagCorner(z, F, G, Y, X, K, J) { var Z = getProjectingAngle(F, G), Q = F.v[G % F._length], ee = F.v[G === 0 ? F._length - 1 : G - 1], te = F.v[(G + 1) % F._length], oe = K === 2 ? Math.sqrt(Math.pow(Q[0] - ee[0], 2) + Math.pow(Q[1] - ee[1], 2)) : 0, ie = K === 2 ? Math.sqrt(Math.pow(Q[0] - te[0], 2) + Math.pow(Q[1] - te[1], 2)) : 0; setPoint(z, F.v[G % F._length], Z, J, Y, ie / ((X + 1) * 2), oe / ((X + 1) * 2)) } function zigZagSegment(z, F, G, Y, X, K) { for (var J = 0; J < Y; J += 1) { var Z = (J + 1) / (Y + 1), Q = X === 2 ? Math.sqrt(Math.pow(F.points[3][0] - F.points[0][0], 2) + Math.pow(F.points[3][1] - F.points[0][1], 2)) : 0, ee = F.normalAngle(Z), te = F.point(Z); setPoint(z, te, ee, K, G, Q / ((Y + 1) * 2), Q / ((Y + 1) * 2)), K = -K } return K } ZigZagModifier.prototype.processPath = function (z, F, G, Y) { var X = z._length, K = shapePool.newElement(); if (K.c = z.c, z.c || (X -= 1), X === 0) return K; var J = -1, Z = PolynomialBezier.shapeSegment(z, 0); zigZagCorner(K, z, 0, F, G, Y, J); for (var Q = 0; Q < X; Q += 1)J = zigZagSegment(K, Z, F, G, Y, -J), Q === X - 1 && !z.c ? Z = null : Z = PolynomialBezier.shapeSegment(z, (Q + 1) % X), zigZagCorner(K, z, Q + 1, F, G, Y, J); return K }, ZigZagModifier.prototype.processShapes = function (z) { var F, G, Y = this.shapes.length, X, K, J = this.amplitude.v, Z = Math.max(0, Math.round(this.frequency.v)), Q = this.pointsType.v; if (J !== 0) { var ee, te; for (G = 0; G < Y; G += 1) { if (ee = this.shapes[G], te = ee.localShapeCollection, !(!ee.shape._mdf && !this._mdf && !z)) for (te.releaseShapes(), ee.shape._mdf = !0, F = ee.shape.paths.shapes, K = ee.shape.paths._length, X = 0; X < K; X += 1)te.addShape(this.processPath(F[X], J, Z, Q)); ee.shape.paths = ee.localShapeCollection } } this.dynamicProperties.length || (this._mdf = !1) }; function linearOffset(z, F, G) { var Y = Math.atan2(F[0] - z[0], F[1] - z[1]); return [polarOffset(z, Y, G), polarOffset(F, Y, G)] } function offsetSegment(z, F) { var G, Y, X, K, J, Z, Q; Q = linearOffset(z.points[0], z.points[1], F), G = Q[0], Y = Q[1], Q = linearOffset(z.points[1], z.points[2], F), X = Q[0], K = Q[1], Q = linearOffset(z.points[2], z.points[3], F), J = Q[0], Z = Q[1]; var ee = lineIntersection(G, Y, X, K); ee === null && (ee = Y); var te = lineIntersection(J, Z, X, K); return te === null && (te = J), new PolynomialBezier(G, ee, te, Z) } function joinLines(z, F, G, Y, X) { var K = F.points[3], J = G.points[0]; if (Y === 3 || pointEqual(K, J)) return K; if (Y === 2) { var Z = -F.tangentAngle(1), Q = -G.tangentAngle(0) + Math.PI, ee = lineIntersection(K, polarOffset(K, Z + Math.PI / 2, 100), J, polarOffset(J, Z + Math.PI / 2, 100)), te = ee ? pointDistance(ee, K) : pointDistance(K, J) / 2, oe = polarOffset(K, Z, 2 * te * roundCorner); return z.setXYAt(oe[0], oe[1], "o", z.length() - 1), oe = polarOffset(J, Q, 2 * te * roundCorner), z.setTripleAt(J[0], J[1], J[0], J[1], oe[0], oe[1], z.length()), J } var ie = pointEqual(K, F.points[2]) ? F.points[0] : F.points[2], se = pointEqual(J, G.points[1]) ? G.points[3] : G.points[1], ne = lineIntersection(ie, K, J, se); return ne && pointDistance(ne, K) < X ? (z.setTripleAt(ne[0], ne[1], ne[0], ne[1], ne[0], ne[1], z.length()), ne) : K } function getIntersection(z, F) { var G = z.intersections(F); return G.length && floatEqual(G[0][0], 1) && G.shift(), G.length ? G[0] : null } function pruneSegmentIntersection(z, F) { var G = z.slice(), Y = F.slice(), X = getIntersection(z[z.length - 1], F[0]); return X && (G[z.length - 1] = z[z.length - 1].split(X[0])[0], Y[0] = F[0].split(X[1])[1]), z.length > 1 && F.length > 1 && (X = getIntersection(z[0], F[F.length - 1]), X) ? [[z[0].split(X[0])[0]], [F[F.length - 1].split(X[1])[1]]] : [G, Y] } function pruneIntersections(z) { for (var F, G = 1; G < z.length; G += 1)F = pruneSegmentIntersection(z[G - 1], z[G]), z[G - 1] = F[0], z[G] = F[1]; return z.length > 1 && (F = pruneSegmentIntersection(z[z.length - 1], z[0]), z[z.length - 1] = F[0], z[0] = F[1]), z } function offsetSegmentSplit(z, F) { var G = z.inflectionPoints(), Y, X, K, J; if (G.length === 0) return [offsetSegment(z, F)]; if (G.length === 1 || floatEqual(G[1], 1)) return K = z.split(G[0]), Y = K[0], X = K[1], [offsetSegment(Y, F), offsetSegment(X, F)]; K = z.split(G[0]), Y = K[0]; var Z = (G[1] - G[0]) / (1 - G[0]); return K = K[1].split(Z), J = K[0], X = K[1], [offsetSegment(Y, F), offsetSegment(J, F), offsetSegment(X, F)] } function OffsetPathModifier() { } extendPrototype([ShapeModifier], OffsetPathModifier), OffsetPathModifier.prototype.initModifierProperties = function (z, F) { this.getValue = this.processKeys, this.amount = PropertyFactory.getProp(z, F.a, 0, null, this), this.miterLimit = PropertyFactory.getProp(z, F.ml, 0, null, this), this.lineJoin = F.lj, this._isAnimated = this.amount.effectsSequence.length !== 0 }, OffsetPathModifier.prototype.processPath = function (z, F, G, Y) { var X = shapePool.newElement(); X.c = z.c; var K = z.length(); z.c || (K -= 1); var J, Z, Q, ee = []; for (J = 0; J < K; J += 1)Q = PolynomialBezier.shapeSegment(z, J), ee.push(offsetSegmentSplit(Q, F)); if (!z.c) for (J = K - 1; J >= 0; J -= 1)Q = PolynomialBezier.shapeSegmentInverted(z, J), ee.push(offsetSegmentSplit(Q, F)); ee = pruneIntersections(ee); var te = null, oe = null; for (J = 0; J < ee.length; J += 1) { var ie = ee[J]; for (oe && (te = joinLines(X, oe, ie[0], G, Y)), oe = ie[ie.length - 1], Z = 0; Z < ie.length; Z += 1)Q = ie[Z], te && pointEqual(Q.points[0], te) ? X.setXYAt(Q.points[1][0], Q.points[1][1], "o", X.length() - 1) : X.setTripleAt(Q.points[0][0], Q.points[0][1], Q.points[1][0], Q.points[1][1], Q.points[0][0], Q.points[0][1], X.length()), X.setTripleAt(Q.points[3][0], Q.points[3][1], Q.points[3][0], Q.points[3][1], Q.points[2][0], Q.points[2][1], X.length()), te = Q.points[3] } return ee.length && joinLines(X, oe, ee[0][0], G, Y), X }, OffsetPathModifier.prototype.processShapes = function (z) { var F, G, Y = this.shapes.length, X, K, J = this.amount.v, Z = this.miterLimit.v, Q = this.lineJoin; if (J !== 0) { var ee, te; for (G = 0; G < Y; G += 1) { if (ee = this.shapes[G], te = ee.localShapeCollection, !(!ee.shape._mdf && !this._mdf && !z)) for (te.releaseShapes(), ee.shape._mdf = !0, F = ee.shape.paths.shapes, K = ee.shape.paths._length, X = 0; X < K; X += 1)te.addShape(this.processPath(F[X], J, Q, Z)); ee.shape.paths = ee.localShapeCollection } } this.dynamicProperties.length || (this._mdf = !1) }; function getFontProperties(z) { for (var F = z.fStyle ? z.fStyle.split(" ") : [], G = "normal", Y = "normal", X = F.length, K, J = 0; J < X; J += 1)switch (K = F[J].toLowerCase(), K) { case "italic": Y = "italic"; break; case "bold": G = "700"; break; case "black": G = "900"; break; case "medium": G = "500"; break; case "regular": case "normal": G = "400"; break; case "light": case "thin": G = "200"; break }return { style: Y, weight: z.fWeight || G } } var FontManager = function () { var z = 5e3, F = { w: 0, size: 0, shapes: [], data: { shapes: [] } }, G = []; G = G.concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]); var Y = 127988, X = 917631, K = 917601, J = 917626, Z = 65039, Q = 8205, ee = 127462, te = 127487, oe = ["d83cdffb", "d83cdffc", "d83cdffd", "d83cdffe", "d83cdfff"]; function ie(ye) { var xe = ye.split(","), pe, de = xe.length, _e = []; for (pe = 0; pe < de; pe += 1)xe[pe] !== "sans-serif" && xe[pe] !== "monospace" && _e.push(xe[pe]); return _e.join(",") } function se(ye, xe) { var pe = createTag("span"); pe.setAttribute("aria-hidden", !0), pe.style.fontFamily = xe; var de = createTag("span"); de.innerText = "giItT1WQy@!-/#", pe.style.position = "absolute", pe.style.left = "-10000px", pe.style.top = "-10000px", pe.style.fontSize = "300px", pe.style.fontVariant = "normal", pe.style.fontStyle = "normal", pe.style.fontWeight = "normal", pe.style.letterSpacing = "0", pe.appendChild(de), document.body.appendChild(pe); var _e = de.offsetWidth; return de.style.fontFamily = ie(ye) + ", " + xe, { node: de, w: _e, parent: pe } } function ne() { var ye, xe = this.fonts.length, pe, de, _e = xe; for (ye = 0; ye < xe; ye += 1)this.fonts[ye].loaded ? _e -= 1 : this.fonts[ye].fOrigin === "n" || this.fonts[ye].origin === 0 ? this.fonts[ye].loaded = !0 : (pe = this.fonts[ye].monoCase.node, de = this.fonts[ye].monoCase.w, pe.offsetWidth !== de ? (_e -= 1, this.fonts[ye].loaded = !0) : (pe = this.fonts[ye].sansCase.node, de = this.fonts[ye].sansCase.w, pe.offsetWidth !== de && (_e -= 1, this.fonts[ye].loaded = !0)), this.fonts[ye].loaded && (this.fonts[ye].sansCase.parent.parentNode.removeChild(this.fonts[ye].sansCase.parent), this.fonts[ye].monoCase.parent.parentNode.removeChild(this.fonts[ye].monoCase.parent))); _e !== 0 && Date.now() - this.initTime < z ? setTimeout(this.checkLoadedFontsBinded, 20) : setTimeout(this.setIsLoadedBinded, 10) } function re(ye, xe) { var pe = document.body && xe ? "svg" : "canvas", de, _e = getFontProperties(ye); if (pe === "svg") { var be = createNS("text"); be.style.fontSize = "100px", be.setAttribute("font-family", ye.fFamily), be.setAttribute("font-style", _e.style), be.setAttribute("font-weight", _e.weight), be.textContent = "1", ye.fClass ? (be.style.fontFamily = "inherit", be.setAttribute("class", ye.fClass)) : be.style.fontFamily = ye.fFamily, xe.appendChild(be), de = be } else { var Ae = new OffscreenCanvas(500, 500).getContext("2d"); Ae.font = _e.style + " " + _e.weight + " 100px " + ye.fFamily, de = Ae } function $e(Fe) { return pe === "svg" ? (de.textContent = Fe, de.getComputedTextLength()) : de.measureText(Fe).width } return { measureText: $e } } function fe(ye, xe) { if (!ye) { this.isLoaded = !0; return } if (this.chars) { this.isLoaded = !0, this.fonts = ye.list; return } if (!document.body) { this.isLoaded = !0, ye.list.forEach(function (Ze) { Ze.helper = re(Ze), Ze.cache = {} }), this.fonts = ye.list; return } var pe = ye.list, de, _e = pe.length, be = _e; for (de = 0; de < _e; de += 1) { var Ae = !0, $e, Fe; if (pe[de].loaded = !1, pe[de].monoCase = se(pe[de].fFamily, "monospace"), pe[de].sansCase = se(pe[de].fFamily, "sans-serif"), !pe[de].fPath) pe[de].loaded = !0, be -= 1; else if (pe[de].fOrigin === "p" || pe[de].origin === 3) { if ($e = document.querySelectorAll('style[f-forigin="p"][f-family="' + pe[de].fFamily + '"], style[f-origin="3"][f-family="' + pe[de].fFamily + '"]'), $e.length > 0 && (Ae = !1), Ae) { var Ie = createTag("style"); Ie.setAttribute("f-forigin", pe[de].fOrigin), Ie.setAttribute("f-origin", pe[de].origin), Ie.setAttribute("f-family", pe[de].fFamily), Ie.type = "text/css", Ie.innerText = "@font-face {font-family: " + pe[de].fFamily + "; font-style: normal; src: url('" + pe[de].fPath + "');}", xe.appendChild(Ie) } } else if (pe[de].fOrigin === "g" || pe[de].origin === 1) { for ($e = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]'), Fe = 0; Fe < $e.length; Fe += 1)$e[Fe].href.indexOf(pe[de].fPath) !== -1 && (Ae = !1); if (Ae) { var Be = createTag("link"); Be.setAttribute("f-forigin", pe[de].fOrigin), Be.setAttribute("f-origin", pe[de].origin), Be.type = "text/css", Be.rel = "stylesheet", Be.href = pe[de].fPath, document.body.appendChild(Be) } } else if (pe[de].fOrigin === "t" || pe[de].origin === 2) { for ($e = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]'), Fe = 0; Fe < $e.length; Fe += 1)pe[de].fPath === $e[Fe].src && (Ae = !1); if (Ae) { var Ve = createTag("link"); Ve.setAttribute("f-forigin", pe[de].fOrigin), Ve.setAttribute("f-origin", pe[de].origin), Ve.setAttribute("rel", "stylesheet"), Ve.setAttribute("href", pe[de].fPath), xe.appendChild(Ve) } } pe[de].helper = re(pe[de], xe), pe[de].cache = {}, this.fonts.push(pe[de]) } be === 0 ? this.isLoaded = !0 : setTimeout(this.checkLoadedFonts.bind(this), 100) } function ae(ye) { if (ye) { this.chars || (this.chars = []); var xe, pe = ye.length, de, _e = this.chars.length, be; for (xe = 0; xe < pe; xe += 1) { for (de = 0, be = !1; de < _e;)this.chars[de].style === ye[xe].style && this.chars[de].fFamily === ye[xe].fFamily && this.chars[de].ch === ye[xe].ch && (be = !0), de += 1; be || (this.chars.push(ye[xe]), _e += 1) } } } function he(ye, xe, pe) { for (var de = 0, _e = this.chars.length; de < _e;) { if (this.chars[de].ch === ye && this.chars[de].style === xe && this.chars[de].fFamily === pe) return this.chars[de]; de += 1 } return (typeof ye == "string" && ye.charCodeAt(0) !== 13 || !ye) && console && console.warn && !this._warned && (this._warned = !0, console.warn("Missing character from exported characters list: ", ye, xe, pe)), F } function le(ye, xe, pe) { var de = this.getFontByName(xe), _e = ye; if (!de.cache[_e]) { var be = de.helper; if (ye === " ") { var Ae = be.measureText("|" + ye + "|"), $e = be.measureText("||"); de.cache[_e] = (Ae - $e) / 100 } else de.cache[_e] = be.measureText(ye) / 100 } return de.cache[_e] * pe } function ce(ye) { for (var xe = 0, pe = this.fonts.length; xe < pe;) { if (this.fonts[xe].fName === ye) return this.fonts[xe]; xe += 1 } return this.fonts[0] } function ue(ye) { var xe = 0, pe = ye.charCodeAt(0); if (pe >= 55296 && pe <= 56319) { var de = ye.charCodeAt(1); de >= 56320 && de <= 57343 && (xe = (pe - 55296) * 1024 + de - 56320 + 65536) } return xe } function me(ye, xe) { var pe = ye.toString(16) + xe.toString(16); return oe.indexOf(pe) !== -1 } function ge(ye) { return ye === Q } function ve(ye) { return ye === Z } function Se(ye) { var xe = ue(ye); return xe >= ee && xe <= te } function ke(ye) { return Se(ye.substr(0, 2)) && Se(ye.substr(2, 2)) } function Ce(ye) { return G.indexOf(ye) !== -1 } function Ee(ye, xe) { var pe = ue(ye.substr(xe, 2)); if (pe !== Y) return !1; var de = 0; for (xe += 2; de < 5;) { if (pe = ue(ye.substr(xe, 2)), pe < K || pe > J) return !1; de += 1, xe += 2 } return ue(ye.substr(xe, 2)) === X } function De() { this.isLoaded = !0 } var Pe = function () { this.fonts = [], this.chars = null, this.typekitLoaded = 0, this.isLoaded = !1, this._warned = !1, this.initTime = Date.now(), this.setIsLoadedBinded = this.setIsLoaded.bind(this), this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this) }; Pe.isModifier = me, Pe.isZeroWidthJoiner = ge, Pe.isFlagEmoji = ke, Pe.isRegionalCode = Se, Pe.isCombinedCharacter = Ce, Pe.isRegionalFlag = Ee, Pe.isVariationSelector = ve, Pe.BLACK_FLAG_CODE_POINT = Y; var Te = { addChars: ae, addFonts: fe, getCharData: he, getFontByName: ce, measureText: le, checkLoadedFonts: ne, setIsLoaded: De }; return Pe.prototype = Te, Pe }(); function SlotManager(z) { this.animationData = z } SlotManager.prototype.getProp = function (z) { return this.animationData.slots && this.animationData.slots[z.sid] ? Object.assign(z, this.animationData.slots[z.sid].p) : z }; function slotFactory(z) { return new SlotManager(z) } function RenderableElement() { } RenderableElement.prototype = { initRenderable: function () { this.isInRange = !1, this.hidden = !1, this.isTransparent = !1, this.renderableComponents = [] }, addRenderableComponent: function (F) { this.renderableComponents.indexOf(F) === -1 && this.renderableComponents.push(F) }, removeRenderableComponent: function (F) { this.renderableComponents.indexOf(F) !== -1 && this.renderableComponents.splice(this.renderableComponents.indexOf(F), 1) }, prepareRenderableFrame: function (F) { this.checkLayerLimits(F) }, checkTransparency: function () { this.finalTransform.mProp.o.v <= 0 ? !this.isTransparent && this.globalData.renderConfig.hideOnTransparent && (this.isTransparent = !0, this.hide()) : this.isTransparent && (this.isTransparent = !1, this.show()) }, checkLayerLimits: function (F) { this.data.ip - this.data.st <= F && this.data.op - this.data.st > F ? this.isInRange !== !0 && (this.globalData._mdf = !0, this._mdf = !0, this.isInRange = !0, this.show()) : this.isInRange !== !1 && (this.globalData._mdf = !0, this.isInRange = !1, this.hide()) }, renderRenderable: function () { var F, G = this.renderableComponents.length; for (F = 0; F < G; F += 1)this.renderableComponents[F].renderFrame(this._isFirstFrame) }, sourceRectAtTime: function () { return { top: 0, left: 0, width: 100, height: 100 } }, getLayerSize: function () { return this.data.ty === 5 ? { w: this.data.textData.width, h: this.data.textData.height } : { w: this.data.width, h: this.data.height } } }; var getBlendMode = function () { var z = { 0: "source-over", 1: "multiply", 2: "screen", 3: "overlay", 4: "darken", 5: "lighten", 6: "color-dodge", 7: "color-burn", 8: "hard-light", 9: "soft-light", 10: "difference", 11: "exclusion", 12: "hue", 13: "saturation", 14: "color", 15: "luminosity" }; return function (F) { return z[F] || "" } }(); function SliderEffect(z, F, G) { this.p = PropertyFactory.getProp(F, z.v, 0, 0, G) } function AngleEffect(z, F, G) { this.p = PropertyFactory.getProp(F, z.v, 0, 0, G) } function ColorEffect(z, F, G) { this.p = PropertyFactory.getProp(F, z.v, 1, 0, G) } function PointEffect(z, F, G) { this.p = PropertyFactory.getProp(F, z.v, 1, 0, G) } function LayerIndexEffect(z, F, G) { this.p = PropertyFactory.getProp(F, z.v, 0, 0, G) } function MaskIndexEffect(z, F, G) { this.p = PropertyFactory.getProp(F, z.v, 0, 0, G) } function CheckboxEffect(z, F, G) { this.p = PropertyFactory.getProp(F, z.v, 0, 0, G) } function NoValueEffect() { this.p = {} } function EffectsManager(z, F) { var G = z.ef || []; this.effectElements = []; var Y, X = G.length, K; for (Y = 0; Y < X; Y += 1)K = new GroupEffect(G[Y], F), this.effectElements.push(K) } function GroupEffect(z, F) { this.init(z, F) } extendPrototype([DynamicPropertyContainer], GroupEffect), GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties, GroupEffect.prototype.init = function (z, F) { this.data = z, this.effectElements = [], this.initDynamicPropertyContainer(F); var G, Y = this.data.ef.length, X, K = this.data.ef; for (G = 0; G < Y; G += 1) { switch (X = null, K[G].ty) { case 0: X = new SliderEffect(K[G], F, this); break; case 1: X = new AngleEffect(K[G], F, this); break; case 2: X = new ColorEffect(K[G], F, this); break; case 3: X = new PointEffect(K[G], F, this); break; case 4: case 7: X = new CheckboxEffect(K[G], F, this); break; case 10: X = new LayerIndexEffect(K[G], F, this); break; case 11: X = new MaskIndexEffect(K[G], F, this); break; case 5: X = new EffectsManager(K[G], F); break; default: X = new NoValueEffect(K[G]); break }X && this.effectElements.push(X) } }; function BaseElement() { } BaseElement.prototype = { checkMasks: function () { if (!this.data.hasMask) return !1; for (var F = 0, G = this.data.masksProperties.length; F < G;) { if (this.data.masksProperties[F].mode !== "n" && this.data.masksProperties[F].cl !== !1) return !0; F += 1 } return !1 }, initExpressions: function () { var F = getExpressionInterfaces(); if (F) { var G = F("layer"), Y = F("effects"), X = F("shape"), K = F("text"), J = F("comp"); this.layerInterface = G(this), this.data.hasMask && this.maskManager && this.layerInterface.registerMaskInterface(this.maskManager); var Z = Y.createEffectsInterface(this, this.layerInterface); this.layerInterface.registerEffectsInterface(Z), this.data.ty === 0 || this.data.xt ? this.compInterface = J(this) : this.data.ty === 4 ? (this.layerInterface.shapeInterface = X(this.shapesData, this.itemsData, this.layerInterface), this.layerInterface.content = this.layerInterface.shapeInterface) : this.data.ty === 5 && (this.layerInterface.textInterface = K(this), this.layerInterface.text = this.layerInterface.textInterface) } }, setBlendMode: function () { var F = getBlendMode(this.data.bm), G = this.baseElement || this.layerElement; G.style["mix-blend-mode"] = F }, initBaseData: function (F, G, Y) { this.globalData = G, this.comp = Y, this.data = F, this.layerId = createElementID(), this.data.sr || (this.data.sr = 1), this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties) }, getType: function () { return this.type }, sourceRectAtTime: function () { } }; function FrameElement() { } FrameElement.prototype = { initFrame: function () { this._isFirstFrame = !1, this.dynamicProperties = [], this._mdf = !1 }, prepareProperties: function (F, G) { var Y, X = this.dynamicProperties.length; for (Y = 0; Y < X; Y += 1)(G || this._isParent && this.dynamicProperties[Y].propType === "transform") && (this.dynamicProperties[Y].getValue(), this.dynamicProperties[Y]._mdf && (this.globalData._mdf = !0, this._mdf = !0)) }, addDynamicProperty: function (F) { this.dynamicProperties.indexOf(F) === -1 && this.dynamicProperties.push(F) } }; function FootageElement(z, F, G) { this.initFrame(), this.initRenderable(), this.assetData = F.getAssetData(z.refId), this.footageData = F.imageLoader.getAsset(this.assetData), this.initBaseData(z, F, G) } FootageElement.prototype.prepareFrame = function () { }, extendPrototype([RenderableElement, BaseElement, FrameElement], FootageElement), FootageElement.prototype.getBaseElement = function () { return null }, FootageElement.prototype.renderFrame = function () { }, FootageElement.prototype.destroy = function () { }, FootageElement.prototype.initExpressions = function () { var z = getExpressionInterfaces(); if (z) { var F = z("footage"); this.layerInterface = F(this) } }, FootageElement.prototype.getFootageData = function () { return this.footageData }; function AudioElement(z, F, G) { this.initFrame(), this.initRenderable(), this.assetData = F.getAssetData(z.refId), this.initBaseData(z, F, G), this._isPlaying = !1, this._canPlay = !1; var Y = this.globalData.getAssetsPath(this.assetData); this.audio = this.globalData.audioController.createAudio(Y), this._currentTime = 0, this.globalData.audioController.addAudio(this), this._volumeMultiplier = 1, this._volume = 1, this._previousVolume = null, this.tm = z.tm ? PropertyFactory.getProp(this, z.tm, 0, F.frameRate, this) : { _placeholder: !0 }, this.lv = PropertyFactory.getProp(this, z.au && z.au.lv ? z.au.lv : { k: [100] }, 1, .01, this) } AudioElement.prototype.prepareFrame = function (z) { if (this.prepareRenderableFrame(z, !0), this.prepareProperties(z, !0), this.tm._placeholder) this._currentTime = z / this.data.sr; else { var F = this.tm.v; this._currentTime = F } this._volume = this.lv.v[0]; var G = this._volume * this._volumeMultiplier; this._previousVolume !== G && (this._previousVolume = G, this.audio.volume(G)) }, extendPrototype([RenderableElement, BaseElement, FrameElement], AudioElement), AudioElement.prototype.renderFrame = function () { this.isInRange && this._canPlay && (this._isPlaying ? (!this.audio.playing() || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > .1) && this.audio.seek(this._currentTime / this.globalData.frameRate) : (this.audio.play(), this.audio.seek(this._currentTime / this.globalData.frameRate), this._isPlaying = !0)) }, AudioElement.prototype.show = function () { }, AudioElement.prototype.hide = function () { this.audio.pause(), this._isPlaying = !1 }, AudioElement.prototype.pause = function () { this.audio.pause(), this._isPlaying = !1, this._canPlay = !1 }, AudioElement.prototype.resume = function () { this._canPlay = !0 }, AudioElement.prototype.setRate = function (z) { this.audio.rate(z) }, AudioElement.prototype.volume = function (z) { this._volumeMultiplier = z, this._previousVolume = z * this._volume, this.audio.volume(this._previousVolume) }, AudioElement.prototype.getBaseElement = function () { return null }, AudioElement.prototype.destroy = function () { }, AudioElement.prototype.sourceRectAtTime = function () { }, AudioElement.prototype.initExpressions = function () { }; function BaseRenderer() { } BaseRenderer.prototype.checkLayers = function (z) { var F, G = this.layers.length, Y; for (this.completeLayers = !0, F = G - 1; F >= 0; F -= 1)this.elements[F] || (Y = this.layers[F], Y.ip - Y.st <= z - this.layers[F].st && Y.op - Y.st > z - this.layers[F].st && this.buildItem(F)), this.completeLayers = this.elements[F] ? this.completeLayers : !1; this.checkPendingElements() }, BaseRenderer.prototype.createItem = function (z) { switch (z.ty) { case 2: return this.createImage(z); case 0: return this.createComp(z); case 1: return this.createSolid(z); case 3: return this.createNull(z); case 4: return this.createShape(z); case 5: return this.createText(z); case 6: return this.createAudio(z); case 13: return this.createCamera(z); case 15: return this.createFootage(z); default: return this.createNull(z) } }, BaseRenderer.prototype.createCamera = function () { throw new Error("You're using a 3d camera. Try the html renderer.") }, BaseRenderer.prototype.createAudio = function (z) { return new AudioElement(z, this.globalData, this) }, BaseRenderer.prototype.createFootage = function (z) { return new FootageElement(z, this.globalData, this) }, BaseRenderer.prototype.buildAllItems = function () { var z, F = this.layers.length; for (z = 0; z < F; z += 1)this.buildItem(z); this.checkPendingElements() }, BaseRenderer.prototype.includeLayers = function (z) { this.completeLayers = !1; var F, G = z.length, Y, X = this.layers.length; for (F = 0; F < G; F += 1)for (Y = 0; Y < X;) { if (this.layers[Y].id === z[F].id) { this.layers[Y] = z[F]; break } Y += 1 } }, BaseRenderer.prototype.setProjectInterface = function (z) { this.globalData.projectInterface = z }, BaseRenderer.prototype.initItems = function () { this.globalData.progressiveLoad || this.buildAllItems() }, BaseRenderer.prototype.buildElementParenting = function (z, F, G) { for (var Y = this.elements, X = this.layers, K = 0, J = X.length; K < J;)X[K].ind == F && (!Y[K] || Y[K] === !0 ? (this.buildItem(K), this.addPendingElement(z)) : (G.push(Y[K]), Y[K].setAsParent(), X[K].parent !== void 0 ? this.buildElementParenting(z, X[K].parent, G) : z.setHierarchy(G))), K += 1 }, BaseRenderer.prototype.addPendingElement = function (z) { this.pendingElements.push(z) }, BaseRenderer.prototype.searchExtraCompositions = function (z) { var F, G = z.length; for (F = 0; F < G; F += 1)if (z[F].xt) { var Y = this.createComp(z[F]); Y.initExpressions(), this.globalData.projectInterface.registerComposition(Y) } }, BaseRenderer.prototype.getElementById = function (z) { var F, G = this.elements.length; for (F = 0; F < G; F += 1)if (this.elements[F].data.ind === z) return this.elements[F]; return null }, BaseRenderer.prototype.getElementByPath = function (z) { var F = z.shift(), G; if (typeof F == "number") G = this.elements[F]; else { var Y, X = this.elements.length; for (Y = 0; Y < X; Y += 1)if (this.elements[Y].data.nm === F) { G = this.elements[Y]; break } } return z.length === 0 ? G : G.getElementByPath(z) }, BaseRenderer.prototype.setupGlobalData = function (z, F) { this.globalData.fontManager = new FontManager, this.globalData.slotManager = slotFactory(z), this.globalData.fontManager.addChars(z.chars), this.globalData.fontManager.addFonts(z.fonts, F), this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem), this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem), this.globalData.imageLoader = this.animationItem.imagePreloader, this.globalData.audioController = this.animationItem.audioController, this.globalData.frameId = 0, this.globalData.frameRate = z.fr, this.globalData.nm = z.nm, this.globalData.compSize = { w: z.w, h: z.h } }; var effectTypes = { TRANSFORM_EFFECT: "transformEFfect" }; function TransformElement() { } TransformElement.prototype = { initTransform: function () { var F = new Matrix; this.finalTransform = { mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : { o: 0 }, _matMdf: !1, _localMatMdf: !1, _opMdf: !1, mat: F, localMat: F, localOpacity: 1 }, this.data.ao && (this.finalTransform.mProp.autoOriented = !0), this.data.ty }, renderTransform: function () { if (this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame, this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame, this.hierarchy) { var F, G = this.finalTransform.mat, Y = 0, X = this.hierarchy.length; if (!this.finalTransform._matMdf) for (; Y < X;) { if (this.hierarchy[Y].finalTransform.mProp._mdf) { this.finalTransform._matMdf = !0; break } Y += 1 } if (this.finalTransform._matMdf) for (F = this.finalTransform.mProp.v.props, G.cloneFromProps(F), Y = 0; Y < X; Y += 1)G.multiply(this.hierarchy[Y].finalTransform.mProp.v) } this.finalTransform._matMdf && (this.finalTransform._localMatMdf = this.finalTransform._matMdf), this.finalTransform._opMdf && (this.finalTransform.localOpacity = this.finalTransform.mProp.o.v) }, renderLocalTransform: function () { if (this.localTransforms) { var F = 0, G = this.localTransforms.length; if (this.finalTransform._localMatMdf = this.finalTransform._matMdf, !this.finalTransform._localMatMdf || !this.finalTransform._opMdf) for (; F < G;)this.localTransforms[F]._mdf && (this.finalTransform._localMatMdf = !0), this.localTransforms[F]._opMdf && !this.finalTransform._opMdf && (this.finalTransform.localOpacity = this.finalTransform.mProp.o.v, this.finalTransform._opMdf = !0), F += 1; if (this.finalTransform._localMatMdf) { var Y = this.finalTransform.localMat; for (this.localTransforms[0].matrix.clone(Y), F = 1; F < G; F += 1) { var X = this.localTransforms[F].matrix; Y.multiply(X) } Y.multiply(this.finalTransform.mat) } if (this.finalTransform._opMdf) { var K = this.finalTransform.localOpacity; for (F = 0; F < G; F += 1)K *= this.localTransforms[F].opacity * .01; this.finalTransform.localOpacity = K } } }, searchEffectTransforms: function () { if (this.renderableEffectsManager) { var F = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT); if (F.length) { this.localTransforms = [], this.finalTransform.localMat = new Matrix; var G = 0, Y = F.length; for (G = 0; G < Y; G += 1)this.localTransforms.push(F[G]) } } }, globalToLocal: function (F) { var G = []; G.push(this.finalTransform); for (var Y = !0, X = this.comp; Y;)X.finalTransform ? (X.data.hasMask && G.splice(0, 0, X.finalTransform), X = X.comp) : Y = !1; var K, J = G.length, Z; for (K = 0; K < J; K += 1)Z = G[K].mat.applyToPointArray(0, 0, 0), F = [F[0] - Z[0], F[1] - Z[1], 0]; return F }, mHelper: new Matrix }; function MaskElement(z, F, G) { this.data = z, this.element = F, this.globalData = G, this.storedData = [], this.masksProperties = this.data.masksProperties || [], this.maskElement = null; var Y = this.globalData.defs, X, K = this.masksProperties ? this.masksProperties.length : 0; this.viewData = createSizedArray(K), this.solidPath = ""; var J, Z = this.masksProperties, Q = 0, ee = [], te, oe, ie = createElementID(), se, ne, re, fe, ae = "clipPath", he = "clip-path"; for (X = 0; X < K; X += 1)if ((Z[X].mode !== "a" && Z[X].mode !== "n" || Z[X].inv || Z[X].o.k !== 100 || Z[X].o.x) && (ae = "mask", he = "mask"), (Z[X].mode === "s" || Z[X].mode === "i") && Q === 0 ? (se = createNS("rect"), se.setAttribute("fill", "#ffffff"), se.setAttribute("width", this.element.comp.data.w || 0), se.setAttribute("height", this.element.comp.data.h || 0), ee.push(se)) : se = null, J = createNS("path"), Z[X].mode === "n") this.viewData[X] = { op: PropertyFactory.getProp(this.element, Z[X].o, 0, .01, this.element), prop: ShapePropertyFactory.getShapeProp(this.element, Z[X], 3), elem: J, lastPath: "" }, Y.appendChild(J); else { Q += 1, J.setAttribute("fill", Z[X].mode === "s" ? "#000000" : "#ffffff"), J.setAttribute("clip-rule", "nonzero"); var le; if (Z[X].x.k !== 0 ? (ae = "mask", he = "mask", fe = PropertyFactory.getProp(this.element, Z[X].x, 0, null, this.element), le = createElementID(), ne = createNS("filter"), ne.setAttribute("id", le), re = createNS("feMorphology"), re.setAttribute("operator", "erode"), re.setAttribute("in", "SourceGraphic"), re.setAttribute("radius", "0"), ne.appendChild(re), Y.appendChild(ne), J.setAttribute("stroke", Z[X].mode === "s" ? "#000000" : "#ffffff")) : (re = null, fe = null), this.storedData[X] = { elem: J, x: fe, expan: re, lastPath: "", lastOperator: "", filterId: le, lastRadius: 0 }, Z[X].mode === "i") { oe = ee.length; var ce = createNS("g"); for (te = 0; te < oe; te += 1)ce.appendChild(ee[te]); var ue = createNS("mask"); ue.setAttribute("mask-type", "alpha"), ue.setAttribute("id", ie + "_" + Q), ue.appendChild(J), Y.appendChild(ue), ce.setAttribute("mask", "url(" + getLocationHref() + "#" + ie + "_" + Q + ")"), ee.length = 0, ee.push(ce) } else ee.push(J); Z[X].inv && !this.solidPath && (this.solidPath = this.createLayerSolidPath()), this.viewData[X] = { elem: J, lastPath: "", op: PropertyFactory.getProp(this.element, Z[X].o, 0, .01, this.element), prop: ShapePropertyFactory.getShapeProp(this.element, Z[X], 3), invRect: se }, this.viewData[X].prop.k || this.drawPath(Z[X], this.viewData[X].prop.v, this.viewData[X]) } for (this.maskElement = createNS(ae), K = ee.length, X = 0; X < K; X += 1)this.maskElement.appendChild(ee[X]); Q > 0 && (this.maskElement.setAttribute("id", ie), this.element.maskedElement.setAttribute(he, "url(" + getLocationHref() + "#" + ie + ")"), Y.appendChild(this.maskElement)), this.viewData.length && this.element.addRenderableComponent(this) } MaskElement.prototype.getMaskProperty = function (z) { return this.viewData[z].prop }, MaskElement.prototype.renderFrame = function (z) { var F = this.element.finalTransform.mat, G, Y = this.masksProperties.length; for (G = 0; G < Y; G += 1)if ((this.viewData[G].prop._mdf || z) && this.drawPath(this.masksProperties[G], this.viewData[G].prop.v, this.viewData[G]), (this.viewData[G].op._mdf || z) && this.viewData[G].elem.setAttribute("fill-opacity", this.viewData[G].op.v), this.masksProperties[G].mode !== "n" && (this.viewData[G].invRect && (this.element.finalTransform.mProp._mdf || z) && this.viewData[G].invRect.setAttribute("transform", F.getInverseMatrix().to2dCSS()), this.storedData[G].x && (this.storedData[G].x._mdf || z))) { var X = this.storedData[G].expan; this.storedData[G].x.v < 0 ? (this.storedData[G].lastOperator !== "erode" && (this.storedData[G].lastOperator = "erode", this.storedData[G].elem.setAttribute("filter", "url(" + getLocationHref() + "#" + this.storedData[G].filterId + ")")), X.setAttribute("radius", -this.storedData[G].x.v)) : (this.storedData[G].lastOperator !== "dilate" && (this.storedData[G].lastOperator = "dilate", this.storedData[G].elem.setAttribute("filter", null)), this.storedData[G].elem.setAttribute("stroke-width", this.storedData[G].x.v * 2)) } }, MaskElement.prototype.getMaskelement = function () { return this.maskElement }, MaskElement.prototype.createLayerSolidPath = function () { var z = "M0,0 "; return z += " h" + this.globalData.compSize.w, z += " v" + this.globalData.compSize.h, z += " h-" + this.globalData.compSize.w, z += " v-" + this.globalData.compSize.h + " ", z }, MaskElement.prototype.drawPath = function (z, F, G) { var Y = " M" + F.v[0][0] + "," + F.v[0][1], X, K; for (K = F._length, X = 1; X < K; X += 1)Y += " C" + F.o[X - 1][0] + "," + F.o[X - 1][1] + " " + F.i[X][0] + "," + F.i[X][1] + " " + F.v[X][0] + "," + F.v[X][1]; if (F.c && K > 1 && (Y += " C" + F.o[X - 1][0] + "," + F.o[X - 1][1] + " " + F.i[0][0] + "," + F.i[0][1] + " " + F.v[0][0] + "," + F.v[0][1]), G.lastPath !== Y) { var J = ""; G.elem && (F.c && (J = z.inv ? this.solidPath + Y : Y), G.elem.setAttribute("d", J)), G.lastPath = Y } }, MaskElement.prototype.destroy = function () { this.element = null, this.globalData = null, this.maskElement = null, this.data = null, this.masksProperties = null }; var filtersFactory = function () { var z = {}; z.createFilter = F, z.createAlphaToLuminanceFilter = G; function F(Y, X) { var K = createNS("filter"); return K.setAttribute("id", Y), X !== !0 && (K.setAttribute("filterUnits", "objectBoundingBox"), K.setAttribute("x", "0%"), K.setAttribute("y", "0%"), K.setAttribute("width", "100%"), K.setAttribute("height", "100%")), K } function G() { var Y = createNS("feColorMatrix"); return Y.setAttribute("type", "matrix"), Y.setAttribute("color-interpolation-filters", "sRGB"), Y.setAttribute("values", "0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1"), Y } return z }(), featureSupport = function () { var z = { maskType: !0, svgLumaHidden: !0, offscreenCanvas: typeof OffscreenCanvas < "u" }; return (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) && (z.maskType = !1), /firefox/i.test(navigator.userAgent) && (z.svgLumaHidden = !1), z }(), registeredEffects$1 = {}, idPrefix = "filter_result_"; function SVGEffects(z) { var F, G = "SourceGraphic", Y = z.data.ef ? z.data.ef.length : 0, X = createElementID(), K = filtersFactory.createFilter(X, !0), J = 0; this.filters = []; var Z; for (F = 0; F < Y; F += 1) { Z = null; var Q = z.data.ef[F].ty; if (registeredEffects$1[Q]) { var ee = registeredEffects$1[Q].effect; Z = new ee(K, z.effectsManager.effectElements[F], z, idPrefix + J, G), G = idPrefix + J, registeredEffects$1[Q].countsAsEffect && (J += 1) } Z && this.filters.push(Z) } J && (z.globalData.defs.appendChild(K), z.layerElement.setAttribute("filter", "url(" + getLocationHref() + "#" + X + ")")), this.filters.length && z.addRenderableComponent(this) } SVGEffects.prototype.renderFrame = function (z) { var F, G = this.filters.length; for (F = 0; F < G; F += 1)this.filters[F].renderFrame(z) }, SVGEffects.prototype.getEffects = function (z) { var F, G = this.filters.length, Y = []; for (F = 0; F < G; F += 1)this.filters[F].type === z && Y.push(this.filters[F]); return Y }; function registerEffect$1(z, F, G) { registeredEffects$1[z] = { effect: F, countsAsEffect: G } } function SVGBaseElement() { } SVGBaseElement.prototype = { initRendererElement: function () { this.layerElement = createNS("g") }, createContainerElements: function () { this.matteElement = createNS("g"), this.transformedElement = this.layerElement, this.maskedElement = this.layerElement, this._sizeChanged = !1; var F = null; if (this.data.td) { this.matteMasks = {}; var G = createNS("g"); G.setAttribute("id", this.layerId), G.appendChild(this.layerElement), F = G, this.globalData.defs.appendChild(G) } else this.data.tt ? (this.matteElement.appendChild(this.layerElement), F = this.matteElement, this.baseElement = this.matteElement) : this.baseElement = this.layerElement; if (this.data.ln && this.layerElement.setAttribute("id", this.data.ln), this.data.cl && this.layerElement.setAttribute("class", this.data.cl), this.data.ty === 0 && !this.data.hd) { var Y = createNS("clipPath"), X = createNS("path"); X.setAttribute("d", "M0,0 L" + this.data.w + ",0 L" + this.data.w + "," + this.data.h + " L0," + this.data.h + "z"); var K = createElementID(); if (Y.setAttribute("id", K), Y.appendChild(X), this.globalData.defs.appendChild(Y), this.checkMasks()) { var J = createNS("g"); J.setAttribute("clip-path", "url(" + getLocationHref() + "#" + K + ")"), J.appendChild(this.layerElement), this.transformedElement = J, F ? F.appendChild(this.transformedElement) : this.baseElement = this.transformedElement } else this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + K + ")") } this.data.bm !== 0 && this.setBlendMode() }, renderElement: function () { this.finalTransform._localMatMdf && this.transformedElement.setAttribute("transform", this.finalTransform.localMat.to2dCSS()), this.finalTransform._opMdf && this.transformedElement.setAttribute("opacity", this.finalTransform.localOpacity) }, destroyBaseElement: function () { this.layerElement = null, this.matteElement = null, this.maskManager.destroy() }, getBaseElement: function () { return this.data.hd ? null : this.baseElement }, createRenderableComponents: function () { this.maskManager = new MaskElement(this.data, this, this.globalData), this.renderableEffectsManager = new SVGEffects(this), this.searchEffectTransforms() }, getMatte: function (F) { if (this.matteMasks || (this.matteMasks = {}), !this.matteMasks[F]) { var G = this.layerId + "_" + F, Y, X, K, J; if (F === 1 || F === 3) { var Z = createNS("mask"); Z.setAttribute("id", G), Z.setAttribute("mask-type", F === 3 ? "luminance" : "alpha"), K = createNS("use"), K.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId), Z.appendChild(K), this.globalData.defs.appendChild(Z), !featureSupport.maskType && F === 1 && (Z.setAttribute("mask-type", "luminance"), Y = createElementID(), X = filtersFactory.createFilter(Y), this.globalData.defs.appendChild(X), X.appendChild(filtersFactory.createAlphaToLuminanceFilter()), J = createNS("g"), J.appendChild(K), Z.appendChild(J), J.setAttribute("filter", "url(" + getLocationHref() + "#" + Y + ")")) } else if (F === 2) { var Q = createNS("mask"); Q.setAttribute("id", G), Q.setAttribute("mask-type", "alpha"); var ee = createNS("g"); Q.appendChild(ee), Y = createElementID(), X = filtersFactory.createFilter(Y); var te = createNS("feComponentTransfer"); te.setAttribute("in", "SourceGraphic"), X.appendChild(te); var oe = createNS("feFuncA"); oe.setAttribute("type", "table"), oe.setAttribute("tableValues", "1.0 0.0"), te.appendChild(oe), this.globalData.defs.appendChild(X); var ie = createNS("rect"); ie.setAttribute("width", this.comp.data.w), ie.setAttribute("height", this.comp.data.h), ie.setAttribute("x", "0"), ie.setAttribute("y", "0"), ie.setAttribute("fill", "#ffffff"), ie.setAttribute("opacity", "0"), ee.setAttribute("filter", "url(" + getLocationHref() + "#" + Y + ")"), ee.appendChild(ie), K = createNS("use"), K.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId), ee.appendChild(K), featureSupport.maskType || (Q.setAttribute("mask-type", "luminance"), X.appendChild(filtersFactory.createAlphaToLuminanceFilter()), J = createNS("g"), ee.appendChild(ie), J.appendChild(this.layerElement), ee.appendChild(J)), this.globalData.defs.appendChild(Q) } this.matteMasks[F] = G } return this.matteMasks[F] }, setMatte: function (F) { this.matteElement && this.matteElement.setAttribute("mask", "url(" + getLocationHref() + "#" + F + ")") } }; function HierarchyElement() { } HierarchyElement.prototype = { initHierarchy: function () { this.hierarchy = [], this._isParent = !1, this.checkParenting() }, setHierarchy: function (F) { this.hierarchy = F }, setAsParent: function () { this._isParent = !0 }, checkParenting: function () { this.data.parent !== void 0 && this.comp.buildElementParenting(this, this.data.parent, []) } }; function RenderableDOMElement() { } (function () { var z = { initElement: function (G, Y, X) { this.initFrame(), this.initBaseData(G, Y, X), this.initTransform(G, Y, X), this.initHierarchy(), this.initRenderable(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), this.createContent(), this.hide() }, hide: function () { if (!this.hidden && (!this.isInRange || this.isTransparent)) { var G = this.baseElement || this.layerElement; G.style.display = "none", this.hidden = !0 } }, show: function () { if (this.isInRange && !this.isTransparent) { if (!this.data.hd) { var G = this.baseElement || this.layerElement; G.style.display = "block" } this.hidden = !1, this._isFirstFrame = !0 } }, renderFrame: function () { this.data.hd || this.hidden || (this.renderTransform(), this.renderRenderable(), this.renderLocalTransform(), this.renderElement(), this.renderInnerContent(), this._isFirstFrame && (this._isFirstFrame = !1)) }, renderInnerContent: function () { }, prepareFrame: function (G) { this._mdf = !1, this.prepareRenderableFrame(G), this.prepareProperties(G, this.isInRange), this.checkTransparency() }, destroy: function () { this.innerElem = null, this.destroyBaseElement() } }; extendPrototype([RenderableElement, createProxyFunction(z)], RenderableDOMElement) })(); function IImageElement(z, F, G) { this.assetData = F.getAssetData(z.refId), this.assetData && this.assetData.sid && (this.assetData = F.slotManager.getProp(this.assetData)), this.initElement(z, F, G), this.sourceRect = { top: 0, left: 0, width: this.assetData.w, height: this.assetData.h } } extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], IImageElement), IImageElement.prototype.createContent = function () { var z = this.globalData.getAssetsPath(this.assetData); this.innerElem = createNS("image"), this.innerElem.setAttribute("width", this.assetData.w + "px"), this.innerElem.setAttribute("height", this.assetData.h + "px"), this.innerElem.setAttribute("preserveAspectRatio", this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio), this.innerElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", z), this.layerElement.appendChild(this.innerElem) }, IImageElement.prototype.sourceRectAtTime = function () { return this.sourceRect }; function ProcessedElement(z, F) { this.elem = z, this.pos = F } function IShapeElement() { } IShapeElement.prototype = { addShapeToModifiers: function (F) { var G, Y = this.shapeModifiers.length; for (G = 0; G < Y; G += 1)this.shapeModifiers[G].addShape(F) }, isShapeInAnimatedModifiers: function (F) { for (var G = 0, Y = this.shapeModifiers.length; G < Y;)if (this.shapeModifiers[G].isAnimatedWithShape(F)) return !0; return !1 }, renderModifiers: function () { if (this.shapeModifiers.length) { var F, G = this.shapes.length; for (F = 0; F < G; F += 1)this.shapes[F].sh.reset(); G = this.shapeModifiers.length; var Y; for (F = G - 1; F >= 0 && (Y = this.shapeModifiers[F].processShapes(this._isFirstFrame), !Y); F -= 1); } }, searchProcessedElement: function (F) { for (var G = this.processedElements, Y = 0, X = G.length; Y < X;) { if (G[Y].elem === F) return G[Y].pos; Y += 1 } return 0 }, addProcessedElement: function (F, G) { for (var Y = this.processedElements, X = Y.length; X;)if (X -= 1, Y[X].elem === F) { Y[X].pos = G; return } Y.push(new ProcessedElement(F, G)) }, prepareFrame: function (F) { this.prepareRenderableFrame(F), this.prepareProperties(F, this.isInRange) } }; var lineCapEnum = { 1: "butt", 2: "round", 3: "square" }, lineJoinEnum = { 1: "miter", 2: "round", 3: "bevel" }; function SVGShapeData(z, F, G) { this.caches = [], this.styles = [], this.transformers = z, this.lStr = "", this.sh = G, this.lvl = F, this._isAnimated = !!G.k; for (var Y = 0, X = z.length; Y < X;) { if (z[Y].mProps.dynamicProperties.length) { this._isAnimated = !0; break } Y += 1 } } SVGShapeData.prototype.setAsAnimated = function () { this._isAnimated = !0 }; function SVGStyleData(z, F) { this.data = z, this.type = z.ty, this.d = "", this.lvl = F, this._mdf = !1, this.closed = z.hd === !0, this.pElem = createNS("path"), this.msElem = null } SVGStyleData.prototype.reset = function () { this.d = "", this._mdf = !1 }; function DashProperty(z, F, G, Y) { this.elem = z, this.frameId = -1, this.dataProps = createSizedArray(F.length), this.renderer = G, this.k = !1, this.dashStr = "", this.dashArray = createTypedArray("float32", F.length ? F.length - 1 : 0), this.dashoffset = createTypedArray("float32", 1), this.initDynamicPropertyContainer(Y); var X, K = F.length || 0, J; for (X = 0; X < K; X += 1)J = PropertyFactory.getProp(z, F[X].v, 0, 0, this), this.k = J.k || this.k, this.dataProps[X] = { n: F[X].n, p: J }; this.k || this.getValue(!0), this._isAnimated = this.k } DashProperty.prototype.getValue = function (z) { if (!(this.elem.globalData.frameId === this.frameId && !z) && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf = this._mdf || z, this._mdf)) { var F = 0, G = this.dataProps.length; for (this.renderer === "svg" && (this.dashStr = ""), F = 0; F < G; F += 1)this.dataProps[F].n !== "o" ? this.renderer === "svg" ? this.dashStr += " " + this.dataProps[F].p.v : this.dashArray[F] = this.dataProps[F].p.v : this.dashoffset[0] = this.dataProps[F].p.v } }, extendPrototype([DynamicPropertyContainer], DashProperty); function SVGStrokeStyleData(z, F, G) { this.initDynamicPropertyContainer(z), this.getValue = this.iterateDynamicProperties, this.o = PropertyFactory.getProp(z, F.o, 0, .01, this), this.w = PropertyFactory.getProp(z, F.w, 0, null, this), this.d = new DashProperty(z, F.d || {}, "svg", this), this.c = PropertyFactory.getProp(z, F.c, 1, 255, this), this.style = G, this._isAnimated = !!this._isAnimated } extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData); function SVGFillStyleData(z, F, G) { this.initDynamicPropertyContainer(z), this.getValue = this.iterateDynamicProperties, this.o = PropertyFactory.getProp(z, F.o, 0, .01, this), this.c = PropertyFactory.getProp(z, F.c, 1, 255, this), this.style = G } extendPrototype([DynamicPropertyContainer], SVGFillStyleData); function SVGNoStyleData(z, F, G) { this.initDynamicPropertyContainer(z), this.getValue = this.iterateDynamicProperties, this.style = G } extendPrototype([DynamicPropertyContainer], SVGNoStyleData); function GradientProperty(z, F, G) { this.data = F, this.c = createTypedArray("uint8c", F.p * 4); var Y = F.k.k[0].s ? F.k.k[0].s.length - F.p * 4 : F.k.k.length - F.p * 4; this.o = createTypedArray("float32", Y), this._cmdf = !1, this._omdf = !1, this._collapsable = this.checkCollapsable(), this._hasOpacity = Y, this.initDynamicPropertyContainer(G), this.prop = PropertyFactory.getProp(z, F.k, 1, null, this), this.k = this.prop.k, this.getValue(!0) } GradientProperty.prototype.comparePoints = function (z, F) { for (var G = 0, Y = this.o.length / 2, X; G < Y;) { if (X = Math.abs(z[G * 4] - z[F * 4 + G * 2]), X > .01) return !1; G += 1 } return !0 }, GradientProperty.prototype.checkCollapsable = function () { if (this.o.length / 2 !== this.c.length / 4) return !1; if (this.data.k.k[0].s) for (var z = 0, F = this.data.k.k.length; z < F;) { if (!this.comparePoints(this.data.k.k[z].s, this.data.p)) return !1; z += 1 } else if (!this.comparePoints(this.data.k.k, this.data.p)) return !1; return !0 }, GradientProperty.prototype.getValue = function (z) { if (this.prop.getValue(), this._mdf = !1, this._cmdf = !1, this._omdf = !1, this.prop._mdf || z) { var F, G = this.data.p * 4, Y, X; for (F = 0; F < G; F += 1)Y = F % 4 === 0 ? 100 : 255, X = Math.round(this.prop.v[F] * Y), this.c[F] !== X && (this.c[F] = X, this._cmdf = !z); if (this.o.length) for (G = this.prop.v.length, F = this.data.p * 4; F < G; F += 1)Y = F % 2 === 0 ? 100 : 1, X = F % 2 === 0 ? Math.round(this.prop.v[F] * 100) : this.prop.v[F], this.o[F - this.data.p * 4] !== X && (this.o[F - this.data.p * 4] = X, this._omdf = !z); this._mdf = !z } }, extendPrototype([DynamicPropertyContainer], GradientProperty); function SVGGradientFillStyleData(z, F, G) { this.initDynamicPropertyContainer(z), this.getValue = this.iterateDynamicProperties, this.initGradientData(z, F, G) } SVGGradientFillStyleData.prototype.initGradientData = function (z, F, G) { this.o = PropertyFactory.getProp(z, F.o, 0, .01, this), this.s = PropertyFactory.getProp(z, F.s, 1, null, this), this.e = PropertyFactory.getProp(z, F.e, 1, null, this), this.h = PropertyFactory.getProp(z, F.h || { k: 0 }, 0, .01, this), this.a = PropertyFactory.getProp(z, F.a || { k: 0 }, 0, degToRads, this), this.g = new GradientProperty(z, F.g, this), this.style = G, this.stops = [], this.setGradientData(G.pElem, F), this.setGradientOpacity(F, G), this._isAnimated = !!this._isAnimated }, SVGGradientFillStyleData.prototype.setGradientData = function (z, F) { var G = createElementID(), Y = createNS(F.t === 1 ? "linearGradient" : "radialGradient"); Y.setAttribute("id", G), Y.setAttribute("spreadMethod", "pad"), Y.setAttribute("gradientUnits", "userSpaceOnUse"); var X = [], K, J, Z; for (Z = F.g.p * 4, J = 0; J < Z; J += 4)K = createNS("stop"), Y.appendChild(K), X.push(K); z.setAttribute(F.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + G + ")"), this.gf = Y, this.cst = X }, SVGGradientFillStyleData.prototype.setGradientOpacity = function (z, F) { if (this.g._hasOpacity && !this.g._collapsable) { var G, Y, X, K = createNS("mask"), J = createNS("path"); K.appendChild(J); var Z = createElementID(), Q = createElementID(); K.setAttribute("id", Q); var ee = createNS(z.t === 1 ? "linearGradient" : "radialGradient"); ee.setAttribute("id", Z), ee.setAttribute("spreadMethod", "pad"), ee.setAttribute("gradientUnits", "userSpaceOnUse"), X = z.g.k.k[0].s ? z.g.k.k[0].s.length : z.g.k.k.length; var te = this.stops; for (Y = z.g.p * 4; Y < X; Y += 2)G = createNS("stop"), G.setAttribute("stop-color", "rgb(255,255,255)"), ee.appendChild(G), te.push(G); J.setAttribute(z.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + Z + ")"), z.ty === "gs" && (J.setAttribute("stroke-linecap", lineCapEnum[z.lc || 2]), J.setAttribute("stroke-linejoin", lineJoinEnum[z.lj || 2]), z.lj === 1 && J.setAttribute("stroke-miterlimit", z.ml)), this.of = ee, this.ms = K, this.ost = te, this.maskId = Q, F.msElem = J } }, extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData); function SVGGradientStrokeStyleData(z, F, G) { this.initDynamicPropertyContainer(z), this.getValue = this.iterateDynamicProperties, this.w = PropertyFactory.getProp(z, F.w, 0, null, this), this.d = new DashProperty(z, F.d || {}, "svg", this), this.initGradientData(z, F, G), this._isAnimated = !!this._isAnimated } extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData); function ShapeGroupData() { this.it = [], this.prevViewData = [], this.gr = createNS("g") } function SVGTransformData(z, F, G) { this.transform = { mProps: z, op: F, container: G }, this.elements = [], this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length } var buildShapeString = function (F, G, Y, X) { if (G === 0) return ""; var K = F.o, J = F.i, Z = F.v, Q, ee = " M" + X.applyToPointStringified(Z[0][0], Z[0][1]); for (Q = 1; Q < G; Q += 1)ee += " C" + X.applyToPointStringified(K[Q - 1][0], K[Q - 1][1]) + " " + X.applyToPointStringified(J[Q][0], J[Q][1]) + " " + X.applyToPointStringified(Z[Q][0], Z[Q][1]); return Y && G && (ee += " C" + X.applyToPointStringified(K[Q - 1][0], K[Q - 1][1]) + " " + X.applyToPointStringified(J[0][0], J[0][1]) + " " + X.applyToPointStringified(Z[0][0], Z[0][1]), ee += "z"), ee }, SVGElementsRenderer = function () { var z = new Matrix, F = new Matrix, G = { createRenderFunction: Y }; function Y(oe) { switch (oe.ty) { case "fl": return Z; case "gf": return ee; case "gs": return Q; case "st": return te; case "sh": case "el": case "rc": case "sr": return J; case "tr": return X; case "no": return K; default: return null } } function X(oe, ie, se) { (se || ie.transform.op._mdf) && ie.transform.container.setAttribute("opacity", ie.transform.op.v), (se || ie.transform.mProps._mdf) && ie.transform.container.setAttribute("transform", ie.transform.mProps.v.to2dCSS()) } function K() { } function J(oe, ie, se) { var ne, re, fe, ae, he, le, ce = ie.styles.length, ue = ie.lvl, me, ge, ve, Se; for (le = 0; le < ce; le += 1) { if (ae = ie.sh._mdf || se, ie.styles[le].lvl < ue) { for (ge = F.reset(), ve = ue - ie.styles[le].lvl, Se = ie.transformers.length - 1; !ae && ve > 0;)ae = ie.transformers[Se].mProps._mdf || ae, ve -= 1, Se -= 1; if (ae) for (ve = ue - ie.styles[le].lvl, Se = ie.transformers.length - 1; ve > 0;)ge.multiply(ie.transformers[Se].mProps.v), ve -= 1, Se -= 1 } else ge = z; if (me = ie.sh.paths, re = me._length, ae) { for (fe = "", ne = 0; ne < re; ne += 1)he = me.shapes[ne], he && he._length && (fe += buildShapeString(he, he._length, he.c, ge)); ie.caches[le] = fe } else fe = ie.caches[le]; ie.styles[le].d += oe.hd === !0 ? "" : fe, ie.styles[le]._mdf = ae || ie.styles[le]._mdf } } function Z(oe, ie, se) { var ne = ie.style; (ie.c._mdf || se) && ne.pElem.setAttribute("fill", "rgb(" + bmFloor(ie.c.v[0]) + "," + bmFloor(ie.c.v[1]) + "," + bmFloor(ie.c.v[2]) + ")"), (ie.o._mdf || se) && ne.pElem.setAttribute("fill-opacity", ie.o.v) } function Q(oe, ie, se) { ee(oe, ie, se), te(oe, ie, se) } function ee(oe, ie, se) { var ne = ie.gf, re = ie.g._hasOpacity, fe = ie.s.v, ae = ie.e.v; if (ie.o._mdf || se) { var he = oe.ty === "gf" ? "fill-opacity" : "stroke-opacity"; ie.style.pElem.setAttribute(he, ie.o.v) } if (ie.s._mdf || se) { var le = oe.t === 1 ? "x1" : "cx", ce = le === "x1" ? "y1" : "cy"; ne.setAttribute(le, fe[0]), ne.setAttribute(ce, fe[1]), re && !ie.g._collapsable && (ie.of.setAttribute(le, fe[0]), ie.of.setAttribute(ce, fe[1])) } var ue, me, ge, ve; if (ie.g._cmdf || se) { ue = ie.cst; var Se = ie.g.c; for (ge = ue.length, me = 0; me < ge; me += 1)ve = ue[me], ve.setAttribute("offset", Se[me * 4] + "%"), ve.setAttribute("stop-color", "rgb(" + Se[me * 4 + 1] + "," + Se[me * 4 + 2] + "," + Se[me * 4 + 3] + ")") } if (re && (ie.g._omdf || se)) { var ke = ie.g.o; for (ie.g._collapsable ? ue = ie.cst : ue = ie.ost, ge = ue.length, me = 0; me < ge; me += 1)ve = ue[me], ie.g._collapsable || ve.setAttribute("offset", ke[me * 2] + "%"), ve.setAttribute("stop-opacity", ke[me * 2 + 1]) } if (oe.t === 1) (ie.e._mdf || se) && (ne.setAttribute("x2", ae[0]), ne.setAttribute("y2", ae[1]), re && !ie.g._collapsable && (ie.of.setAttribute("x2", ae[0]), ie.of.setAttribute("y2", ae[1]))); else { var Ce; if ((ie.s._mdf || ie.e._mdf || se) && (Ce = Math.sqrt(Math.pow(fe[0] - ae[0], 2) + Math.pow(fe[1] - ae[1], 2)), ne.setAttribute("r", Ce), re && !ie.g._collapsable && ie.of.setAttribute("r", Ce)), ie.e._mdf || ie.h._mdf || ie.a._mdf || se) { Ce || (Ce = Math.sqrt(Math.pow(fe[0] - ae[0], 2) + Math.pow(fe[1] - ae[1], 2))); var Ee = Math.atan2(ae[1] - fe[1], ae[0] - fe[0]), De = ie.h.v; De >= 1 ? De = .99 : De <= -1 && (De = -.99); var Pe = Ce * De, Te = Math.cos(Ee + ie.a.v) * Pe + fe[0], ye = Math.sin(Ee + ie.a.v) * Pe + fe[1]; ne.setAttribute("fx", Te), ne.setAttribute("fy", ye), re && !ie.g._collapsable && (ie.of.setAttribute("fx", Te), ie.of.setAttribute("fy", ye)) } } } function te(oe, ie, se) { var ne = ie.style, re = ie.d; re && (re._mdf || se) && re.dashStr && (ne.pElem.setAttribute("stroke-dasharray", re.dashStr), ne.pElem.setAttribute("stroke-dashoffset", re.dashoffset[0])), ie.c && (ie.c._mdf || se) && ne.pElem.setAttribute("stroke", "rgb(" + bmFloor(ie.c.v[0]) + "," + bmFloor(ie.c.v[1]) + "," + bmFloor(ie.c.v[2]) + ")"), (ie.o._mdf || se) && ne.pElem.setAttribute("stroke-opacity", ie.o.v), (ie.w._mdf || se) && (ne.pElem.setAttribute("stroke-width", ie.w.v), ne.msElem && ne.msElem.setAttribute("stroke-width", ie.w.v)) } return G }(); function SVGShapeElement(z, F, G) { this.shapes = [], this.shapesData = z.shapes, this.stylesList = [], this.shapeModifiers = [], this.itemsData = [], this.processedElements = [], this.animatedContents = [], this.initElement(z, F, G), this.prevViewData = [] } extendPrototype([BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement], SVGShapeElement), SVGShapeElement.prototype.initSecondaryElement = function () { }, SVGShapeElement.prototype.identityMatrix = new Matrix, SVGShapeElement.prototype.buildExpressionInterface = function () { }, SVGShapeElement.prototype.createContent = function () { this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0), this.filterUniqueShapes() }, SVGShapeElement.prototype.filterUniqueShapes = function () { var z, F = this.shapes.length, G, Y, X = this.stylesList.length, K, J = [], Z = !1; for (Y = 0; Y < X; Y += 1) { for (K = this.stylesList[Y], Z = !1, J.length = 0, z = 0; z < F; z += 1)G = this.shapes[z], G.styles.indexOf(K) !== -1 && (J.push(G), Z = G._isAnimated || Z); J.length > 1 && Z && this.setShapesAsAnimated(J) } }, SVGShapeElement.prototype.setShapesAsAnimated = function (z) { var F, G = z.length; for (F = 0; F < G; F += 1)z[F].setAsAnimated() }, SVGShapeElement.prototype.createStyleElement = function (z, F) { var G, Y = new SVGStyleData(z, F), X = Y.pElem; if (z.ty === "st") G = new SVGStrokeStyleData(this, z, Y); else if (z.ty === "fl") G = new SVGFillStyleData(this, z, Y); else if (z.ty === "gf" || z.ty === "gs") { var K = z.ty === "gf" ? SVGGradientFillStyleData : SVGGradientStrokeStyleData; G = new K(this, z, Y), this.globalData.defs.appendChild(G.gf), G.maskId && (this.globalData.defs.appendChild(G.ms), this.globalData.defs.appendChild(G.of), X.setAttribute("mask", "url(" + getLocationHref() + "#" + G.maskId + ")")) } else z.ty === "no" && (G = new SVGNoStyleData(this, z, Y)); return (z.ty === "st" || z.ty === "gs") && (X.setAttribute("stroke-linecap", lineCapEnum[z.lc || 2]), X.setAttribute("stroke-linejoin", lineJoinEnum[z.lj || 2]), X.setAttribute("fill-opacity", "0"), z.lj === 1 && X.setAttribute("stroke-miterlimit", z.ml)), z.r === 2 && X.setAttribute("fill-rule", "evenodd"), z.ln && X.setAttribute("id", z.ln), z.cl && X.setAttribute("class", z.cl), z.bm && (X.style["mix-blend-mode"] = getBlendMode(z.bm)), this.stylesList.push(Y), this.addToAnimatedContents(z, G), G }, SVGShapeElement.prototype.createGroupElement = function (z) { var F = new ShapeGroupData; return z.ln && F.gr.setAttribute("id", z.ln), z.cl && F.gr.setAttribute("class", z.cl), z.bm && (F.gr.style["mix-blend-mode"] = getBlendMode(z.bm)), F }, SVGShapeElement.prototype.createTransformElement = function (z, F) { var G = TransformPropertyFactory.getTransformProperty(this, z, this), Y = new SVGTransformData(G, G.o, F); return this.addToAnimatedContents(z, Y), Y }, SVGShapeElement.prototype.createShapeElement = function (z, F, G) { var Y = 4; z.ty === "rc" ? Y = 5 : z.ty === "el" ? Y = 6 : z.ty === "sr" && (Y = 7); var X = ShapePropertyFactory.getShapeProp(this, z, Y, this), K = new SVGShapeData(F, G, X); return this.shapes.push(K), this.addShapeToModifiers(K), this.addToAnimatedContents(z, K), K }, SVGShapeElement.prototype.addToAnimatedContents = function (z, F) { for (var G = 0, Y = this.animatedContents.length; G < Y;) { if (this.animatedContents[G].element === F) return; G += 1 } this.animatedContents.push({ fn: SVGElementsRenderer.createRenderFunction(z), element: F, data: z }) }, SVGShapeElement.prototype.setElementStyles = function (z) { var F = z.styles, G, Y = this.stylesList.length; for (G = 0; G < Y; G += 1)this.stylesList[G].closed || F.push(this.stylesList[G]) }, SVGShapeElement.prototype.reloadShapes = function () { this._isFirstFrame = !0; var z, F = this.itemsData.length; for (z = 0; z < F; z += 1)this.prevViewData[z] = this.itemsData[z]; for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0), this.filterUniqueShapes(), F = this.dynamicProperties.length, z = 0; z < F; z += 1)this.dynamicProperties[z].getValue(); this.renderModifiers() }, SVGShapeElement.prototype.searchShapes = function (z, F, G, Y, X, K, J) { var Z = [].concat(K), Q, ee = z.length - 1, te, oe, ie = [], se = [], ne, re, fe; for (Q = ee; Q >= 0; Q -= 1) { if (fe = this.searchProcessedElement(z[Q]), fe ? F[Q] = G[fe - 1] : z[Q]._render = J, z[Q].ty === "fl" || z[Q].ty === "st" || z[Q].ty === "gf" || z[Q].ty === "gs" || z[Q].ty === "no") fe ? F[Q].style.closed = !1 : F[Q] = this.createStyleElement(z[Q], X), z[Q]._render && F[Q].style.pElem.parentNode !== Y && Y.appendChild(F[Q].style.pElem), ie.push(F[Q].style); else if (z[Q].ty === "gr") { if (!fe) F[Q] = this.createGroupElement(z[Q]); else for (oe = F[Q].it.length, te = 0; te < oe; te += 1)F[Q].prevViewData[te] = F[Q].it[te]; this.searchShapes(z[Q].it, F[Q].it, F[Q].prevViewData, F[Q].gr, X + 1, Z, J), z[Q]._render && F[Q].gr.parentNode !== Y && Y.appendChild(F[Q].gr) } else z[Q].ty === "tr" ? (fe || (F[Q] = this.createTransformElement(z[Q], Y)), ne = F[Q].transform, Z.push(ne)) : z[Q].ty === "sh" || z[Q].ty === "rc" || z[Q].ty === "el" || z[Q].ty === "sr" ? (fe || (F[Q] = this.createShapeElement(z[Q], Z, X)), this.setElementStyles(F[Q])) : z[Q].ty === "tm" || z[Q].ty === "rd" || z[Q].ty === "ms" || z[Q].ty === "pb" || z[Q].ty === "zz" || z[Q].ty === "op" ? (fe ? (re = F[Q], re.closed = !1) : (re = ShapeModifiers.getModifier(z[Q].ty), re.init(this, z[Q]), F[Q] = re, this.shapeModifiers.push(re)), se.push(re)) : z[Q].ty === "rp" && (fe ? (re = F[Q], re.closed = !0) : (re = ShapeModifiers.getModifier(z[Q].ty), F[Q] = re, re.init(this, z, Q, F), this.shapeModifiers.push(re), J = !1), se.push(re)); this.addProcessedElement(z[Q], Q + 1) } for (ee = ie.length, Q = 0; Q < ee; Q += 1)ie[Q].closed = !0; for (ee = se.length, Q = 0; Q < ee; Q += 1)se[Q].closed = !0 }, SVGShapeElement.prototype.renderInnerContent = function () { this.renderModifiers(); var z, F = this.stylesList.length; for (z = 0; z < F; z += 1)this.stylesList[z].reset(); for (this.renderShape(), z = 0; z < F; z += 1)(this.stylesList[z]._mdf || this._isFirstFrame) && (this.stylesList[z].msElem && (this.stylesList[z].msElem.setAttribute("d", this.stylesList[z].d), this.stylesList[z].d = "M0 0" + this.stylesList[z].d), this.stylesList[z].pElem.setAttribute("d", this.stylesList[z].d || "M0 0")) }, SVGShapeElement.prototype.renderShape = function () { var z, F = this.animatedContents.length, G; for (z = 0; z < F; z += 1)G = this.animatedContents[z], (this._isFirstFrame || G.element._isAnimated) && G.data !== !0 && G.fn(G.data, G.element, this._isFirstFrame) }, SVGShapeElement.prototype.destroy = function () { this.destroyBaseElement(), this.shapesData = null, this.itemsData = null }; function LetterProps(z, F, G, Y, X, K) { this.o = z, this.sw = F, this.sc = G, this.fc = Y, this.m = X, this.p = K, this._mdf = { o: !0, sw: !!F, sc: !!G, fc: !!Y, m: !0, p: !0 } } LetterProps.prototype.update = function (z, F, G, Y, X, K) { this._mdf.o = !1, this._mdf.sw = !1, this._mdf.sc = !1, this._mdf.fc = !1, this._mdf.m = !1, this._mdf.p = !1; var J = !1; return this.o !== z && (this.o = z, this._mdf.o = !0, J = !0), this.sw !== F && (this.sw = F, this._mdf.sw = !0, J = !0), this.sc !== G && (this.sc = G, this._mdf.sc = !0, J = !0), this.fc !== Y && (this.fc = Y, this._mdf.fc = !0, J = !0), this.m !== X && (this.m = X, this._mdf.m = !0, J = !0), K.length && (this.p[0] !== K[0] || this.p[1] !== K[1] || this.p[4] !== K[4] || this.p[5] !== K[5] || this.p[12] !== K[12] || this.p[13] !== K[13]) && (this.p = K, this._mdf.p = !0, J = !0), J }; function TextProperty(z, F) { this._frameId = initialDefaultFrame, this.pv = "", this.v = "", this.kf = !1, this._isFirstFrame = !0, this._mdf = !1, F.d && F.d.sid && (F.d = z.globalData.slotManager.getProp(F.d)), this.data = F, this.elem = z, this.comp = this.elem.comp, this.keysIndex = 0, this.canResize = !1, this.minimumFontSize = 1, this.effectsSequence = [], this.currentData = { ascent: 0, boxWidth: this.defaultBoxWidth, f: "", fStyle: "", fWeight: "", fc: "", j: "", justifyOffset: "", l: [], lh: 0, lineWidths: [], ls: "", of: "", s: "", sc: "", sw: 0, t: 0, tr: 0, sz: 0, ps: null, fillColorAnim: !1, strokeColorAnim: !1, strokeWidthAnim: !1, yOffset: 0, finalSize: 0, finalText: [], finalLineHeight: 0, __complete: !1 }, this.copyData(this.currentData, this.data.d.k[0].s), this.searchProperty() || this.completeTextData(this.currentData) } TextProperty.prototype.defaultBoxWidth = [0, 0], TextProperty.prototype.copyData = function (z, F) { for (var G in F) Object.prototype.hasOwnProperty.call(F, G) && (z[G] = F[G]); return z }, TextProperty.prototype.setCurrentData = function (z) { z.__complete || this.completeTextData(z), this.currentData = z, this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth, this._mdf = !0 }, TextProperty.prototype.searchProperty = function () { return this.searchKeyframes() }, TextProperty.prototype.searchKeyframes = function () { return this.kf = this.data.d.k.length > 1, this.kf && this.addEffect(this.getKeyframeValue.bind(this)), this.kf }, TextProperty.prototype.addEffect = function (z) { this.effectsSequence.push(z), this.elem.addDynamicProperty(this) }, TextProperty.prototype.getValue = function (z) { if (!((this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) && !z)) { this.currentData.t = this.data.d.k[this.keysIndex].s.t; var F = this.currentData, G = this.keysIndex; if (this.lock) { this.setCurrentData(this.currentData); return } this.lock = !0, this._mdf = !1; var Y, X = this.effectsSequence.length, K = z || this.data.d.k[this.keysIndex].s; for (Y = 0; Y < X; Y += 1)G !== this.keysIndex ? K = this.effectsSequence[Y](K, K.t) : K = this.effectsSequence[Y](this.currentData, K.t); F !== K && this.setCurrentData(K), this.v = this.currentData, this.pv = this.v, this.lock = !1, this.frameId = this.elem.globalData.frameId } }, TextProperty.prototype.getKeyframeValue = function () { for (var z = this.data.d.k, F = this.elem.comp.renderedFrame, G = 0, Y = z.length; G <= Y - 1 && !(G === Y - 1 || z[G + 1].t > F);)G += 1; return this.keysIndex !== G && (this.keysIndex = G), this.data.d.k[this.keysIndex].s }, TextProperty.prototype.buildFinalText = function (z) { for (var F = [], G = 0, Y = z.length, X, K, J = !1, Z = !1, Q = ""; G < Y;)J = Z, Z = !1, X = z.charCodeAt(G), Q = z.charAt(G), FontManager.isCombinedCharacter(X) ? J = !0 : X >= 55296 && X <= 56319 ? FontManager.isRegionalFlag(z, G) ? Q = z.substr(G, 14) : (K = z.charCodeAt(G + 1), K >= 56320 && K <= 57343 && (FontManager.isModifier(X, K) ? (Q = z.substr(G, 2), J = !0) : FontManager.isFlagEmoji(z.substr(G, 4)) ? Q = z.substr(G, 4) : Q = z.substr(G, 2))) : X > 56319 ? (K = z.charCodeAt(G + 1), FontManager.isVariationSelector(X) && (J = !0)) : FontManager.isZeroWidthJoiner(X) && (J = !0, Z = !0), J ? (F[F.length - 1] += Q, J = !1) : F.push(Q), G += Q.length; return F }, TextProperty.prototype.completeTextData = function (z) { z.__complete = !0; var F = this.elem.globalData.fontManager, G = this.data, Y = [], X, K, J, Z = 0, Q, ee = G.m.g, te = 0, oe = 0, ie = 0, se = [], ne = 0, re = 0, fe, ae, he = F.getFontByName(z.f), le, ce = 0, ue = getFontProperties(he); z.fWeight = ue.weight, z.fStyle = ue.style, z.finalSize = z.s, z.finalText = this.buildFinalText(z.t), K = z.finalText.length, z.finalLineHeight = z.lh; var me = z.tr / 1e3 * z.finalSize, ge; if (z.sz) for (var ve = !0, Se = z.sz[0], ke = z.sz[1], Ce, Ee; ve;) { Ee = this.buildFinalText(z.t), Ce = 0, ne = 0, K = Ee.length, me = z.tr / 1e3 * z.finalSize; var De = -1; for (X = 0; X < K; X += 1)ge = Ee[X].charCodeAt(0), J = !1, Ee[X] === " " ? De = X : (ge === 13 || ge === 3) && (ne = 0, J = !0, Ce += z.finalLineHeight || z.finalSize * 1.2), F.chars ? (le = F.getCharData(Ee[X], he.fStyle, he.fFamily), ce = J ? 0 : le.w * z.finalSize / 100) : ce = F.measureText(Ee[X], z.f, z.finalSize), ne + ce > Se && Ee[X] !== " " ? (De === -1 ? K += 1 : X = De, Ce += z.finalLineHeight || z.finalSize * 1.2, Ee.splice(X, De === X ? 1 : 0, "\r"), De = -1, ne = 0) : (ne += ce, ne += me); Ce += he.ascent * z.finalSize / 100, this.canResize && z.finalSize > this.minimumFontSize && ke < Ce ? (z.finalSize -= 1, z.finalLineHeight = z.finalSize * z.lh / z.s) : (z.finalText = Ee, K = z.finalText.length, ve = !1) } ne = -me, ce = 0; var Pe = 0, Te; for (X = 0; X < K; X += 1)if (J = !1, Te = z.finalText[X], ge = Te.charCodeAt(0), ge === 13 || ge === 3 ? (Pe = 0, se.push(ne), re = ne > re ? ne : re, ne = -2 * me, Q = "", J = !0, ie += 1) : Q = Te, F.chars ? (le = F.getCharData(Te, he.fStyle, F.getFontByName(z.f).fFamily), ce = J ? 0 : le.w * z.finalSize / 100) : ce = F.measureText(Q, z.f, z.finalSize), Te === " " ? Pe += ce + me : (ne += ce + me + Pe, Pe = 0), Y.push({ l: ce, an: ce, add: te, n: J, anIndexes: [], val: Q, line: ie, animatorJustifyOffset: 0 }), ee == 2) { if (te += ce, Q === "" || Q === " " || X === K - 1) { for ((Q === "" || Q === " ") && (te -= ce); oe <= X;)Y[oe].an = te, Y[oe].ind = Z, Y[oe].extra = ce, oe += 1; Z += 1, te = 0 } } else if (ee == 3) { if (te += ce, Q === "" || X === K - 1) { for (Q === "" && (te -= ce); oe <= X;)Y[oe].an = te, Y[oe].ind = Z, Y[oe].extra = ce, oe += 1; te = 0, Z += 1 } } else Y[Z].ind = Z, Y[Z].extra = 0, Z += 1; if (z.l = Y, re = ne > re ? ne : re, se.push(ne), z.sz) z.boxWidth = z.sz[0], z.justifyOffset = 0; else switch (z.boxWidth = re, z.j) { case 1: z.justifyOffset = -z.boxWidth; break; case 2: z.justifyOffset = -z.boxWidth / 2; break; default: z.justifyOffset = 0 }z.lineWidths = se; var ye = G.a, xe, pe; ae = ye.length; var de, _e, be = []; for (fe = 0; fe < ae; fe += 1) { for (xe = ye[fe], xe.a.sc && (z.strokeColorAnim = !0), xe.a.sw && (z.strokeWidthAnim = !0), (xe.a.fc || xe.a.fh || xe.a.fs || xe.a.fb) && (z.fillColorAnim = !0), _e = 0, de = xe.s.b, X = 0; X < K; X += 1)pe = Y[X], pe.anIndexes[fe] = _e, (de == 1 && pe.val !== "" || de == 2 && pe.val !== "" && pe.val !== " " || de == 3 && (pe.n || pe.val == " " || X == K - 1) || de == 4 && (pe.n || X == K - 1)) && (xe.s.rn === 1 && be.push(_e), _e += 1); G.a[fe].s.totalChars = _e; var Ae = -1, $e; if (xe.s.rn === 1) for (X = 0; X < K; X += 1)pe = Y[X], Ae != pe.anIndexes[fe] && (Ae = pe.anIndexes[fe], $e = be.splice(Math.floor(Math.random() * be.length), 1)[0]), pe.anIndexes[fe] = $e } z.yOffset = z.finalLineHeight || z.finalSize * 1.2, z.ls = z.ls || 0, z.ascent = he.ascent * z.finalSize / 100 }, TextProperty.prototype.updateDocumentData = function (z, F) { F = F === void 0 ? this.keysIndex : F; var G = this.copyData({}, this.data.d.k[F].s); G = this.copyData(G, z), this.data.d.k[F].s = G, this.recalculate(F), this.setCurrentData(G), this.elem.addDynamicProperty(this) }, TextProperty.prototype.recalculate = function (z) { var F = this.data.d.k[z].s; F.__complete = !1, this.keysIndex = 0, this._isFirstFrame = !0, this.getValue(F) }, TextProperty.prototype.canResizeFont = function (z) { this.canResize = z, this.recalculate(this.keysIndex), this.elem.addDynamicProperty(this) }, TextProperty.prototype.setMinimumFontSize = function (z) { this.minimumFontSize = Math.floor(z) || 1, this.recalculate(this.keysIndex), this.elem.addDynamicProperty(this) }; var TextSelectorProp = function () { var z = Math.max, F = Math.min, G = Math.floor; function Y(K, J) { this._currentTextLength = -1, this.k = !1, this.data = J, this.elem = K, this.comp = K.comp, this.finalS = 0, this.finalE = 0, this.initDynamicPropertyContainer(K), this.s = PropertyFactory.getProp(K, J.s || { k: 0 }, 0, 0, this), "e" in J ? this.e = PropertyFactory.getProp(K, J.e, 0, 0, this) : this.e = { v: 100 }, this.o = PropertyFactory.getProp(K, J.o || { k: 0 }, 0, 0, this), this.xe = PropertyFactory.getProp(K, J.xe || { k: 0 }, 0, 0, this), this.ne = PropertyFactory.getProp(K, J.ne || { k: 0 }, 0, 0, this), this.sm = PropertyFactory.getProp(K, J.sm || { k: 100 }, 0, 0, this), this.a = PropertyFactory.getProp(K, J.a, 0, .01, this), this.dynamicProperties.length || this.getValue() } Y.prototype = { getMult: function (J) { this._currentTextLength !== this.elem.textProperty.currentData.l.length && this.getValue(); var Z = 0, Q = 0, ee = 1, te = 1; this.ne.v > 0 ? Z = this.ne.v / 100 : Q = -this.ne.v / 100, this.xe.v > 0 ? ee = 1 - this.xe.v / 100 : te = 1 + this.xe.v / 100; var oe = BezierFactory.getBezierEasing(Z, Q, ee, te).get, ie = 0, se = this.finalS, ne = this.finalE, re = this.data.sh; if (re === 2) ne === se ? ie = J >= ne ? 1 : 0 : ie = z(0, F(.5 / (ne - se) + (J - se) / (ne - se), 1)), ie = oe(ie); else if (re === 3) ne === se ? ie = J >= ne ? 0 : 1 : ie = 1 - z(0, F(.5 / (ne - se) + (J - se) / (ne - se), 1)), ie = oe(ie); else if (re === 4) ne === se ? ie = 0 : (ie = z(0, F(.5 / (ne - se) + (J - se) / (ne - se), 1)), ie < .5 ? ie *= 2 : ie = 1 - 2 * (ie - .5)), ie = oe(ie); else if (re === 5) { if (ne === se) ie = 0; else { var fe = ne - se; J = F(z(0, J + .5 - se), ne - se); var ae = -fe / 2 + J, he = fe / 2; ie = Math.sqrt(1 - ae * ae / (he * he)) } ie = oe(ie) } else re === 6 ? (ne === se ? ie = 0 : (J = F(z(0, J + .5 - se), ne - se), ie = (1 + Math.cos(Math.PI + Math.PI * 2 * J / (ne - se))) / 2), ie = oe(ie)) : (J >= G(se) && (J - se < 0 ? ie = z(0, F(F(ne, 1) - (se - J), 1)) : ie = z(0, F(ne - J, 1))), ie = oe(ie)); if (this.sm.v !== 100) { var le = this.sm.v * .01; le === 0 && (le = 1e-8); var ce = .5 - le * .5; ie < ce ? ie = 0 : (ie = (ie - ce) / le, ie > 1 && (ie = 1)) } return ie * this.a.v }, getValue: function (J) { this.iterateDynamicProperties(), this._mdf = J || this._mdf, this._currentTextLength = this.elem.textProperty.currentData.l.length || 0, J && this.data.r === 2 && (this.e.v = this._currentTextLength); var Z = this.data.r === 2 ? 1 : 100 / this.data.totalChars, Q = this.o.v / Z, ee = this.s.v / Z + Q, te = this.e.v / Z + Q; if (ee > te) { var oe = ee; ee = te, te = oe } this.finalS = ee, this.finalE = te } }, extendPrototype([DynamicPropertyContainer], Y); function X(K, J, Z) { return new Y(K, J) } return { getTextSelectorProp: X } }(); function TextAnimatorDataProperty(z, F, G) { var Y = { propType: !1 }, X = PropertyFactory.getProp, K = F.a; this.a = { r: K.r ? X(z, K.r, 0, degToRads, G) : Y, rx: K.rx ? X(z, K.rx, 0, degToRads, G) : Y, ry: K.ry ? X(z, K.ry, 0, degToRads, G) : Y, sk: K.sk ? X(z, K.sk, 0, degToRads, G) : Y, sa: K.sa ? X(z, K.sa, 0, degToRads, G) : Y, s: K.s ? X(z, K.s, 1, .01, G) : Y, a: K.a ? X(z, K.a, 1, 0, G) : Y, o: K.o ? X(z, K.o, 0, .01, G) : Y, p: K.p ? X(z, K.p, 1, 0, G) : Y, sw: K.sw ? X(z, K.sw, 0, 0, G) : Y, sc: K.sc ? X(z, K.sc, 1, 0, G) : Y, fc: K.fc ? X(z, K.fc, 1, 0, G) : Y, fh: K.fh ? X(z, K.fh, 0, 0, G) : Y, fs: K.fs ? X(z, K.fs, 0, .01, G) : Y, fb: K.fb ? X(z, K.fb, 0, .01, G) : Y, t: K.t ? X(z, K.t, 0, 0, G) : Y }, this.s = TextSelectorProp.getTextSelectorProp(z, F.s, G), this.s.t = F.s.t } function TextAnimatorProperty(z, F, G) { this._isFirstFrame = !0, this._hasMaskedPath = !1, this._frameId = -1, this._textData = z, this._renderType = F, this._elem = G, this._animatorsData = createSizedArray(this._textData.a.length), this._pathData = {}, this._moreOptions = { alignment: {} }, this.renderedLetters = [], this.lettersChangedFlag = !1, this.initDynamicPropertyContainer(G) } TextAnimatorProperty.prototype.searchProperties = function () { var z, F = this._textData.a.length, G, Y = PropertyFactory.getProp; for (z = 0; z < F; z += 1)G = this._textData.a[z], this._animatorsData[z] = new TextAnimatorDataProperty(this._elem, G, this); this._textData.p && "m" in this._textData.p ? (this._pathData = { a: Y(this._elem, this._textData.p.a, 0, 0, this), f: Y(this._elem, this._textData.p.f, 0, 0, this), l: Y(this._elem, this._textData.p.l, 0, 0, this), r: Y(this._elem, this._textData.p.r, 0, 0, this), p: Y(this._elem, this._textData.p.p, 0, 0, this), m: this._elem.maskManager.getMaskProperty(this._textData.p.m) }, this._hasMaskedPath = !0) : this._hasMaskedPath = !1, this._moreOptions.alignment = Y(this._elem, this._textData.m.a, 1, 0, this) }, TextAnimatorProperty.prototype.getMeasures = function (z, F) { if (this.lettersChangedFlag = F, !(!this._mdf && !this._isFirstFrame && !F && (!this._hasMaskedPath || !this._pathData.m._mdf))) { this._isFirstFrame = !1; var G = this._moreOptions.alignment.v, Y = this._animatorsData, X = this._textData, K = this.mHelper, J = this._renderType, Z = this.renderedLetters.length, Q, ee, te, oe, ie = z.l, se, ne, re, fe, ae, he, le, ce, ue, me, ge, ve, Se, ke, Ce; if (this._hasMaskedPath) { if (Ce = this._pathData.m, !this._pathData.n || this._pathData._mdf) { var Ee = Ce.v; this._pathData.r.v && (Ee = Ee.reverse()), se = { tLength: 0, segments: [] }, oe = Ee._length - 1; var De; for (ve = 0, te = 0; te < oe; te += 1)De = bez.buildBezierData(Ee.v[te], Ee.v[te + 1], [Ee.o[te][0] - Ee.v[te][0], Ee.o[te][1] - Ee.v[te][1]], [Ee.i[te + 1][0] - Ee.v[te + 1][0], Ee.i[te + 1][1] - Ee.v[te + 1][1]]), se.tLength += De.segmentLength, se.segments.push(De), ve += De.segmentLength; te = oe, Ce.v.c && (De = bez.buildBezierData(Ee.v[te], Ee.v[0], [Ee.o[te][0] - Ee.v[te][0], Ee.o[te][1] - Ee.v[te][1]], [Ee.i[0][0] - Ee.v[0][0], Ee.i[0][1] - Ee.v[0][1]]), se.tLength += De.segmentLength, se.segments.push(De), ve += De.segmentLength), this._pathData.pi = se } if (se = this._pathData.pi, ne = this._pathData.f.v, le = 0, he = 1, fe = 0, ae = !0, me = se.segments, ne < 0 && Ce.v.c) for (se.tLength < Math.abs(ne) && (ne = -Math.abs(ne) % se.tLength), le = me.length - 1, ue = me[le].points, he = ue.length - 1; ne < 0;)ne += ue[he].partialLength, he -= 1, he < 0 && (le -= 1, ue = me[le].points, he = ue.length - 1); ue = me[le].points, ce = ue[he - 1], re = ue[he], ge = re.partialLength } oe = ie.length, Q = 0, ee = 0; var Pe = z.finalSize * 1.2 * .714, Te = !0, ye, xe, pe, de, _e; de = Y.length; var be, Ae = -1, $e, Fe, Ie, Be = ne, Ve = le, Ze = he, Qe = -1, Ue, Ye, Xe, Re, Me, it, nt, we, Ge = "", Oe = this.defaultPropsArray, at; if (z.j === 2 || z.j === 1) { var We = 0, ot = 0, dt = z.j === 2 ? -.5 : -1, mt = 0, rt = !0; for (te = 0; te < oe; te += 1)if (ie[te].n) { for (We && (We += ot); mt < te;)ie[mt].animatorJustifyOffset = We, mt += 1; We = 0, rt = !0 } else { for (pe = 0; pe < de; pe += 1)ye = Y[pe].a, ye.t.propType && (rt && z.j === 2 && (ot += ye.t.v * dt), xe = Y[pe].s, be = xe.getMult(ie[te].anIndexes[pe], X.a[pe].s.totalChars), be.length ? We += ye.t.v * be[0] * dt : We += ye.t.v * be * dt); rt = !1 } for (We && (We += ot); mt < te;)ie[mt].animatorJustifyOffset = We, mt += 1 } for (te = 0; te < oe; te += 1) { if (K.reset(), Ue = 1, ie[te].n) Q = 0, ee += z.yOffset, ee += Te ? 1 : 0, ne = Be, Te = !1, this._hasMaskedPath && (le = Ve, he = Ze, ue = me[le].points, ce = ue[he - 1], re = ue[he], ge = re.partialLength, fe = 0), Ge = "", we = "", it = "", at = "", Oe = this.defaultPropsArray; else { if (this._hasMaskedPath) { if (Qe !== ie[te].line) { switch (z.j) { case 1: ne += ve - z.lineWidths[ie[te].line]; break; case 2: ne += (ve - z.lineWidths[ie[te].line]) / 2; break }Qe = ie[te].line } Ae !== ie[te].ind && (ie[Ae] && (ne += ie[Ae].extra), ne += ie[te].an / 2, Ae = ie[te].ind), ne += G[0] * ie[te].an * .005; var ut = 0; for (pe = 0; pe < de; pe += 1)ye = Y[pe].a, ye.p.propType && (xe = Y[pe].s, be = xe.getMult(ie[te].anIndexes[pe], X.a[pe].s.totalChars), be.length ? ut += ye.p.v[0] * be[0] : ut += ye.p.v[0] * be), ye.a.propType && (xe = Y[pe].s, be = xe.getMult(ie[te].anIndexes[pe], X.a[pe].s.totalChars), be.length ? ut += ye.a.v[0] * be[0] : ut += ye.a.v[0] * be); for (ae = !0, this._pathData.a.v && (ne = ie[0].an * .5 + (ve - this._pathData.f.v - ie[0].an * .5 - ie[ie.length - 1].an * .5) * Ae / (oe - 1), ne += this._pathData.f.v); ae;)fe + ge >= ne + ut || !ue ? (Se = (ne + ut - fe) / re.partialLength, Fe = ce.point[0] + (re.point[0] - ce.point[0]) * Se, Ie = ce.point[1] + (re.point[1] - ce.point[1]) * Se, K.translate(-G[0] * ie[te].an * .005, -(G[1] * Pe) * .01), ae = !1) : ue && (fe += re.partialLength, he += 1, he >= ue.length && (he = 0, le += 1, me[le] ? ue = me[le].points : Ce.v.c ? (he = 0, le = 0, ue = me[le].points) : (fe -= re.partialLength, ue = null)), ue && (ce = re, re = ue[he], ge = re.partialLength)); $e = ie[te].an / 2 - ie[te].add, K.translate(-$e, 0, 0) } else $e = ie[te].an / 2 - ie[te].add, K.translate(-$e, 0, 0), K.translate(-G[0] * ie[te].an * .005, -G[1] * Pe * .01, 0); for (pe = 0; pe < de; pe += 1)ye = Y[pe].a, ye.t.propType && (xe = Y[pe].s, be = xe.getMult(ie[te].anIndexes[pe], X.a[pe].s.totalChars), (Q !== 0 || z.j !== 0) && (this._hasMaskedPath ? be.length ? ne += ye.t.v * be[0] : ne += ye.t.v * be : be.length ? Q += ye.t.v * be[0] : Q += ye.t.v * be)); for (z.strokeWidthAnim && (Xe = z.sw || 0), z.strokeColorAnim && (z.sc ? Ye = [z.sc[0], z.sc[1], z.sc[2]] : Ye = [0, 0, 0]), z.fillColorAnim && z.fc && (Re = [z.fc[0], z.fc[1], z.fc[2]]), pe = 0; pe < de; pe += 1)ye = Y[pe].a, ye.a.propType && (xe = Y[pe].s, be = xe.getMult(ie[te].anIndexes[pe], X.a[pe].s.totalChars), be.length ? K.translate(-ye.a.v[0] * be[0], -ye.a.v[1] * be[1], ye.a.v[2] * be[2]) : K.translate(-ye.a.v[0] * be, -ye.a.v[1] * be, ye.a.v[2] * be)); for (pe = 0; pe < de; pe += 1)ye = Y[pe].a, ye.s.propType && (xe = Y[pe].s, be = xe.getMult(ie[te].anIndexes[pe], X.a[pe].s.totalChars), be.length ? K.scale(1 + (ye.s.v[0] - 1) * be[0], 1 + (ye.s.v[1] - 1) * be[1], 1) : K.scale(1 + (ye.s.v[0] - 1) * be, 1 + (ye.s.v[1] - 1) * be, 1)); for (pe = 0; pe < de; pe += 1) { if (ye = Y[pe].a, xe = Y[pe].s, be = xe.getMult(ie[te].anIndexes[pe], X.a[pe].s.totalChars), ye.sk.propType && (be.length ? K.skewFromAxis(-ye.sk.v * be[0], ye.sa.v * be[1]) : K.skewFromAxis(-ye.sk.v * be, ye.sa.v * be)), ye.r.propType && (be.length ? K.rotateZ(-ye.r.v * be[2]) : K.rotateZ(-ye.r.v * be)), ye.ry.propType && (be.length ? K.rotateY(ye.ry.v * be[1]) : K.rotateY(ye.ry.v * be)), ye.rx.propType && (be.length ? K.rotateX(ye.rx.v * be[0]) : K.rotateX(ye.rx.v * be)), ye.o.propType && (be.length ? Ue += (ye.o.v * be[0] - Ue) * be[0] : Ue += (ye.o.v * be - Ue) * be), z.strokeWidthAnim && ye.sw.propType && (be.length ? Xe += ye.sw.v * be[0] : Xe += ye.sw.v * be), z.strokeColorAnim && ye.sc.propType) for (Me = 0; Me < 3; Me += 1)be.length ? Ye[Me] += (ye.sc.v[Me] - Ye[Me]) * be[0] : Ye[Me] += (ye.sc.v[Me] - Ye[Me]) * be; if (z.fillColorAnim && z.fc) { if (ye.fc.propType) for (Me = 0; Me < 3; Me += 1)be.length ? Re[Me] += (ye.fc.v[Me] - Re[Me]) * be[0] : Re[Me] += (ye.fc.v[Me] - Re[Me]) * be; ye.fh.propType && (be.length ? Re = addHueToRGB(Re, ye.fh.v * be[0]) : Re = addHueToRGB(Re, ye.fh.v * be)), ye.fs.propType && (be.length ? Re = addSaturationToRGB(Re, ye.fs.v * be[0]) : Re = addSaturationToRGB(Re, ye.fs.v * be)), ye.fb.propType && (be.length ? Re = addBrightnessToRGB(Re, ye.fb.v * be[0]) : Re = addBrightnessToRGB(Re, ye.fb.v * be)) } } for (pe = 0; pe < de; pe += 1)ye = Y[pe].a, ye.p.propType && (xe = Y[pe].s, be = xe.getMult(ie[te].anIndexes[pe], X.a[pe].s.totalChars), this._hasMaskedPath ? be.length ? K.translate(0, ye.p.v[1] * be[0], -ye.p.v[2] * be[1]) : K.translate(0, ye.p.v[1] * be, -ye.p.v[2] * be) : be.length ? K.translate(ye.p.v[0] * be[0], ye.p.v[1] * be[1], -ye.p.v[2] * be[2]) : K.translate(ye.p.v[0] * be, ye.p.v[1] * be, -ye.p.v[2] * be)); if (z.strokeWidthAnim && (it = Xe < 0 ? 0 : Xe), z.strokeColorAnim && (nt = "rgb(" + Math.round(Ye[0] * 255) + "," + Math.round(Ye[1] * 255) + "," + Math.round(Ye[2] * 255) + ")"), z.fillColorAnim && z.fc && (we = "rgb(" + Math.round(Re[0] * 255) + "," + Math.round(Re[1] * 255) + "," + Math.round(Re[2] * 255) + ")"), this._hasMaskedPath) { if (K.translate(0, -z.ls), K.translate(0, G[1] * Pe * .01 + ee, 0), this._pathData.p.v) { ke = (re.point[1] - ce.point[1]) / (re.point[0] - ce.point[0]); var tt = Math.atan(ke) * 180 / Math.PI; re.point[0] < ce.point[0] && (tt += 180), K.rotate(-tt * Math.PI / 180) } K.translate(Fe, Ie, 0), ne -= G[0] * ie[te].an * .005, ie[te + 1] && Ae !== ie[te + 1].ind && (ne += ie[te].an / 2, ne += z.tr * .001 * z.finalSize) } else { switch (K.translate(Q, ee, 0), z.ps && K.translate(z.ps[0], z.ps[1] + z.ascent, 0), z.j) { case 1: K.translate(ie[te].animatorJustifyOffset + z.justifyOffset + (z.boxWidth - z.lineWidths[ie[te].line]), 0, 0); break; case 2: K.translate(ie[te].animatorJustifyOffset + z.justifyOffset + (z.boxWidth - z.lineWidths[ie[te].line]) / 2, 0, 0); break }K.translate(0, -z.ls), K.translate($e, 0, 0), K.translate(G[0] * ie[te].an * .005, G[1] * Pe * .01, 0), Q += ie[te].l + z.tr * .001 * z.finalSize } J === "html" ? Ge = K.toCSS() : J === "svg" ? Ge = K.to2dCSS() : Oe = [K.props[0], K.props[1], K.props[2], K.props[3], K.props[4], K.props[5], K.props[6], K.props[7], K.props[8], K.props[9], K.props[10], K.props[11], K.props[12], K.props[13], K.props[14], K.props[15]], at = Ue } Z <= te ? (_e = new LetterProps(at, it, nt, we, Ge, Oe), this.renderedLetters.push(_e), Z += 1, this.lettersChangedFlag = !0) : (_e = this.renderedLetters[te], this.lettersChangedFlag = _e.update(at, it, nt, we, Ge, Oe) || this.lettersChangedFlag) } } }, TextAnimatorProperty.prototype.getValue = function () { this._elem.globalData.frameId !== this._frameId && (this._frameId = this._elem.globalData.frameId, this.iterateDynamicProperties()) }, TextAnimatorProperty.prototype.mHelper = new Matrix, TextAnimatorProperty.prototype.defaultPropsArray = [], extendPrototype([DynamicPropertyContainer], TextAnimatorProperty); function ITextElement() { } ITextElement.prototype.initElement = function (z, F, G) { this.lettersChangedFlag = !0, this.initFrame(), this.initBaseData(z, F, G), this.textProperty = new TextProperty(this, z.t, this.dynamicProperties), this.textAnimator = new TextAnimatorProperty(z.t, this.renderType, this), this.initTransform(z, F, G), this.initHierarchy(), this.initRenderable(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), this.createContent(), this.hide(), this.textAnimator.searchProperties(this.dynamicProperties) }, ITextElement.prototype.prepareFrame = function (z) { this._mdf = !1, this.prepareRenderableFrame(z), this.prepareProperties(z, this.isInRange) }, ITextElement.prototype.createPathShape = function (z, F) { var G, Y = F.length, X, K = ""; for (G = 0; G < Y; G += 1)F[G].ty === "sh" && (X = F[G].ks.k, K += buildShapeString(X, X.i.length, !0, z)); return K }, ITextElement.prototype.updateDocumentData = function (z, F) { this.textProperty.updateDocumentData(z, F) }, ITextElement.prototype.canResizeFont = function (z) { this.textProperty.canResizeFont(z) }, ITextElement.prototype.setMinimumFontSize = function (z) { this.textProperty.setMinimumFontSize(z) }, ITextElement.prototype.applyTextPropertiesToMatrix = function (z, F, G, Y, X) { switch (z.ps && F.translate(z.ps[0], z.ps[1] + z.ascent, 0), F.translate(0, -z.ls, 0), z.j) { case 1: F.translate(z.justifyOffset + (z.boxWidth - z.lineWidths[G]), 0, 0); break; case 2: F.translate(z.justifyOffset + (z.boxWidth - z.lineWidths[G]) / 2, 0, 0); break }F.translate(Y, X, 0) }, ITextElement.prototype.buildColor = function (z) { return "rgb(" + Math.round(z[0] * 255) + "," + Math.round(z[1] * 255) + "," + Math.round(z[2] * 255) + ")" }, ITextElement.prototype.emptyProp = new LetterProps, ITextElement.prototype.destroy = function () { }, ITextElement.prototype.validateText = function () { (this.textProperty._mdf || this.textProperty._isFirstFrame) && (this.buildNewText(), this.textProperty._isFirstFrame = !1, this.textProperty._mdf = !1) }; var emptyShapeData = { shapes: [] }; function SVGTextLottieElement(z, F, G) { this.textSpans = [], this.renderType = "svg", this.initElement(z, F, G) } extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], SVGTextLottieElement), SVGTextLottieElement.prototype.createContent = function () { this.data.singleShape && !this.globalData.fontManager.chars && (this.textContainer = createNS("text")) }, SVGTextLottieElement.prototype.buildTextContents = function (z) { for (var F = 0, G = z.length, Y = [], X = ""; F < G;)z[F] === "\r" || z[F] === "" ? (Y.push(X), X = "") : X += z[F], F += 1; return Y.push(X), Y }, SVGTextLottieElement.prototype.buildShapeData = function (z, F) { if (z.shapes && z.shapes.length) { var G = z.shapes[0]; if (G.it) { var Y = G.it[G.it.length - 1]; Y.s && (Y.s.k[0] = F, Y.s.k[1] = F) } } return z }, SVGTextLottieElement.prototype.buildNewText = function () { this.addDynamicProperty(this); var z, F, G = this.textProperty.currentData; this.renderedLetters = createSizedArray(G ? G.l.length : 0), G.fc ? this.layerElement.setAttribute("fill", this.buildColor(G.fc)) : this.layerElement.setAttribute("fill", "rgba(0,0,0,0)"), G.sc && (this.layerElement.setAttribute("stroke", this.buildColor(G.sc)), this.layerElement.setAttribute("stroke-width", G.sw)), this.layerElement.setAttribute("font-size", G.finalSize); var Y = this.globalData.fontManager.getFontByName(G.f); if (Y.fClass) this.layerElement.setAttribute("class", Y.fClass); else { this.layerElement.setAttribute("font-family", Y.fFamily); var X = G.fWeight, K = G.fStyle; this.layerElement.setAttribute("font-style", K), this.layerElement.setAttribute("font-weight", X) } this.layerElement.setAttribute("aria-label", G.t); var J = G.l || [], Z = !!this.globalData.fontManager.chars; F = J.length; var Q, ee = this.mHelper, te = "", oe = this.data.singleShape, ie = 0, se = 0, ne = !0, re = G.tr * .001 * G.finalSize; if (oe && !Z && !G.sz) { var fe = this.textContainer, ae = "start"; switch (G.j) { case 1: ae = "end"; break; case 2: ae = "middle"; break; default: ae = "start"; break }fe.setAttribute("text-anchor", ae), fe.setAttribute("letter-spacing", re); var he = this.buildTextContents(G.finalText); for (F = he.length, se = G.ps ? G.ps[1] + G.ascent : 0, z = 0; z < F; z += 1)Q = this.textSpans[z].span || createNS("tspan"), Q.textContent = he[z], Q.setAttribute("x", 0), Q.setAttribute("y", se), Q.style.display = "inherit", fe.appendChild(Q), this.textSpans[z] || (this.textSpans[z] = { span: null, glyph: null }), this.textSpans[z].span = Q, se += G.finalLineHeight; this.layerElement.appendChild(fe) } else { var le = this.textSpans.length, ce; for (z = 0; z < F; z += 1) { if (this.textSpans[z] || (this.textSpans[z] = { span: null, childSpan: null, glyph: null }), !Z || !oe || z === 0) { if (Q = le > z ? this.textSpans[z].span : createNS(Z ? "g" : "text"), le <= z) { if (Q.setAttribute("stroke-linecap", "butt"), Q.setAttribute("stroke-linejoin", "round"), Q.setAttribute("stroke-miterlimit", "4"), this.textSpans[z].span = Q, Z) { var ue = createNS("g"); Q.appendChild(ue), this.textSpans[z].childSpan = ue } this.textSpans[z].span = Q, this.layerElement.appendChild(Q) } Q.style.display = "inherit" } if (ee.reset(), oe && (J[z].n && (ie = -re, se += G.yOffset, se += ne ? 1 : 0, ne = !1), this.applyTextPropertiesToMatrix(G, ee, J[z].line, ie, se), ie += J[z].l || 0, ie += re), Z) { ce = this.globalData.fontManager.getCharData(G.finalText[z], Y.fStyle, this.globalData.fontManager.getFontByName(G.f).fFamily); var me; if (ce.t === 1) me = new SVGCompElement(ce.data, this.globalData, this); else { var ge = emptyShapeData; ce.data && ce.data.shapes && (ge = this.buildShapeData(ce.data, G.finalSize)), me = new SVGShapeElement(ge, this.globalData, this) } if (this.textSpans[z].glyph) { var ve = this.textSpans[z].glyph; this.textSpans[z].childSpan.removeChild(ve.layerElement), ve.destroy() } this.textSpans[z].glyph = me, me._debug = !0, me.prepareFrame(0), me.renderFrame(), this.textSpans[z].childSpan.appendChild(me.layerElement), ce.t === 1 && this.textSpans[z].childSpan.setAttribute("transform", "scale(" + G.finalSize / 100 + "," + G.finalSize / 100 + ")") } else oe && Q.setAttribute("transform", "translate(" + ee.props[12] + "," + ee.props[13] + ")"), Q.textContent = J[z].val, Q.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve") } oe && Q && Q.setAttribute("d", te) } for (; z < this.textSpans.length;)this.textSpans[z].span.style.display = "none", z += 1; this._sizeChanged = !0 }, SVGTextLottieElement.prototype.sourceRectAtTime = function () { if (this.prepareFrame(this.comp.renderedFrame - this.data.st), this.renderInnerContent(), this._sizeChanged) { this._sizeChanged = !1; var z = this.layerElement.getBBox(); this.bbox = { top: z.y, left: z.x, width: z.width, height: z.height } } return this.bbox }, SVGTextLottieElement.prototype.getValue = function () { var z, F = this.textSpans.length, G; for (this.renderedFrame = this.comp.renderedFrame, z = 0; z < F; z += 1)G = this.textSpans[z].glyph, G && (G.prepareFrame(this.comp.renderedFrame - this.data.st), G._mdf && (this._mdf = !0)) }, SVGTextLottieElement.prototype.renderInnerContent = function () { if (this.validateText(), (!this.data.singleShape || this._mdf) && (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag), this.lettersChangedFlag || this.textAnimator.lettersChangedFlag)) { this._sizeChanged = !0; var z, F, G = this.textAnimator.renderedLetters, Y = this.textProperty.currentData.l; F = Y.length; var X, K, J; for (z = 0; z < F; z += 1)Y[z].n || (X = G[z], K = this.textSpans[z].span, J = this.textSpans[z].glyph, J && J.renderFrame(), X._mdf.m && K.setAttribute("transform", X.m), X._mdf.o && K.setAttribute("opacity", X.o), X._mdf.sw && K.setAttribute("stroke-width", X.sw), X._mdf.sc && K.setAttribute("stroke", X.sc), X._mdf.fc && K.setAttribute("fill", X.fc)) } }; function ISolidElement(z, F, G) { this.initElement(z, F, G) } extendPrototype([IImageElement], ISolidElement), ISolidElement.prototype.createContent = function () { var z = createNS("rect"); z.setAttribute("width", this.data.sw), z.setAttribute("height", this.data.sh), z.setAttribute("fill", this.data.sc), this.layerElement.appendChild(z) }; function NullElement(z, F, G) { this.initFrame(), this.initBaseData(z, F, G), this.initFrame(), this.initTransform(z, F, G), this.initHierarchy() } NullElement.prototype.prepareFrame = function (z) { this.prepareProperties(z, !0) }, NullElement.prototype.renderFrame = function () { }, NullElement.prototype.getBaseElement = function () { return null }, NullElement.prototype.destroy = function () { }, NullElement.prototype.sourceRectAtTime = function () { }, NullElement.prototype.hide = function () { }, extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement); function SVGRendererBase() { } extendPrototype([BaseRenderer], SVGRendererBase), SVGRendererBase.prototype.createNull = function (z) { return new NullElement(z, this.globalData, this) }, SVGRendererBase.prototype.createShape = function (z) { return new SVGShapeElement(z, this.globalData, this) }, SVGRendererBase.prototype.createText = function (z) { return new SVGTextLottieElement(z, this.globalData, this) }, SVGRendererBase.prototype.createImage = function (z) { return new IImageElement(z, this.globalData, this) }, SVGRendererBase.prototype.createSolid = function (z) { return new ISolidElement(z, this.globalData, this) }, SVGRendererBase.prototype.configAnimation = function (z) { this.svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg"), this.svgElement.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink"), this.renderConfig.viewBoxSize ? this.svgElement.setAttribute("viewBox", this.renderConfig.viewBoxSize) : this.svgElement.setAttribute("viewBox", "0 0 " + z.w + " " + z.h), this.renderConfig.viewBoxOnly || (this.svgElement.setAttribute("width", z.w), this.svgElement.setAttribute("height", z.h), this.svgElement.style.width = "100%", this.svgElement.style.height = "100%", this.svgElement.style.transform = "translate3d(0,0,0)", this.svgElement.style.contentVisibility = this.renderConfig.contentVisibility), this.renderConfig.width && this.svgElement.setAttribute("width", this.renderConfig.width), this.renderConfig.height && this.svgElement.setAttribute("height", this.renderConfig.height), this.renderConfig.className && this.svgElement.setAttribute("class", this.renderConfig.className), this.renderConfig.id && this.svgElement.setAttribute("id", this.renderConfig.id), this.renderConfig.focusable !== void 0 && this.svgElement.setAttribute("focusable", this.renderConfig.focusable), this.svgElement.setAttribute("preserveAspectRatio", this.renderConfig.preserveAspectRatio), this.animationItem.wrapper.appendChild(this.svgElement); var F = this.globalData.defs; this.setupGlobalData(z, F), this.globalData.progressiveLoad = this.renderConfig.progressiveLoad, this.data = z; var G = createNS("clipPath"), Y = createNS("rect"); Y.setAttribute("width", z.w), Y.setAttribute("height", z.h), Y.setAttribute("x", 0), Y.setAttribute("y", 0); var X = createElementID(); G.setAttribute("id", X), G.appendChild(Y), this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + X + ")"), F.appendChild(G), this.layers = z.layers, this.elements = createSizedArray(z.layers.length) }, SVGRendererBase.prototype.destroy = function () { this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""), this.layerElement = null, this.globalData.defs = null; var z, F = this.layers ? this.layers.length : 0; for (z = 0; z < F; z += 1)this.elements[z] && this.elements[z].destroy && this.elements[z].destroy(); this.elements.length = 0, this.destroyed = !0, this.animationItem = null }, SVGRendererBase.prototype.updateContainerSize = function () { }, SVGRendererBase.prototype.findIndexByInd = function (z) { var F = 0, G = this.layers.length; for (F = 0; F < G; F += 1)if (this.layers[F].ind === z) return F; return -1 }, SVGRendererBase.prototype.buildItem = function (z) { var F = this.elements; if (!(F[z] || this.layers[z].ty === 99)) { F[z] = !0; var G = this.createItem(this.layers[z]); if (F[z] = G, getExpressionsPlugin() && (this.layers[z].ty === 0 && this.globalData.projectInterface.registerComposition(G), G.initExpressions()), this.appendElementInPos(G, z), this.layers[z].tt) { var Y = "tp" in this.layers[z] ? this.findIndexByInd(this.layers[z].tp) : z - 1; if (Y === -1) return; if (!this.elements[Y] || this.elements[Y] === !0) this.buildItem(Y), this.addPendingElement(G); else { var X = F[Y], K = X.getMatte(this.layers[z].tt); G.setMatte(K) } } } }, SVGRendererBase.prototype.checkPendingElements = function () { for (; this.pendingElements.length;) { var z = this.pendingElements.pop(); if (z.checkParenting(), z.data.tt) for (var F = 0, G = this.elements.length; F < G;) { if (this.elements[F] === z) { var Y = "tp" in z.data ? this.findIndexByInd(z.data.tp) : F - 1, X = this.elements[Y], K = X.getMatte(this.layers[F].tt); z.setMatte(K); break } F += 1 } } }, SVGRendererBase.prototype.renderFrame = function (z) { if (!(this.renderedFrame === z || this.destroyed)) { z === null ? z = this.renderedFrame : this.renderedFrame = z, this.globalData.frameNum = z, this.globalData.frameId += 1, this.globalData.projectInterface.currentFrame = z, this.globalData._mdf = !1; var F, G = this.layers.length; for (this.completeLayers || this.checkLayers(z), F = G - 1; F >= 0; F -= 1)(this.completeLayers || this.elements[F]) && this.elements[F].prepareFrame(z - this.layers[F].st); if (this.globalData._mdf) for (F = 0; F < G; F += 1)(this.completeLayers || this.elements[F]) && this.elements[F].renderFrame() } }, SVGRendererBase.prototype.appendElementInPos = function (z, F) { var G = z.getBaseElement(); if (G) { for (var Y = 0, X; Y < F;)this.elements[Y] && this.elements[Y] !== !0 && this.elements[Y].getBaseElement() && (X = this.elements[Y].getBaseElement()), Y += 1; X ? this.layerElement.insertBefore(G, X) : this.layerElement.appendChild(G) } }, SVGRendererBase.prototype.hide = function () { this.layerElement.style.display = "none" }, SVGRendererBase.prototype.show = function () { this.layerElement.style.display = "block" }; function ICompElement() { } extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement), ICompElement.prototype.initElement = function (z, F, G) { this.initFrame(), this.initBaseData(z, F, G), this.initTransform(z, F, G), this.initRenderable(), this.initHierarchy(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), (this.data.xt || !F.progressiveLoad) && this.buildAllItems(), this.hide() }, ICompElement.prototype.prepareFrame = function (z) { if (this._mdf = !1, this.prepareRenderableFrame(z), this.prepareProperties(z, this.isInRange), !(!this.isInRange && !this.data.xt)) { if (this.tm._placeholder) this.renderedFrame = z / this.data.sr; else { var F = this.tm.v; F === this.data.op && (F = this.data.op - 1), this.renderedFrame = F } var G, Y = this.elements.length; for (this.completeLayers || this.checkLayers(this.renderedFrame), G = Y - 1; G >= 0; G -= 1)(this.completeLayers || this.elements[G]) && (this.elements[G].prepareFrame(this.renderedFrame - this.layers[G].st), this.elements[G]._mdf && (this._mdf = !0)) } }, ICompElement.prototype.renderInnerContent = function () { var z, F = this.layers.length; for (z = 0; z < F; z += 1)(this.completeLayers || this.elements[z]) && this.elements[z].renderFrame() }, ICompElement.prototype.setElements = function (z) { this.elements = z }, ICompElement.prototype.getElements = function () { return this.elements }, ICompElement.prototype.destroyElements = function () { var z, F = this.layers.length; for (z = 0; z < F; z += 1)this.elements[z] && this.elements[z].destroy() }, ICompElement.prototype.destroy = function () { this.destroyElements(), this.destroyBaseElement() }; function SVGCompElement(z, F, G) { this.layers = z.layers, this.supports3d = !0, this.completeLayers = !1, this.pendingElements = [], this.elements = this.layers ? createSizedArray(this.layers.length) : [], this.initElement(z, F, G), this.tm = z.tm ? PropertyFactory.getProp(this, z.tm, 0, F.frameRate, this) : { _placeholder: !0 } } extendPrototype([SVGRendererBase, ICompElement, SVGBaseElement], SVGCompElement), SVGCompElement.prototype.createComp = function (z) { return new SVGCompElement(z, this.globalData, this) }; function SVGRenderer(z, F) { this.animationItem = z, this.layers = null, this.renderedFrame = -1, this.svgElement = createNS("svg"); var G = ""; if (F && F.title) { var Y = createNS("title"), X = createElementID(); Y.setAttribute("id", X), Y.textContent = F.title, this.svgElement.appendChild(Y), G += X } if (F && F.description) { var K = createNS("desc"), J = createElementID(); K.setAttribute("id", J), K.textContent = F.description, this.svgElement.appendChild(K), G += " " + J } G && this.svgElement.setAttribute("aria-labelledby", G); var Z = createNS("defs"); this.svgElement.appendChild(Z); var Q = createNS("g"); this.svgElement.appendChild(Q), this.layerElement = Q, this.renderConfig = { preserveAspectRatio: F && F.preserveAspectRatio || "xMidYMid meet", imagePreserveAspectRatio: F && F.imagePreserveAspectRatio || "xMidYMid slice", contentVisibility: F && F.contentVisibility || "visible", progressiveLoad: F && F.progressiveLoad || !1, hideOnTransparent: !(F && F.hideOnTransparent === !1), viewBoxOnly: F && F.viewBoxOnly || !1, viewBoxSize: F && F.viewBoxSize || !1, className: F && F.className || "", id: F && F.id || "", focusable: F && F.focusable, filterSize: { width: F && F.filterSize && F.filterSize.width || "100%", height: F && F.filterSize && F.filterSize.height || "100%", x: F && F.filterSize && F.filterSize.x || "0%", y: F && F.filterSize && F.filterSize.y || "0%" }, width: F && F.width, height: F && F.height, runExpressions: !F || F.runExpressions === void 0 || F.runExpressions }, this.globalData = { _mdf: !1, frameNum: -1, defs: Z, renderConfig: this.renderConfig }, this.elements = [], this.pendingElements = [], this.destroyed = !1, this.rendererType = "svg" } extendPrototype([SVGRendererBase], SVGRenderer), SVGRenderer.prototype.createComp = function (z) { return new SVGCompElement(z, this.globalData, this) }; function ShapeTransformManager() { this.sequences = {}, this.sequenceList = [], this.transform_key_count = 0 } ShapeTransformManager.prototype = { addTransformSequence: function (F) { var G, Y = F.length, X = "_"; for (G = 0; G < Y; G += 1)X += F[G].transform.key + "_"; var K = this.sequences[X]; return K || (K = { transforms: [].concat(F), finalTransform: new Matrix, _mdf: !1 }, this.sequences[X] = K, this.sequenceList.push(K)), K }, processSequence: function (F, G) { for (var Y = 0, X = F.transforms.length, K = G; Y < X && !G;) { if (F.transforms[Y].transform.mProps._mdf) { K = !0; break } Y += 1 } if (K) for (F.finalTransform.reset(), Y = X - 1; Y >= 0; Y -= 1)F.finalTransform.multiply(F.transforms[Y].transform.mProps.v); F._mdf = K }, processSequences: function (F) { var G, Y = this.sequenceList.length; for (G = 0; G < Y; G += 1)this.processSequence(this.sequenceList[G], F) }, getNewKey: function () { return this.transform_key_count += 1, "_" + this.transform_key_count } }; var lumaLoader = function () { var F = "__lottie_element_luma_buffer", G = null, Y = null, X = null; function K() { var Q = createNS("svg"), ee = createNS("filter"), te = createNS("feColorMatrix"); return ee.setAttribute("id", F), te.setAttribute("type", "matrix"), te.setAttribute("color-interpolation-filters", "sRGB"), te.setAttribute("values", "0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0"), ee.appendChild(te), Q.appendChild(ee), Q.setAttribute("id", F + "_svg"), featureSupport.svgLumaHidden && (Q.style.display = "none"), Q } function J() { G || (X = K(), document.body.appendChild(X), G = createTag("canvas"), Y = G.getContext("2d"), Y.filter = "url(#" + F + ")", Y.fillStyle = "rgba(0,0,0,0)", Y.fillRect(0, 0, 1, 1)) } function Z(Q) { return G || J(), G.width = Q.width, G.height = Q.height, Y.filter = "url(#" + F + ")", G } return { load: J, get: Z } }; function createCanvas(z, F) { if (featureSupport.offscreenCanvas) return new OffscreenCanvas(z, F); var G = createTag("canvas"); return G.width = z, G.height = F, G } var assetLoader = function () { return { loadLumaCanvas: lumaLoader.load, getLumaCanvas: lumaLoader.get, createCanvas } }(), registeredEffects = {}; function CVEffects(z) { var F, G = z.data.ef ? z.data.ef.length : 0; this.filters = []; var Y; for (F = 0; F < G; F += 1) { Y = null; var X = z.data.ef[F].ty; if (registeredEffects[X]) { var K = registeredEffects[X].effect; Y = new K(z.effectsManager.effectElements[F], z) } Y && this.filters.push(Y) } this.filters.length && z.addRenderableComponent(this) } CVEffects.prototype.renderFrame = function (z) { var F, G = this.filters.length; for (F = 0; F < G; F += 1)this.filters[F].renderFrame(z) }, CVEffects.prototype.getEffects = function (z) { var F, G = this.filters.length, Y = []; for (F = 0; F < G; F += 1)this.filters[F].type === z && Y.push(this.filters[F]); return Y }; function registerEffect(z, F) { registeredEffects[z] = { effect: F } } function CVMaskElement(z, F) { this.data = z, this.element = F, this.masksProperties = this.data.masksProperties || [], this.viewData = createSizedArray(this.masksProperties.length); var G, Y = this.masksProperties.length, X = !1; for (G = 0; G < Y; G += 1)this.masksProperties[G].mode !== "n" && (X = !0), this.viewData[G] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[G], 3); this.hasMasks = X, X && this.element.addRenderableComponent(this) } CVMaskElement.prototype.renderFrame = function () { if (this.hasMasks) { var z = this.element.finalTransform.mat, F = this.element.canvasContext, G, Y = this.masksProperties.length, X, K, J; for (F.beginPath(), G = 0; G < Y; G += 1)if (this.masksProperties[G].mode !== "n") { this.masksProperties[G].inv && (F.moveTo(0, 0), F.lineTo(this.element.globalData.compSize.w, 0), F.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h), F.lineTo(0, this.element.globalData.compSize.h), F.lineTo(0, 0)), J = this.viewData[G].v, X = z.applyToPointArray(J.v[0][0], J.v[0][1], 0), F.moveTo(X[0], X[1]); var Z, Q = J._length; for (Z = 1; Z < Q; Z += 1)K = z.applyToTriplePoints(J.o[Z - 1], J.i[Z], J.v[Z]), F.bezierCurveTo(K[0], K[1], K[2], K[3], K[4], K[5]); K = z.applyToTriplePoints(J.o[Z - 1], J.i[0], J.v[0]), F.bezierCurveTo(K[0], K[1], K[2], K[3], K[4], K[5]) } this.element.globalData.renderer.save(!0), F.clip() } }, CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty, CVMaskElement.prototype.destroy = function () { this.element = null }; function CVBaseElement() { } var operationsMap = { 1: "source-in", 2: "source-out", 3: "source-in", 4: "source-out" }; CVBaseElement.prototype = { createElements: function () { }, initRendererElement: function () { }, createContainerElements: function () { if (this.data.tt >= 1) { this.buffers = []; var F = this.globalData.canvasContext, G = assetLoader.createCanvas(F.canvas.width, F.canvas.height); this.buffers.push(G); var Y = assetLoader.createCanvas(F.canvas.width, F.canvas.height); this.buffers.push(Y), this.data.tt >= 3 && !document._isProxy && assetLoader.loadLumaCanvas() } this.canvasContext = this.globalData.canvasContext, this.transformCanvas = this.globalData.transformCanvas, this.renderableEffectsManager = new CVEffects(this), this.searchEffectTransforms() }, createContent: function () { }, setBlendMode: function () { var F = this.globalData; if (F.blendMode !== this.data.bm) { F.blendMode = this.data.bm; var G = getBlendMode(this.data.bm); F.canvasContext.globalCompositeOperation = G } }, createRenderableComponents: function () { this.maskManager = new CVMaskElement(this.data, this), this.transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT) }, hideElement: function () { !this.hidden && (!this.isInRange || this.isTransparent) && (this.hidden = !0) }, showElement: function () { this.isInRange && !this.isTransparent && (this.hidden = !1, this._isFirstFrame = !0, this.maskManager._isFirstFrame = !0) }, clearCanvas: function (F) { F.clearRect(this.transformCanvas.tx, this.transformCanvas.ty, this.transformCanvas.w * this.transformCanvas.sx, this.transformCanvas.h * this.transformCanvas.sy) }, prepareLayer: function () { if (this.data.tt >= 1) { var F = this.buffers[0], G = F.getContext("2d"); this.clearCanvas(G), G.drawImage(this.canvasContext.canvas, 0, 0), this.currentTransform = this.canvasContext.getTransform(), this.canvasContext.setTransform(1, 0, 0, 1, 0, 0), this.clearCanvas(this.canvasContext), this.canvasContext.setTransform(this.currentTransform) } }, exitLayer: function () { if (this.data.tt >= 1) { var F = this.buffers[1], G = F.getContext("2d"); this.clearCanvas(G), G.drawImage(this.canvasContext.canvas, 0, 0), this.canvasContext.setTransform(1, 0, 0, 1, 0, 0), this.clearCanvas(this.canvasContext), this.canvasContext.setTransform(this.currentTransform); var Y = this.comp.getElementById("tp" in this.data ? this.data.tp : this.data.ind - 1); if (Y.renderFrame(!0), this.canvasContext.setTransform(1, 0, 0, 1, 0, 0), this.data.tt >= 3 && !document._isProxy) { var X = assetLoader.getLumaCanvas(this.canvasContext.canvas), K = X.getContext("2d"); K.drawImage(this.canvasContext.canvas, 0, 0), this.clearCanvas(this.canvasContext), this.canvasContext.drawImage(X, 0, 0) } this.canvasContext.globalCompositeOperation = operationsMap[this.data.tt], this.canvasContext.drawImage(F, 0, 0), this.canvasContext.globalCompositeOperation = "destination-over", this.canvasContext.drawImage(this.buffers[0], 0, 0), this.canvasContext.setTransform(this.currentTransform), this.canvasContext.globalCompositeOperation = "source-over" } }, renderFrame: function (F) { if (!(this.hidden || this.data.hd) && !(this.data.td === 1 && !F)) { this.renderTransform(), this.renderRenderable(), this.renderLocalTransform(), this.setBlendMode(); var G = this.data.ty === 0; this.prepareLayer(), this.globalData.renderer.save(G), this.globalData.renderer.ctxTransform(this.finalTransform.localMat.props), this.globalData.renderer.ctxOpacity(this.finalTransform.localOpacity), this.renderInnerContent(), this.globalData.renderer.restore(G), this.exitLayer(), this.maskManager.hasMasks && this.globalData.renderer.restore(!0), this._isFirstFrame && (this._isFirstFrame = !1) } }, destroy: function () { this.canvasContext = null, this.data = null, this.globalData = null, this.maskManager.destroy() }, mHelper: new Matrix }, CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement, CVBaseElement.prototype.show = CVBaseElement.prototype.showElement; function CVShapeData(z, F, G, Y) { this.styledShapes = [], this.tr = [0, 0, 0, 0, 0, 0]; var X = 4; F.ty === "rc" ? X = 5 : F.ty === "el" ? X = 6 : F.ty === "sr" && (X = 7), this.sh = ShapePropertyFactory.getShapeProp(z, F, X, z); var K, J = G.length, Z; for (K = 0; K < J; K += 1)G[K].closed || (Z = { transforms: Y.addTransformSequence(G[K].transforms), trNodes: [] }, this.styledShapes.push(Z), G[K].elements.push(Z)) } CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated; function CVShapeElement(z, F, G) { this.shapes = [], this.shapesData = z.shapes, this.stylesList = [], this.itemsData = [], this.prevViewData = [], this.shapeModifiers = [], this.processedElements = [], this.transformsManager = new ShapeTransformManager, this.initElement(z, F, G) } extendPrototype([BaseElement, TransformElement, CVBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableElement], CVShapeElement), CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement, CVShapeElement.prototype.transformHelper = { opacity: 1, _opMdf: !1 }, CVShapeElement.prototype.dashResetter = [], CVShapeElement.prototype.createContent = function () { this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, []) }, CVShapeElement.prototype.createStyleElement = function (z, F) { var G = { data: z, type: z.ty, preTransforms: this.transformsManager.addTransformSequence(F), transforms: [], elements: [], closed: z.hd === !0 }, Y = {}; if (z.ty === "fl" || z.ty === "st" ? (Y.c = PropertyFactory.getProp(this, z.c, 1, 255, this), Y.c.k || (G.co = "rgb(" + bmFloor(Y.c.v[0]) + "," + bmFloor(Y.c.v[1]) + "," + bmFloor(Y.c.v[2]) + ")")) : (z.ty === "gf" || z.ty === "gs") && (Y.s = PropertyFactory.getProp(this, z.s, 1, null, this), Y.e = PropertyFactory.getProp(this, z.e, 1, null, this), Y.h = PropertyFactory.getProp(this, z.h || { k: 0 }, 0, .01, this), Y.a = PropertyFactory.getProp(this, z.a || { k: 0 }, 0, degToRads, this), Y.g = new GradientProperty(this, z.g, this)), Y.o = PropertyFactory.getProp(this, z.o, 0, .01, this), z.ty === "st" || z.ty === "gs") { if (G.lc = lineCapEnum[z.lc || 2], G.lj = lineJoinEnum[z.lj || 2], z.lj == 1 && (G.ml = z.ml), Y.w = PropertyFactory.getProp(this, z.w, 0, null, this), Y.w.k || (G.wi = Y.w.v), z.d) { var X = new DashProperty(this, z.d, "canvas", this); Y.d = X, Y.d.k || (G.da = Y.d.dashArray, G.do = Y.d.dashoffset[0]) } } else G.r = z.r === 2 ? "evenodd" : "nonzero"; return this.stylesList.push(G), Y.style = G, Y }, CVShapeElement.prototype.createGroupElement = function () { var z = { it: [], prevViewData: [] }; return z }, CVShapeElement.prototype.createTransformElement = function (z) { var F = { transform: { opacity: 1, _opMdf: !1, key: this.transformsManager.getNewKey(), op: PropertyFactory.getProp(this, z.o, 0, .01, this), mProps: TransformPropertyFactory.getTransformProperty(this, z, this) } }; return F }, CVShapeElement.prototype.createShapeElement = function (z) { var F = new CVShapeData(this, z, this.stylesList, this.transformsManager); return this.shapes.push(F), this.addShapeToModifiers(F), F }, CVShapeElement.prototype.reloadShapes = function () { this._isFirstFrame = !0; var z, F = this.itemsData.length; for (z = 0; z < F; z += 1)this.prevViewData[z] = this.itemsData[z]; for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, []), F = this.dynamicProperties.length, z = 0; z < F; z += 1)this.dynamicProperties[z].getValue(); this.renderModifiers(), this.transformsManager.processSequences(this._isFirstFrame) }, CVShapeElement.prototype.addTransformToStyleList = function (z) { var F, G = this.stylesList.length; for (F = 0; F < G; F += 1)this.stylesList[F].closed || this.stylesList[F].transforms.push(z) }, CVShapeElement.prototype.removeTransformFromStyleList = function () { var z, F = this.stylesList.length; for (z = 0; z < F; z += 1)this.stylesList[z].closed || this.stylesList[z].transforms.pop() }, CVShapeElement.prototype.closeStyles = function (z) { var F, G = z.length; for (F = 0; F < G; F += 1)z[F].closed = !0 }, CVShapeElement.prototype.searchShapes = function (z, F, G, Y, X) { var K, J = z.length - 1, Z, Q, ee = [], te = [], oe, ie, se, ne = [].concat(X); for (K = J; K >= 0; K -= 1) { if (oe = this.searchProcessedElement(z[K]), oe ? F[K] = G[oe - 1] : z[K]._shouldRender = Y, z[K].ty === "fl" || z[K].ty === "st" || z[K].ty === "gf" || z[K].ty === "gs") oe ? F[K].style.closed = !1 : F[K] = this.createStyleElement(z[K], ne), ee.push(F[K].style); else if (z[K].ty === "gr") { if (!oe) F[K] = this.createGroupElement(z[K]); else for (Q = F[K].it.length, Z = 0; Z < Q; Z += 1)F[K].prevViewData[Z] = F[K].it[Z]; this.searchShapes(z[K].it, F[K].it, F[K].prevViewData, Y, ne) } else z[K].ty === "tr" ? (oe || (se = this.createTransformElement(z[K]), F[K] = se), ne.push(F[K]), this.addTransformToStyleList(F[K])) : z[K].ty === "sh" || z[K].ty === "rc" || z[K].ty === "el" || z[K].ty === "sr" ? oe || (F[K] = this.createShapeElement(z[K])) : z[K].ty === "tm" || z[K].ty === "rd" || z[K].ty === "pb" || z[K].ty === "zz" || z[K].ty === "op" ? (oe ? (ie = F[K], ie.closed = !1) : (ie = ShapeModifiers.getModifier(z[K].ty), ie.init(this, z[K]), F[K] = ie, this.shapeModifiers.push(ie)), te.push(ie)) : z[K].ty === "rp" && (oe ? (ie = F[K], ie.closed = !0) : (ie = ShapeModifiers.getModifier(z[K].ty), F[K] = ie, ie.init(this, z, K, F), this.shapeModifiers.push(ie), Y = !1), te.push(ie)); this.addProcessedElement(z[K], K + 1) } for (this.removeTransformFromStyleList(), this.closeStyles(ee), J = te.length, K = 0; K < J; K += 1)te[K].closed = !0 }, CVShapeElement.prototype.renderInnerContent = function () { this.transformHelper.opacity = 1, this.transformHelper._opMdf = !1, this.renderModifiers(), this.transformsManager.processSequences(this._isFirstFrame), this.renderShape(this.transformHelper, this.shapesData, this.itemsData, !0) }, CVShapeElement.prototype.renderShapeTransform = function (z, F) { (z._opMdf || F.op._mdf || this._isFirstFrame) && (F.opacity = z.opacity, F.opacity *= F.op.v, F._opMdf = !0) }, CVShapeElement.prototype.drawLayer = function () { var z, F = this.stylesList.length, G, Y, X, K, J, Z, Q = this.globalData.renderer, ee = this.globalData.canvasContext, te, oe; for (z = 0; z < F; z += 1)if (oe = this.stylesList[z], te = oe.type, !((te === "st" || te === "gs") && oe.wi === 0 || !oe.data._shouldRender || oe.coOp === 0 || this.globalData.currentGlobalAlpha === 0)) { for (Q.save(), J = oe.elements, te === "st" || te === "gs" ? (Q.ctxStrokeStyle(te === "st" ? oe.co : oe.grd), Q.ctxLineWidth(oe.wi), Q.ctxLineCap(oe.lc), Q.ctxLineJoin(oe.lj), Q.ctxMiterLimit(oe.ml || 0)) : Q.ctxFillStyle(te === "fl" ? oe.co : oe.grd), Q.ctxOpacity(oe.coOp), te !== "st" && te !== "gs" && ee.beginPath(), Q.ctxTransform(oe.preTransforms.finalTransform.props), Y = J.length, G = 0; G < Y; G += 1) { for ((te === "st" || te === "gs") && (ee.beginPath(), oe.da && (ee.setLineDash(oe.da), ee.lineDashOffset = oe.do)), Z = J[G].trNodes, K = Z.length, X = 0; X < K; X += 1)Z[X].t === "m" ? ee.moveTo(Z[X].p[0], Z[X].p[1]) : Z[X].t === "c" ? ee.bezierCurveTo(Z[X].pts[0], Z[X].pts[1], Z[X].pts[2], Z[X].pts[3], Z[X].pts[4], Z[X].pts[5]) : ee.closePath(); (te === "st" || te === "gs") && (Q.ctxStroke(), oe.da && ee.setLineDash(this.dashResetter)) } te !== "st" && te !== "gs" && this.globalData.renderer.ctxFill(oe.r), Q.restore() } }, CVShapeElement.prototype.renderShape = function (z, F, G, Y) { var X, K = F.length - 1, J; for (J = z, X = K; X >= 0; X -= 1)F[X].ty === "tr" ? (J = G[X].transform, this.renderShapeTransform(z, J)) : F[X].ty === "sh" || F[X].ty === "el" || F[X].ty === "rc" || F[X].ty === "sr" ? this.renderPath(F[X], G[X]) : F[X].ty === "fl" ? this.renderFill(F[X], G[X], J) : F[X].ty === "st" ? this.renderStroke(F[X], G[X], J) : F[X].ty === "gf" || F[X].ty === "gs" ? this.renderGradientFill(F[X], G[X], J) : F[X].ty === "gr" ? this.renderShape(J, F[X].it, G[X].it) : F[X].ty; Y && this.drawLayer() }, CVShapeElement.prototype.renderStyledShape = function (z, F) { if (this._isFirstFrame || F._mdf || z.transforms._mdf) { var G = z.trNodes, Y = F.paths, X, K, J, Z = Y._length; G.length = 0; var Q = z.transforms.finalTransform; for (J = 0; J < Z; J += 1) { var ee = Y.shapes[J]; if (ee && ee.v) { for (K = ee._length, X = 1; X < K; X += 1)X === 1 && G.push({ t: "m", p: Q.applyToPointArray(ee.v[0][0], ee.v[0][1], 0) }), G.push({ t: "c", pts: Q.applyToTriplePoints(ee.o[X - 1], ee.i[X], ee.v[X]) }); K === 1 && G.push({ t: "m", p: Q.applyToPointArray(ee.v[0][0], ee.v[0][1], 0) }), ee.c && K && (G.push({ t: "c", pts: Q.applyToTriplePoints(ee.o[X - 1], ee.i[0], ee.v[0]) }), G.push({ t: "z" })) } } z.trNodes = G } }, CVShapeElement.prototype.renderPath = function (z, F) { if (z.hd !== !0 && z._shouldRender) { var G, Y = F.styledShapes.length; for (G = 0; G < Y; G += 1)this.renderStyledShape(F.styledShapes[G], F.sh) } }, CVShapeElement.prototype.renderFill = function (z, F, G) { var Y = F.style; (F.c._mdf || this._isFirstFrame) && (Y.co = "rgb(" + bmFloor(F.c.v[0]) + "," + bmFloor(F.c.v[1]) + "," + bmFloor(F.c.v[2]) + ")"), (F.o._mdf || G._opMdf || this._isFirstFrame) && (Y.coOp = F.o.v * G.opacity) }, CVShapeElement.prototype.renderGradientFill = function (z, F, G) { var Y = F.style, X; if (!Y.grd || F.g._mdf || F.s._mdf || F.e._mdf || z.t !== 1 && (F.h._mdf || F.a._mdf)) { var K = this.globalData.canvasContext, J = F.s.v, Z = F.e.v; if (z.t === 1) X = K.createLinearGradient(J[0], J[1], Z[0], Z[1]); else { var Q = Math.sqrt(Math.pow(J[0] - Z[0], 2) + Math.pow(J[1] - Z[1], 2)), ee = Math.atan2(Z[1] - J[1], Z[0] - J[0]), te = F.h.v; te >= 1 ? te = .99 : te <= -1 && (te = -.99); var oe = Q * te, ie = Math.cos(ee + F.a.v) * oe + J[0], se = Math.sin(ee + F.a.v) * oe + J[1]; X = K.createRadialGradient(ie, se, 0, J[0], J[1], Q) } var ne, re = z.g.p, fe = F.g.c, ae = 1; for (ne = 0; ne < re; ne += 1)F.g._hasOpacity && F.g._collapsable && (ae = F.g.o[ne * 2 + 1]), X.addColorStop(fe[ne * 4] / 100, "rgba(" + fe[ne * 4 + 1] + "," + fe[ne * 4 + 2] + "," + fe[ne * 4 + 3] + "," + ae + ")"); Y.grd = X } Y.coOp = F.o.v * G.opacity }, CVShapeElement.prototype.renderStroke = function (z, F, G) { var Y = F.style, X = F.d; X && (X._mdf || this._isFirstFrame) && (Y.da = X.dashArray, Y.do = X.dashoffset[0]), (F.c._mdf || this._isFirstFrame) && (Y.co = "rgb(" + bmFloor(F.c.v[0]) + "," + bmFloor(F.c.v[1]) + "," + bmFloor(F.c.v[2]) + ")"), (F.o._mdf || G._opMdf || this._isFirstFrame) && (Y.coOp = F.o.v * G.opacity), (F.w._mdf || this._isFirstFrame) && (Y.wi = F.w.v) }, CVShapeElement.prototype.destroy = function () { this.shapesData = null, this.globalData = null, this.canvasContext = null, this.stylesList.length = 0, this.itemsData.length = 0 }; function CVTextElement(z, F, G) { this.textSpans = [], this.yOffset = 0, this.fillColorAnim = !1, this.strokeColorAnim = !1, this.strokeWidthAnim = !1, this.stroke = !1, this.fill = !1, this.justifyOffset = 0, this.currentRender = null, this.renderType = "canvas", this.values = { fill: "rgba(0,0,0,0)", stroke: "rgba(0,0,0,0)", sWidth: 0, fValue: "" }, this.initElement(z, F, G) } extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement, ITextElement], CVTextElement), CVTextElement.prototype.tHelper = createTag("canvas").getContext("2d"), CVTextElement.prototype.buildNewText = function () { var z = this.textProperty.currentData; this.renderedLetters = createSizedArray(z.l ? z.l.length : 0); var F = !1; z.fc ? (F = !0, this.values.fill = this.buildColor(z.fc)) : this.values.fill = "rgba(0,0,0,0)", this.fill = F; var G = !1; z.sc && (G = !0, this.values.stroke = this.buildColor(z.sc), this.values.sWidth = z.sw); var Y = this.globalData.fontManager.getFontByName(z.f), X, K, J = z.l, Z = this.mHelper; this.stroke = G, this.values.fValue = z.finalSize + "px " + this.globalData.fontManager.getFontByName(z.f).fFamily, K = z.finalText.length; var Q, ee, te, oe, ie, se, ne, re, fe, ae, he = this.data.singleShape, le = z.tr * .001 * z.finalSize, ce = 0, ue = 0, me = !0, ge = 0; for (X = 0; X < K; X += 1) { Q = this.globalData.fontManager.getCharData(z.finalText[X], Y.fStyle, this.globalData.fontManager.getFontByName(z.f).fFamily), ee = Q && Q.data || {}, Z.reset(), he && J[X].n && (ce = -le, ue += z.yOffset, ue += me ? 1 : 0, me = !1), ie = ee.shapes ? ee.shapes[0].it : [], ne = ie.length, Z.scale(z.finalSize / 100, z.finalSize / 100), he && this.applyTextPropertiesToMatrix(z, Z, J[X].line, ce, ue), fe = createSizedArray(ne - 1); var ve = 0; for (se = 0; se < ne; se += 1)if (ie[se].ty === "sh") { for (oe = ie[se].ks.k.i.length, re = ie[se].ks.k, ae = [], te = 1; te < oe; te += 1)te === 1 && ae.push(Z.applyToX(re.v[0][0], re.v[0][1], 0), Z.applyToY(re.v[0][0], re.v[0][1], 0)), ae.push(Z.applyToX(re.o[te - 1][0], re.o[te - 1][1], 0), Z.applyToY(re.o[te - 1][0], re.o[te - 1][1], 0), Z.applyToX(re.i[te][0], re.i[te][1], 0), Z.applyToY(re.i[te][0], re.i[te][1], 0), Z.applyToX(re.v[te][0], re.v[te][1], 0), Z.applyToY(re.v[te][0], re.v[te][1], 0)); ae.push(Z.applyToX(re.o[te - 1][0], re.o[te - 1][1], 0), Z.applyToY(re.o[te - 1][0], re.o[te - 1][1], 0), Z.applyToX(re.i[0][0], re.i[0][1], 0), Z.applyToY(re.i[0][0], re.i[0][1], 0), Z.applyToX(re.v[0][0], re.v[0][1], 0), Z.applyToY(re.v[0][0], re.v[0][1], 0)), fe[ve] = ae, ve += 1 } he && (ce += J[X].l, ce += le), this.textSpans[ge] ? this.textSpans[ge].elem = fe : this.textSpans[ge] = { elem: fe }, ge += 1 } }, CVTextElement.prototype.renderInnerContent = function () { this.validateText(); var z = this.canvasContext; z.font = this.values.fValue, this.globalData.renderer.ctxLineCap("butt"), this.globalData.renderer.ctxLineJoin("miter"), this.globalData.renderer.ctxMiterLimit(4), this.data.singleShape || this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag); var F, G, Y, X, K, J, Z = this.textAnimator.renderedLetters, Q = this.textProperty.currentData.l; G = Q.length; var ee, te = null, oe = null, ie = null, se, ne, re = this.globalData.renderer; for (F = 0; F < G; F += 1)if (!Q[F].n) { if (ee = Z[F], ee && (re.save(), re.ctxTransform(ee.p), re.ctxOpacity(ee.o)), this.fill) { for (ee && ee.fc ? te !== ee.fc && (re.ctxFillStyle(ee.fc), te = ee.fc) : te !== this.values.fill && (te = this.values.fill, re.ctxFillStyle(this.values.fill)), se = this.textSpans[F].elem, X = se.length, this.globalData.canvasContext.beginPath(), Y = 0; Y < X; Y += 1)for (ne = se[Y], J = ne.length, this.globalData.canvasContext.moveTo(ne[0], ne[1]), K = 2; K < J; K += 6)this.globalData.canvasContext.bezierCurveTo(ne[K], ne[K + 1], ne[K + 2], ne[K + 3], ne[K + 4], ne[K + 5]); this.globalData.canvasContext.closePath(), re.ctxFill() } if (this.stroke) { for (ee && ee.sw ? ie !== ee.sw && (ie = ee.sw, re.ctxLineWidth(ee.sw)) : ie !== this.values.sWidth && (ie = this.values.sWidth, re.ctxLineWidth(this.values.sWidth)), ee && ee.sc ? oe !== ee.sc && (oe = ee.sc, re.ctxStrokeStyle(ee.sc)) : oe !== this.values.stroke && (oe = this.values.stroke, re.ctxStrokeStyle(this.values.stroke)), se = this.textSpans[F].elem, X = se.length, this.globalData.canvasContext.beginPath(), Y = 0; Y < X; Y += 1)for (ne = se[Y], J = ne.length, this.globalData.canvasContext.moveTo(ne[0], ne[1]), K = 2; K < J; K += 6)this.globalData.canvasContext.bezierCurveTo(ne[K], ne[K + 1], ne[K + 2], ne[K + 3], ne[K + 4], ne[K + 5]); this.globalData.canvasContext.closePath(), re.ctxStroke() } ee && this.globalData.renderer.restore() } }; function CVImageElement(z, F, G) { this.assetData = F.getAssetData(z.refId), this.img = F.imageLoader.getAsset(this.assetData), this.initElement(z, F, G) } extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement), CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement, CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame, CVImageElement.prototype.createContent = function () { if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) { var z = createTag("canvas"); z.width = this.assetData.w, z.height = this.assetData.h; var F = z.getContext("2d"), G = this.img.width, Y = this.img.height, X = G / Y, K = this.assetData.w / this.assetData.h, J, Z, Q = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio; X > K && Q === "xMidYMid slice" || X < K && Q !== "xMidYMid slice" ? (Z = Y, J = Z * K) : (J = G, Z = J / K), F.drawImage(this.img, (G - J) / 2, (Y - Z) / 2, J, Z, 0, 0, this.assetData.w, this.assetData.h), this.img = z } }, CVImageElement.prototype.renderInnerContent = function () { this.canvasContext.drawImage(this.img, 0, 0) }, CVImageElement.prototype.destroy = function () { this.img = null }; function CVSolidElement(z, F, G) { this.initElement(z, F, G) } extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement), CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement, CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame, CVSolidElement.prototype.renderInnerContent = function () { this.globalData.renderer.ctxFillStyle(this.data.sc), this.globalData.renderer.ctxFillRect(0, 0, this.data.sw, this.data.sh) }; function CanvasRendererBase() { } extendPrototype([BaseRenderer], CanvasRendererBase), CanvasRendererBase.prototype.createShape = function (z) { return new CVShapeElement(z, this.globalData, this) }, CanvasRendererBase.prototype.createText = function (z) { return new CVTextElement(z, this.globalData, this) }, CanvasRendererBase.prototype.createImage = function (z) { return new CVImageElement(z, this.globalData, this) }, CanvasRendererBase.prototype.createSolid = function (z) { return new CVSolidElement(z, this.globalData, this) }, CanvasRendererBase.prototype.createNull = SVGRenderer.prototype.createNull, CanvasRendererBase.prototype.ctxTransform = function (z) { z[0] === 1 && z[1] === 0 && z[4] === 0 && z[5] === 1 && z[12] === 0 && z[13] === 0 || this.canvasContext.transform(z[0], z[1], z[4], z[5], z[12], z[13]) }, CanvasRendererBase.prototype.ctxOpacity = function (z) { this.canvasContext.globalAlpha *= z < 0 ? 0 : z }, CanvasRendererBase.prototype.ctxFillStyle = function (z) { this.canvasContext.fillStyle = z }, CanvasRendererBase.prototype.ctxStrokeStyle = function (z) { this.canvasContext.strokeStyle = z }, CanvasRendererBase.prototype.ctxLineWidth = function (z) { this.canvasContext.lineWidth = z }, CanvasRendererBase.prototype.ctxLineCap = function (z) { this.canvasContext.lineCap = z }, CanvasRendererBase.prototype.ctxLineJoin = function (z) { this.canvasContext.lineJoin = z }, CanvasRendererBase.prototype.ctxMiterLimit = function (z) { this.canvasContext.miterLimit = z }, CanvasRendererBase.prototype.ctxFill = function (z) { this.canvasContext.fill(z) }, CanvasRendererBase.prototype.ctxFillRect = function (z, F, G, Y) { this.canvasContext.fillRect(z, F, G, Y) }, CanvasRendererBase.prototype.ctxStroke = function () { this.canvasContext.stroke() }, CanvasRendererBase.prototype.reset = function () { if (!this.renderConfig.clearCanvas) { this.canvasContext.restore(); return } this.contextData.reset() }, CanvasRendererBase.prototype.save = function () { this.canvasContext.save() }, CanvasRendererBase.prototype.restore = function (z) { if (!this.renderConfig.clearCanvas) { this.canvasContext.restore(); return } z && (this.globalData.blendMode = "source-over"), this.contextData.restore(z) }, CanvasRendererBase.prototype.configAnimation = function (z) { if (this.animationItem.wrapper) { this.animationItem.container = createTag("canvas"); var F = this.animationItem.container.style; F.width = "100%", F.height = "100%"; var G = "0px 0px 0px"; F.transformOrigin = G, F.mozTransformOrigin = G, F.webkitTransformOrigin = G, F["-webkit-transform"] = G, F.contentVisibility = this.renderConfig.contentVisibility, this.animationItem.wrapper.appendChild(this.animationItem.container), this.canvasContext = this.animationItem.container.getContext("2d"), this.renderConfig.className && this.animationItem.container.setAttribute("class", this.renderConfig.className), this.renderConfig.id && this.animationItem.container.setAttribute("id", this.renderConfig.id) } else this.canvasContext = this.renderConfig.context; this.contextData.setContext(this.canvasContext), this.data = z, this.layers = z.layers, this.transformCanvas = { w: z.w, h: z.h, sx: 0, sy: 0, tx: 0, ty: 0 }, this.setupGlobalData(z, document.body), this.globalData.canvasContext = this.canvasContext, this.globalData.renderer = this, this.globalData.isDashed = !1, this.globalData.progressiveLoad = this.renderConfig.progressiveLoad, this.globalData.transformCanvas = this.transformCanvas, this.elements = createSizedArray(z.layers.length), this.updateContainerSize() }, CanvasRendererBase.prototype.updateContainerSize = function (z, F) { this.reset(); var G, Y; z ? (G = z, Y = F, this.canvasContext.canvas.width = G, this.canvasContext.canvas.height = Y) : (this.animationItem.wrapper && this.animationItem.container ? (G = this.animationItem.wrapper.offsetWidth, Y = this.animationItem.wrapper.offsetHeight) : (G = this.canvasContext.canvas.width, Y = this.canvasContext.canvas.height), this.canvasContext.canvas.width = G * this.renderConfig.dpr, this.canvasContext.canvas.height = Y * this.renderConfig.dpr); var X, K; if (this.renderConfig.preserveAspectRatio.indexOf("meet") !== -1 || this.renderConfig.preserveAspectRatio.indexOf("slice") !== -1) { var J = this.renderConfig.preserveAspectRatio.split(" "), Z = J[1] || "meet", Q = J[0] || "xMidYMid", ee = Q.substr(0, 4), te = Q.substr(4); X = G / Y, K = this.transformCanvas.w / this.transformCanvas.h, K > X && Z === "meet" || K < X && Z === "slice" ? (this.transformCanvas.sx = G / (this.transformCanvas.w / this.renderConfig.dpr), this.transformCanvas.sy = G / (this.transformCanvas.w / this.renderConfig.dpr)) : (this.transformCanvas.sx = Y / (this.transformCanvas.h / this.renderConfig.dpr), this.transformCanvas.sy = Y / (this.transformCanvas.h / this.renderConfig.dpr)), ee === "xMid" && (K < X && Z === "meet" || K > X && Z === "slice") ? this.transformCanvas.tx = (G - this.transformCanvas.w * (Y / this.transformCanvas.h)) / 2 * this.renderConfig.dpr : ee === "xMax" && (K < X && Z === "meet" || K > X && Z === "slice") ? this.transformCanvas.tx = (G - this.transformCanvas.w * (Y / this.transformCanvas.h)) * this.renderConfig.dpr : this.transformCanvas.tx = 0, te === "YMid" && (K > X && Z === "meet" || K < X && Z === "slice") ? this.transformCanvas.ty = (Y - this.transformCanvas.h * (G / this.transformCanvas.w)) / 2 * this.renderConfig.dpr : te === "YMax" && (K > X && Z === "meet" || K < X && Z === "slice") ? this.transformCanvas.ty = (Y - this.transformCanvas.h * (G / this.transformCanvas.w)) * this.renderConfig.dpr : this.transformCanvas.ty = 0 } else this.renderConfig.preserveAspectRatio === "none" ? (this.transformCanvas.sx = G / (this.transformCanvas.w / this.renderConfig.dpr), this.transformCanvas.sy = Y / (this.transformCanvas.h / this.renderConfig.dpr), this.transformCanvas.tx = 0, this.transformCanvas.ty = 0) : (this.transformCanvas.sx = this.renderConfig.dpr, this.transformCanvas.sy = this.renderConfig.dpr, this.transformCanvas.tx = 0, this.transformCanvas.ty = 0); this.transformCanvas.props = [this.transformCanvas.sx, 0, 0, 0, 0, this.transformCanvas.sy, 0, 0, 0, 0, 1, 0, this.transformCanvas.tx, this.transformCanvas.ty, 0, 1], this.ctxTransform(this.transformCanvas.props), this.canvasContext.beginPath(), this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h), this.canvasContext.closePath(), this.canvasContext.clip(), this.renderFrame(this.renderedFrame, !0) }, CanvasRendererBase.prototype.destroy = function () { this.renderConfig.clearCanvas && this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""); var z, F = this.layers ? this.layers.length : 0; for (z = F - 1; z >= 0; z -= 1)this.elements[z] && this.elements[z].destroy && this.elements[z].destroy(); this.elements.length = 0, this.globalData.canvasContext = null, this.animationItem.container = null, this.destroyed = !0 }, CanvasRendererBase.prototype.renderFrame = function (z, F) { if (!(this.renderedFrame === z && this.renderConfig.clearCanvas === !0 && !F || this.destroyed || z === -1)) { this.renderedFrame = z, this.globalData.frameNum = z - this.animationItem._isFirstFrame, this.globalData.frameId += 1, this.globalData._mdf = !this.renderConfig.clearCanvas || F, this.globalData.projectInterface.currentFrame = z; var G, Y = this.layers.length; for (this.completeLayers || this.checkLayers(z), G = Y - 1; G >= 0; G -= 1)(this.completeLayers || this.elements[G]) && this.elements[G].prepareFrame(z - this.layers[G].st); if (this.globalData._mdf) { for (this.renderConfig.clearCanvas === !0 ? this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h) : this.save(), G = Y - 1; G >= 0; G -= 1)(this.completeLayers || this.elements[G]) && this.elements[G].renderFrame(); this.renderConfig.clearCanvas !== !0 && this.restore() } } }, CanvasRendererBase.prototype.buildItem = function (z) { var F = this.elements; if (!(F[z] || this.layers[z].ty === 99)) { var G = this.createItem(this.layers[z], this, this.globalData); F[z] = G, G.initExpressions() } }, CanvasRendererBase.prototype.checkPendingElements = function () { for (; this.pendingElements.length;) { var z = this.pendingElements.pop(); z.checkParenting() } }, CanvasRendererBase.prototype.hide = function () { this.animationItem.container.style.display = "none" }, CanvasRendererBase.prototype.show = function () { this.animationItem.container.style.display = "block" }; function CanvasContext() { this.opacity = -1, this.transform = createTypedArray("float32", 16), this.fillStyle = "", this.strokeStyle = "", this.lineWidth = "", this.lineCap = "", this.lineJoin = "", this.miterLimit = "", this.id = Math.random() } function CVContextData() { this.stack = [], this.cArrPos = 0, this.cTr = new Matrix; var z, F = 15; for (z = 0; z < F; z += 1) { var G = new CanvasContext; this.stack[z] = G } this._length = F, this.nativeContext = null, this.transformMat = new Matrix, this.currentOpacity = 1, this.currentFillStyle = "", this.appliedFillStyle = "", this.currentStrokeStyle = "", this.appliedStrokeStyle = "", this.currentLineWidth = "", this.appliedLineWidth = "", this.currentLineCap = "", this.appliedLineCap = "", this.currentLineJoin = "", this.appliedLineJoin = "", this.appliedMiterLimit = "", this.currentMiterLimit = "" } CVContextData.prototype.duplicate = function () { var z = this._length * 2, F = 0; for (F = this._length; F < z; F += 1)this.stack[F] = new CanvasContext; this._length = z }, CVContextData.prototype.reset = function () { this.cArrPos = 0, this.cTr.reset(), this.stack[this.cArrPos].opacity = 1 }, CVContextData.prototype.restore = function (z) { this.cArrPos -= 1; var F = this.stack[this.cArrPos], G = F.transform, Y, X = this.cTr.props; for (Y = 0; Y < 16; Y += 1)X[Y] = G[Y]; if (z) { this.nativeContext.restore(); var K = this.stack[this.cArrPos + 1]; this.appliedFillStyle = K.fillStyle, this.appliedStrokeStyle = K.strokeStyle, this.appliedLineWidth = K.lineWidth, this.appliedLineCap = K.lineCap, this.appliedLineJoin = K.lineJoin, this.appliedMiterLimit = K.miterLimit } this.nativeContext.setTransform(G[0], G[1], G[4], G[5], G[12], G[13]), (z || F.opacity !== -1 && this.currentOpacity !== F.opacity) && (this.nativeContext.globalAlpha = F.opacity, this.currentOpacity = F.opacity), this.currentFillStyle = F.fillStyle, this.currentStrokeStyle = F.strokeStyle, this.currentLineWidth = F.lineWidth, this.currentLineCap = F.lineCap, this.currentLineJoin = F.lineJoin, this.currentMiterLimit = F.miterLimit }, CVContextData.prototype.save = function (z) { z && this.nativeContext.save(); var F = this.cTr.props; this._length <= this.cArrPos && this.duplicate(); var G = this.stack[this.cArrPos], Y; for (Y = 0; Y < 16; Y += 1)G.transform[Y] = F[Y]; this.cArrPos += 1; var X = this.stack[this.cArrPos]; X.opacity = G.opacity, X.fillStyle = G.fillStyle, X.strokeStyle = G.strokeStyle, X.lineWidth = G.lineWidth, X.lineCap = G.lineCap, X.lineJoin = G.lineJoin, X.miterLimit = G.miterLimit }, CVContextData.prototype.setOpacity = function (z) { this.stack[this.cArrPos].opacity = z }, CVContextData.prototype.setContext = function (z) { this.nativeContext = z }, CVContextData.prototype.fillStyle = function (z) { this.stack[this.cArrPos].fillStyle !== z && (this.currentFillStyle = z, this.stack[this.cArrPos].fillStyle = z) }, CVContextData.prototype.strokeStyle = function (z) { this.stack[this.cArrPos].strokeStyle !== z && (this.currentStrokeStyle = z, this.stack[this.cArrPos].strokeStyle = z) }, CVContextData.prototype.lineWidth = function (z) { this.stack[this.cArrPos].lineWidth !== z && (this.currentLineWidth = z, this.stack[this.cArrPos].lineWidth = z) }, CVContextData.prototype.lineCap = function (z) { this.stack[this.cArrPos].lineCap !== z && (this.currentLineCap = z, this.stack[this.cArrPos].lineCap = z) }, CVContextData.prototype.lineJoin = function (z) { this.stack[this.cArrPos].lineJoin !== z && (this.currentLineJoin = z, this.stack[this.cArrPos].lineJoin = z) }, CVContextData.prototype.miterLimit = function (z) { this.stack[this.cArrPos].miterLimit !== z && (this.currentMiterLimit = z, this.stack[this.cArrPos].miterLimit = z) }, CVContextData.prototype.transform = function (z) { this.transformMat.cloneFromProps(z); var F = this.cTr; this.transformMat.multiply(F), F.cloneFromProps(this.transformMat.props); var G = F.props; this.nativeContext.setTransform(G[0], G[1], G[4], G[5], G[12], G[13]) }, CVContextData.prototype.opacity = function (z) { var F = this.stack[this.cArrPos].opacity; F *= z < 0 ? 0 : z, this.stack[this.cArrPos].opacity !== F && (this.currentOpacity !== z && (this.nativeContext.globalAlpha = z, this.currentOpacity = z), this.stack[this.cArrPos].opacity = F) }, CVContextData.prototype.fill = function (z) { this.appliedFillStyle !== this.currentFillStyle && (this.appliedFillStyle = this.currentFillStyle, this.nativeContext.fillStyle = this.appliedFillStyle), this.nativeContext.fill(z) }, CVContextData.prototype.fillRect = function (z, F, G, Y) { this.appliedFillStyle !== this.currentFillStyle && (this.appliedFillStyle = this.currentFillStyle, this.nativeContext.fillStyle = this.appliedFillStyle), this.nativeContext.fillRect(z, F, G, Y) }, CVContextData.prototype.stroke = function () { this.appliedStrokeStyle !== this.currentStrokeStyle && (this.appliedStrokeStyle = this.currentStrokeStyle, this.nativeContext.strokeStyle = this.appliedStrokeStyle), this.appliedLineWidth !== this.currentLineWidth && (this.appliedLineWidth = this.currentLineWidth, this.nativeContext.lineWidth = this.appliedLineWidth), this.appliedLineCap !== this.currentLineCap && (this.appliedLineCap = this.currentLineCap, this.nativeContext.lineCap = this.appliedLineCap), this.appliedLineJoin !== this.currentLineJoin && (this.appliedLineJoin = this.currentLineJoin, this.nativeContext.lineJoin = this.appliedLineJoin), this.appliedMiterLimit !== this.currentMiterLimit && (this.appliedMiterLimit = this.currentMiterLimit, this.nativeContext.miterLimit = this.appliedMiterLimit), this.nativeContext.stroke() }; function CVCompElement(z, F, G) { this.completeLayers = !1, this.layers = z.layers, this.pendingElements = [], this.elements = createSizedArray(this.layers.length), this.initElement(z, F, G), this.tm = z.tm ? PropertyFactory.getProp(this, z.tm, 0, F.frameRate, this) : { _placeholder: !0 } } extendPrototype([CanvasRendererBase, ICompElement, CVBaseElement], CVCompElement), CVCompElement.prototype.renderInnerContent = function () { var z = this.canvasContext; z.beginPath(), z.moveTo(0, 0), z.lineTo(this.data.w, 0), z.lineTo(this.data.w, this.data.h), z.lineTo(0, this.data.h), z.lineTo(0, 0), z.clip(); var F, G = this.layers.length; for (F = G - 1; F >= 0; F -= 1)(this.completeLayers || this.elements[F]) && this.elements[F].renderFrame() }, CVCompElement.prototype.destroy = function () { var z, F = this.layers.length; for (z = F - 1; z >= 0; z -= 1)this.elements[z] && this.elements[z].destroy(); this.layers = null, this.elements = null }, CVCompElement.prototype.createComp = function (z) { return new CVCompElement(z, this.globalData, this) }; function CanvasRenderer(z, F) { this.animationItem = z, this.renderConfig = { clearCanvas: F && F.clearCanvas !== void 0 ? F.clearCanvas : !0, context: F && F.context || null, progressiveLoad: F && F.progressiveLoad || !1, preserveAspectRatio: F && F.preserveAspectRatio || "xMidYMid meet", imagePreserveAspectRatio: F && F.imagePreserveAspectRatio || "xMidYMid slice", contentVisibility: F && F.contentVisibility || "visible", className: F && F.className || "", id: F && F.id || "", runExpressions: !F || F.runExpressions === void 0 || F.runExpressions }, this.renderConfig.dpr = F && F.dpr || 1, this.animationItem.wrapper && (this.renderConfig.dpr = F && F.dpr || window.devicePixelRatio || 1), this.renderedFrame = -1, this.globalData = { frameNum: -1, _mdf: !1, renderConfig: this.renderConfig, currentGlobalAlpha: -1 }, this.contextData = new CVContextData, this.elements = [], this.pendingElements = [], this.transformMat = new Matrix, this.completeLayers = !1, this.rendererType = "canvas", this.renderConfig.clearCanvas && (this.ctxTransform = this.contextData.transform.bind(this.contextData), this.ctxOpacity = this.contextData.opacity.bind(this.contextData), this.ctxFillStyle = this.contextData.fillStyle.bind(this.contextData), this.ctxStrokeStyle = this.contextData.strokeStyle.bind(this.contextData), this.ctxLineWidth = this.contextData.lineWidth.bind(this.contextData), this.ctxLineCap = this.contextData.lineCap.bind(this.contextData), this.ctxLineJoin = this.contextData.lineJoin.bind(this.contextData), this.ctxMiterLimit = this.contextData.miterLimit.bind(this.contextData), this.ctxFill = this.contextData.fill.bind(this.contextData), this.ctxFillRect = this.contextData.fillRect.bind(this.contextData), this.ctxStroke = this.contextData.stroke.bind(this.contextData), this.save = this.contextData.save.bind(this.contextData)) } extendPrototype([CanvasRendererBase], CanvasRenderer), CanvasRenderer.prototype.createComp = function (z) { return new CVCompElement(z, this.globalData, this) }; function HBaseElement() { } HBaseElement.prototype = { checkBlendMode: function () { }, initRendererElement: function () { this.baseElement = createTag(this.data.tg || "div"), this.data.hasMask ? (this.svgElement = createNS("svg"), this.layerElement = createNS("g"), this.maskedElement = this.layerElement, this.svgElement.appendChild(this.layerElement), this.baseElement.appendChild(this.svgElement)) : this.layerElement = this.baseElement, styleDiv(this.baseElement) }, createContainerElements: function () { this.renderableEffectsManager = new CVEffects(this), this.transformedElement = this.baseElement, this.maskedElement = this.layerElement, this.data.ln && this.layerElement.setAttribute("id", this.data.ln), this.data.cl && this.layerElement.setAttribute("class", this.data.cl), this.data.bm !== 0 && this.setBlendMode() }, renderElement: function () { var F = this.transformedElement ? this.transformedElement.style : {}; if (this.finalTransform._matMdf) { var G = this.finalTransform.mat.toCSS(); F.transform = G, F.webkitTransform = G } this.finalTransform._opMdf && (F.opacity = this.finalTransform.mProp.o.v) }, renderFrame: function () { this.data.hd || this.hidden || (this.renderTransform(), this.renderRenderable(), this.renderElement(), this.renderInnerContent(), this._isFirstFrame && (this._isFirstFrame = !1)) }, destroy: function () { this.layerElement = null, this.transformedElement = null, this.matteElement && (this.matteElement = null), this.maskManager && (this.maskManager.destroy(), this.maskManager = null) }, createRenderableComponents: function () { this.maskManager = new MaskElement(this.data, this, this.globalData) }, addEffects: function () { }, setMatte: function () { } }, HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement, HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy, HBaseElement.prototype.buildElementParenting = BaseRenderer.prototype.buildElementParenting; function HSolidElement(z, F, G) { this.initElement(z, F, G) } extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], HSolidElement), HSolidElement.prototype.createContent = function () { var z; this.data.hasMask ? (z = createNS("rect"), z.setAttribute("width", this.data.sw), z.setAttribute("height", this.data.sh), z.setAttribute("fill", this.data.sc), this.svgElement.setAttribute("width", this.data.sw), this.svgElement.setAttribute("height", this.data.sh)) : (z = createTag("div"), z.style.width = this.data.sw + "px", z.style.height = this.data.sh + "px", z.style.backgroundColor = this.data.sc), this.layerElement.appendChild(z) }; function HShapeElement(z, F, G) { this.shapes = [], this.shapesData = z.shapes, this.stylesList = [], this.shapeModifiers = [], this.itemsData = [], this.processedElements = [], this.animatedContents = [], this.shapesContainer = createNS("g"), this.initElement(z, F, G), this.prevViewData = [], this.currentBBox = { x: 999999, y: -999999, h: 0, w: 0 } } extendPrototype([BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement, HierarchyElement, FrameElement, RenderableElement], HShapeElement), HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent, HShapeElement.prototype.createContent = function () { var z; if (this.baseElement.style.fontSize = 0, this.data.hasMask) this.layerElement.appendChild(this.shapesContainer), z = this.svgElement; else { z = createNS("svg"); var F = this.comp.data ? this.comp.data : this.globalData.compSize; z.setAttribute("width", F.w), z.setAttribute("height", F.h), z.appendChild(this.shapesContainer), this.layerElement.appendChild(z) } this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], !0), this.filterUniqueShapes(), this.shapeCont = z }, HShapeElement.prototype.getTransformedPoint = function (z, F) { var G, Y = z.length; for (G = 0; G < Y; G += 1)F = z[G].mProps.v.applyToPointArray(F[0], F[1], 0); return F }, HShapeElement.prototype.calculateShapeBoundingBox = function (z, F) { var G = z.sh.v, Y = z.transformers, X, K = G._length, J, Z, Q, ee; if (!(K <= 1)) { for (X = 0; X < K - 1; X += 1)J = this.getTransformedPoint(Y, G.v[X]), Z = this.getTransformedPoint(Y, G.o[X]), Q = this.getTransformedPoint(Y, G.i[X + 1]), ee = this.getTransformedPoint(Y, G.v[X + 1]), this.checkBounds(J, Z, Q, ee, F); G.c && (J = this.getTransformedPoint(Y, G.v[X]), Z = this.getTransformedPoint(Y, G.o[X]), Q = this.getTransformedPoint(Y, G.i[0]), ee = this.getTransformedPoint(Y, G.v[0]), this.checkBounds(J, Z, Q, ee, F)) } }, HShapeElement.prototype.checkBounds = function (z, F, G, Y, X) { this.getBoundsOfCurve(z, F, G, Y); var K = this.shapeBoundingBox; X.x = bmMin(K.left, X.x), X.xMax = bmMax(K.right, X.xMax), X.y = bmMin(K.top, X.y), X.yMax = bmMax(K.bottom, X.yMax) }, HShapeElement.prototype.shapeBoundingBox = { left: 0, right: 0, top: 0, bottom: 0 }, HShapeElement.prototype.tempBoundingBox = { x: 0, xMax: 0, y: 0, yMax: 0, width: 0, height: 0 }, HShapeElement.prototype.getBoundsOfCurve = function (z, F, G, Y) { for (var X = [[z[0], Y[0]], [z[1], Y[1]]], K, J, Z, Q, ee, te, oe, ie = 0; ie < 2; ++ie)J = 6 * z[ie] - 12 * F[ie] + 6 * G[ie], K = -3 * z[ie] + 9 * F[ie] - 9 * G[ie] + 3 * Y[ie], Z = 3 * F[ie] - 3 * z[ie], J |= 0, K |= 0, Z |= 0, K === 0 && J === 0 || (K === 0 ? (Q = -Z / J, Q > 0 && Q < 1 && X[ie].push(this.calculateF(Q, z, F, G, Y, ie))) : (ee = J * J - 4 * Z * K, ee >= 0 && (te = (-J + bmSqrt(ee)) / (2 * K), te > 0 && te < 1 && X[ie].push(this.calculateF(te, z, F, G, Y, ie)), oe = (-J - bmSqrt(ee)) / (2 * K), oe > 0 && oe < 1 && X[ie].push(this.calculateF(oe, z, F, G, Y, ie))))); this.shapeBoundingBox.left = bmMin.apply(null, X[0]), this.shapeBoundingBox.top = bmMin.apply(null, X[1]), this.shapeBoundingBox.right = bmMax.apply(null, X[0]), this.shapeBoundingBox.bottom = bmMax.apply(null, X[1]) }, HShapeElement.prototype.calculateF = function (z, F, G, Y, X, K) { return bmPow(1 - z, 3) * F[K] + 3 * bmPow(1 - z, 2) * z * G[K] + 3 * (1 - z) * bmPow(z, 2) * Y[K] + bmPow(z, 3) * X[K] }, HShapeElement.prototype.calculateBoundingBox = function (z, F) { var G, Y = z.length; for (G = 0; G < Y; G += 1)z[G] && z[G].sh ? this.calculateShapeBoundingBox(z[G], F) : z[G] && z[G].it ? this.calculateBoundingBox(z[G].it, F) : z[G] && z[G].style && z[G].w && this.expandStrokeBoundingBox(z[G].w, F) }, HShapeElement.prototype.expandStrokeBoundingBox = function (z, F) { var G = 0; if (z.keyframes) { for (var Y = 0; Y < z.keyframes.length; Y += 1) { var X = z.keyframes[Y].s; X > G && (G = X) } G *= z.mult } else G = z.v * z.mult; F.x -= G, F.xMax += G, F.y -= G, F.yMax += G }, HShapeElement.prototype.currentBoxContains = function (z) { return this.currentBBox.x <= z.x && this.currentBBox.y <= z.y && this.currentBBox.width + this.currentBBox.x >= z.x + z.width && this.currentBBox.height + this.currentBBox.y >= z.y + z.height }, HShapeElement.prototype.renderInnerContent = function () { if (this._renderShapeFrame(), !this.hidden && (this._isFirstFrame || this._mdf)) { var z = this.tempBoundingBox, F = 999999; if (z.x = F, z.xMax = -F, z.y = F, z.yMax = -F, this.calculateBoundingBox(this.itemsData, z), z.width = z.xMax < z.x ? 0 : z.xMax - z.x, z.height = z.yMax < z.y ? 0 : z.yMax - z.y, this.currentBoxContains(z)) return; var G = !1; if (this.currentBBox.w !== z.width && (this.currentBBox.w = z.width, this.shapeCont.setAttribute("width", z.width), G = !0), this.currentBBox.h !== z.height && (this.currentBBox.h = z.height, this.shapeCont.setAttribute("height", z.height), G = !0), G || this.currentBBox.x !== z.x || this.currentBBox.y !== z.y) { this.currentBBox.w = z.width, this.currentBBox.h = z.height, this.currentBBox.x = z.x, this.currentBBox.y = z.y, this.shapeCont.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h); var Y = this.shapeCont.style, X = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)"; Y.transform = X, Y.webkitTransform = X } } }; function HTextElement(z, F, G) { this.textSpans = [], this.textPaths = [], this.currentBBox = { x: 999999, y: -999999, h: 0, w: 0 }, this.renderType = "svg", this.isMasked = !1, this.initElement(z, F, G) } extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], HTextElement), HTextElement.prototype.createContent = function () { if (this.isMasked = this.checkMasks(), this.isMasked) { this.renderType = "svg", this.compW = this.comp.data.w, this.compH = this.comp.data.h, this.svgElement.setAttribute("width", this.compW), this.svgElement.setAttribute("height", this.compH); var z = createNS("g"); this.maskedElement.appendChild(z), this.innerElem = z } else this.renderType = "html", this.innerElem = this.layerElement; this.checkParenting() }, HTextElement.prototype.buildNewText = function () { var z = this.textProperty.currentData; this.renderedLetters = createSizedArray(z.l ? z.l.length : 0); var F = this.innerElem.style, G = z.fc ? this.buildColor(z.fc) : "rgba(0,0,0,0)"; F.fill = G, F.color = G, z.sc && (F.stroke = this.buildColor(z.sc), F.strokeWidth = z.sw + "px"); var Y = this.globalData.fontManager.getFontByName(z.f); if (!this.globalData.fontManager.chars) if (F.fontSize = z.finalSize + "px", F.lineHeight = z.finalSize + "px", Y.fClass) this.innerElem.className = Y.fClass; else { F.fontFamily = Y.fFamily; var X = z.fWeight, K = z.fStyle; F.fontStyle = K, F.fontWeight = X } var J, Z, Q = z.l; Z = Q.length; var ee, te, oe, ie = this.mHelper, se, ne = "", re = 0; for (J = 0; J < Z; J += 1) { if (this.globalData.fontManager.chars ? (this.textPaths[re] ? ee = this.textPaths[re] : (ee = createNS("path"), ee.setAttribute("stroke-linecap", lineCapEnum[1]), ee.setAttribute("stroke-linejoin", lineJoinEnum[2]), ee.setAttribute("stroke-miterlimit", "4")), this.isMasked || (this.textSpans[re] ? (te = this.textSpans[re], oe = te.children[0]) : (te = createTag("div"), te.style.lineHeight = 0, oe = createNS("svg"), oe.appendChild(ee), styleDiv(te)))) : this.isMasked ? ee = this.textPaths[re] ? this.textPaths[re] : createNS("text") : this.textSpans[re] ? (te = this.textSpans[re], ee = this.textPaths[re]) : (te = createTag("span"), styleDiv(te), ee = createTag("span"), styleDiv(ee), te.appendChild(ee)), this.globalData.fontManager.chars) { var fe = this.globalData.fontManager.getCharData(z.finalText[J], Y.fStyle, this.globalData.fontManager.getFontByName(z.f).fFamily), ae; if (fe ? ae = fe.data : ae = null, ie.reset(), ae && ae.shapes && ae.shapes.length && (se = ae.shapes[0].it, ie.scale(z.finalSize / 100, z.finalSize / 100), ne = this.createPathShape(ie, se), ee.setAttribute("d", ne)), this.isMasked) this.innerElem.appendChild(ee); else { if (this.innerElem.appendChild(te), ae && ae.shapes) { document.body.appendChild(oe); var he = oe.getBBox(); oe.setAttribute("width", he.width + 2), oe.setAttribute("height", he.height + 2), oe.setAttribute("viewBox", he.x - 1 + " " + (he.y - 1) + " " + (he.width + 2) + " " + (he.height + 2)); var le = oe.style, ce = "translate(" + (he.x - 1) + "px," + (he.y - 1) + "px)"; le.transform = ce, le.webkitTransform = ce, Q[J].yOffset = he.y - 1 } else oe.setAttribute("width", 1), oe.setAttribute("height", 1); te.appendChild(oe) } } else if (ee.textContent = Q[J].val, ee.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), this.isMasked) this.innerElem.appendChild(ee); else { this.innerElem.appendChild(te); var ue = ee.style, me = "translate3d(0," + -z.finalSize / 1.2 + "px,0)"; ue.transform = me, ue.webkitTransform = me } this.isMasked ? this.textSpans[re] = ee : this.textSpans[re] = te, this.textSpans[re].style.display = "block", this.textPaths[re] = ee, re += 1 } for (; re < this.textSpans.length;)this.textSpans[re].style.display = "none", re += 1 }, HTextElement.prototype.renderInnerContent = function () { this.validateText(); var z; if (this.data.singleShape) { if (!this._isFirstFrame && !this.lettersChangedFlag) return; if (this.isMasked && this.finalTransform._matMdf) { this.svgElement.setAttribute("viewBox", -this.finalTransform.mProp.p.v[0] + " " + -this.finalTransform.mProp.p.v[1] + " " + this.compW + " " + this.compH), z = this.svgElement.style; var F = "translate(" + -this.finalTransform.mProp.p.v[0] + "px," + -this.finalTransform.mProp.p.v[1] + "px)"; z.transform = F, z.webkitTransform = F } } if (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag), !(!this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag)) { var G, Y, X = 0, K = this.textAnimator.renderedLetters, J = this.textProperty.currentData.l; Y = J.length; var Z, Q, ee; for (G = 0; G < Y; G += 1)J[G].n ? X += 1 : (Q = this.textSpans[G], ee = this.textPaths[G], Z = K[X], X += 1, Z._mdf.m && (this.isMasked ? Q.setAttribute("transform", Z.m) : (Q.style.webkitTransform = Z.m, Q.style.transform = Z.m)), Q.style.opacity = Z.o, Z.sw && Z._mdf.sw && ee.setAttribute("stroke-width", Z.sw), Z.sc && Z._mdf.sc && ee.setAttribute("stroke", Z.sc), Z.fc && Z._mdf.fc && (ee.setAttribute("fill", Z.fc), ee.style.color = Z.fc)); if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) { var te = this.innerElem.getBBox(); this.currentBBox.w !== te.width && (this.currentBBox.w = te.width, this.svgElement.setAttribute("width", te.width)), this.currentBBox.h !== te.height && (this.currentBBox.h = te.height, this.svgElement.setAttribute("height", te.height)); var oe = 1; if (this.currentBBox.w !== te.width + oe * 2 || this.currentBBox.h !== te.height + oe * 2 || this.currentBBox.x !== te.x - oe || this.currentBBox.y !== te.y - oe) { this.currentBBox.w = te.width + oe * 2, this.currentBBox.h = te.height + oe * 2, this.currentBBox.x = te.x - oe, this.currentBBox.y = te.y - oe, this.svgElement.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h), z = this.svgElement.style; var ie = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)"; z.transform = ie, z.webkitTransform = ie } } } }; function HCameraElement(z, F, G) { this.initFrame(), this.initBaseData(z, F, G), this.initHierarchy(); var Y = PropertyFactory.getProp; if (this.pe = Y(this, z.pe, 0, 0, this), z.ks.p.s ? (this.px = Y(this, z.ks.p.x, 1, 0, this), this.py = Y(this, z.ks.p.y, 1, 0, this), this.pz = Y(this, z.ks.p.z, 1, 0, this)) : this.p = Y(this, z.ks.p, 1, 0, this), z.ks.a && (this.a = Y(this, z.ks.a, 1, 0, this)), z.ks.or.k.length && z.ks.or.k[0].to) { var X, K = z.ks.or.k.length; for (X = 0; X < K; X += 1)z.ks.or.k[X].to = null, z.ks.or.k[X].ti = null } this.or = Y(this, z.ks.or, 1, degToRads, this), this.or.sh = !0, this.rx = Y(this, z.ks.rx, 0, degToRads, this), this.ry = Y(this, z.ks.ry, 0, degToRads, this), this.rz = Y(this, z.ks.rz, 0, degToRads, this), this.mat = new Matrix, this._prevMat = new Matrix, this._isFirstFrame = !0, this.finalTransform = { mProp: this } } extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement), HCameraElement.prototype.setup = function () { var z, F = this.comp.threeDElements.length, G, Y, X; for (z = 0; z < F; z += 1)if (G = this.comp.threeDElements[z], G.type === "3d") { Y = G.perspectiveElem.style, X = G.container.style; var K = this.pe.v + "px", J = "0px 0px 0px", Z = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)"; Y.perspective = K, Y.webkitPerspective = K, X.transformOrigin = J, X.mozTransformOrigin = J, X.webkitTransformOrigin = J, Y.transform = Z, Y.webkitTransform = Z } }, HCameraElement.prototype.createElements = function () { }, HCameraElement.prototype.hide = function () { }, HCameraElement.prototype.renderFrame = function () { var z = this._isFirstFrame, F, G; if (this.hierarchy) for (G = this.hierarchy.length, F = 0; F < G; F += 1)z = this.hierarchy[F].finalTransform.mProp._mdf || z; if (z || this.pe._mdf || this.p && this.p._mdf || this.px && (this.px._mdf || this.py._mdf || this.pz._mdf) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || this.a && this.a._mdf) { if (this.mat.reset(), this.hierarchy) for (G = this.hierarchy.length - 1, F = G; F >= 0; F -= 1) { var Y = this.hierarchy[F].finalTransform.mProp; this.mat.translate(-Y.p.v[0], -Y.p.v[1], Y.p.v[2]), this.mat.rotateX(-Y.or.v[0]).rotateY(-Y.or.v[1]).rotateZ(Y.or.v[2]), this.mat.rotateX(-Y.rx.v).rotateY(-Y.ry.v).rotateZ(Y.rz.v), this.mat.scale(1 / Y.s.v[0], 1 / Y.s.v[1], 1 / Y.s.v[2]), this.mat.translate(Y.a.v[0], Y.a.v[1], Y.a.v[2]) } if (this.p ? this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]) : this.mat.translate(-this.px.v, -this.py.v, this.pz.v), this.a) { var X; this.p ? X = [this.p.v[0] - this.a.v[0], this.p.v[1] - this.a.v[1], this.p.v[2] - this.a.v[2]] : X = [this.px.v - this.a.v[0], this.py.v - this.a.v[1], this.pz.v - this.a.v[2]]; var K = Math.sqrt(Math.pow(X[0], 2) + Math.pow(X[1], 2) + Math.pow(X[2], 2)), J = [X[0] / K, X[1] / K, X[2] / K], Z = Math.sqrt(J[2] * J[2] + J[0] * J[0]), Q = Math.atan2(J[1], Z), ee = Math.atan2(J[0], -J[2]); this.mat.rotateY(ee).rotateX(-Q) } this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v), this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]), this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0), this.mat.translate(0, 0, this.pe.v); var te = !this._prevMat.equals(this.mat); if ((te || this.pe._mdf) && this.comp.threeDElements) { G = this.comp.threeDElements.length; var oe, ie, se; for (F = 0; F < G; F += 1)if (oe = this.comp.threeDElements[F], oe.type === "3d") { if (te) { var ne = this.mat.toCSS(); se = oe.container.style, se.transform = ne, se.webkitTransform = ne } this.pe._mdf && (ie = oe.perspectiveElem.style, ie.perspective = this.pe.v + "px", ie.webkitPerspective = this.pe.v + "px") } this.mat.clone(this._prevMat) } } this._isFirstFrame = !1 }, HCameraElement.prototype.prepareFrame = function (z) { this.prepareProperties(z, !0) }, HCameraElement.prototype.destroy = function () { }, HCameraElement.prototype.getBaseElement = function () { return null }; function HImageElement(z, F, G) { this.assetData = F.getAssetData(z.refId), this.initElement(z, F, G) } extendPrototype([BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement, FrameElement, RenderableElement], HImageElement), HImageElement.prototype.createContent = function () { var z = this.globalData.getAssetsPath(this.assetData), F = new Image; this.data.hasMask ? (this.imageElem = createNS("image"), this.imageElem.setAttribute("width", this.assetData.w + "px"), this.imageElem.setAttribute("height", this.assetData.h + "px"), this.imageElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", z), this.layerElement.appendChild(this.imageElem), this.baseElement.setAttribute("width", this.assetData.w), this.baseElement.setAttribute("height", this.assetData.h)) : this.layerElement.appendChild(F), F.crossOrigin = "anonymous", F.src = z, this.data.ln && this.baseElement.setAttribute("id", this.data.ln) }; function HybridRendererBase(z, F) { this.animationItem = z, this.layers = null, this.renderedFrame = -1, this.renderConfig = { className: F && F.className || "", imagePreserveAspectRatio: F && F.imagePreserveAspectRatio || "xMidYMid slice", hideOnTransparent: !(F && F.hideOnTransparent === !1), filterSize: { width: F && F.filterSize && F.filterSize.width || "400%", height: F && F.filterSize && F.filterSize.height || "400%", x: F && F.filterSize && F.filterSize.x || "-100%", y: F && F.filterSize && F.filterSize.y || "-100%" } }, this.globalData = { _mdf: !1, frameNum: -1, renderConfig: this.renderConfig }, this.pendingElements = [], this.elements = [], this.threeDElements = [], this.destroyed = !1, this.camera = null, this.supports3d = !0, this.rendererType = "html" } extendPrototype([BaseRenderer], HybridRendererBase), HybridRendererBase.prototype.buildItem = SVGRenderer.prototype.buildItem, HybridRendererBase.prototype.checkPendingElements = function () { for (; this.pendingElements.length;) { var z = this.pendingElements.pop(); z.checkParenting() } }, HybridRendererBase.prototype.appendElementInPos = function (z, F) { var G = z.getBaseElement(); if (G) { var Y = this.layers[F]; if (!Y.ddd || !this.supports3d) if (this.threeDElements) this.addTo3dContainer(G, F); else { for (var X = 0, K, J, Z; X < F;)this.elements[X] && this.elements[X] !== !0 && this.elements[X].getBaseElement && (J = this.elements[X], Z = this.layers[X].ddd ? this.getThreeDContainerByPos(X) : J.getBaseElement(), K = Z || K), X += 1; K ? (!Y.ddd || !this.supports3d) && this.layerElement.insertBefore(G, K) : (!Y.ddd || !this.supports3d) && this.layerElement.appendChild(G) } else this.addTo3dContainer(G, F) } }, HybridRendererBase.prototype.createShape = function (z) { return this.supports3d ? new HShapeElement(z, this.globalData, this) : new SVGShapeElement(z, this.globalData, this) }, HybridRendererBase.prototype.createText = function (z) { return this.supports3d ? new HTextElement(z, this.globalData, this) : new SVGTextLottieElement(z, this.globalData, this) }, HybridRendererBase.prototype.createCamera = function (z) { return this.camera = new HCameraElement(z, this.globalData, this), this.camera }, HybridRendererBase.prototype.createImage = function (z) { return this.supports3d ? new HImageElement(z, this.globalData, this) : new IImageElement(z, this.globalData, this) }, HybridRendererBase.prototype.createSolid = function (z) { return this.supports3d ? new HSolidElement(z, this.globalData, this) : new ISolidElement(z, this.globalData, this) }, HybridRendererBase.prototype.createNull = SVGRenderer.prototype.createNull, HybridRendererBase.prototype.getThreeDContainerByPos = function (z) { for (var F = 0, G = this.threeDElements.length; F < G;) { if (this.threeDElements[F].startPos <= z && this.threeDElements[F].endPos >= z) return this.threeDElements[F].perspectiveElem; F += 1 } return null }, HybridRendererBase.prototype.createThreeDContainer = function (z, F) { var G = createTag("div"), Y, X; styleDiv(G); var K = createTag("div"); if (styleDiv(K), F === "3d") { Y = G.style, Y.width = this.globalData.compSize.w + "px", Y.height = this.globalData.compSize.h + "px"; var J = "50% 50%"; Y.webkitTransformOrigin = J, Y.mozTransformOrigin = J, Y.transformOrigin = J, X = K.style; var Z = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)"; X.transform = Z, X.webkitTransform = Z } G.appendChild(K); var Q = { container: K, perspectiveElem: G, startPos: z, endPos: z, type: F }; return this.threeDElements.push(Q), Q }, HybridRendererBase.prototype.build3dContainers = function () { var z, F = this.layers.length, G, Y = ""; for (z = 0; z < F; z += 1)this.layers[z].ddd && this.layers[z].ty !== 3 ? (Y !== "3d" && (Y = "3d", G = this.createThreeDContainer(z, "3d")), G.endPos = Math.max(G.endPos, z)) : (Y !== "2d" && (Y = "2d", G = this.createThreeDContainer(z, "2d")), G.endPos = Math.max(G.endPos, z)); for (F = this.threeDElements.length, z = F - 1; z >= 0; z -= 1)this.resizerElem.appendChild(this.threeDElements[z].perspectiveElem) }, HybridRendererBase.prototype.addTo3dContainer = function (z, F) { for (var G = 0, Y = this.threeDElements.length; G < Y;) { if (F <= this.threeDElements[G].endPos) { for (var X = this.threeDElements[G].startPos, K; X < F;)this.elements[X] && this.elements[X].getBaseElement && (K = this.elements[X].getBaseElement()), X += 1; K ? this.threeDElements[G].container.insertBefore(z, K) : this.threeDElements[G].container.appendChild(z); break } G += 1 } }, HybridRendererBase.prototype.configAnimation = function (z) { var F = createTag("div"), G = this.animationItem.wrapper, Y = F.style; Y.width = z.w + "px", Y.height = z.h + "px", this.resizerElem = F, styleDiv(F), Y.transformStyle = "flat", Y.mozTransformStyle = "flat", Y.webkitTransformStyle = "flat", this.renderConfig.className && F.setAttribute("class", this.renderConfig.className), G.appendChild(F), Y.overflow = "hidden"; var X = createNS("svg"); X.setAttribute("width", "1"), X.setAttribute("height", "1"), styleDiv(X), this.resizerElem.appendChild(X); var K = createNS("defs"); X.appendChild(K), this.data = z, this.setupGlobalData(z, X), this.globalData.defs = K, this.layers = z.layers, this.layerElement = this.resizerElem, this.build3dContainers(), this.updateContainerSize() }, HybridRendererBase.prototype.destroy = function () { this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""), this.animationItem.container = null, this.globalData.defs = null; var z, F = this.layers ? this.layers.length : 0; for (z = 0; z < F; z += 1)this.elements[z] && this.elements[z].destroy && this.elements[z].destroy(); this.elements.length = 0, this.destroyed = !0, this.animationItem = null }, HybridRendererBase.prototype.updateContainerSize = function () { var z = this.animationItem.wrapper.offsetWidth, F = this.animationItem.wrapper.offsetHeight, G = z / F, Y = this.globalData.compSize.w / this.globalData.compSize.h, X, K, J, Z; Y > G ? (X = z / this.globalData.compSize.w, K = z / this.globalData.compSize.w, J = 0, Z = (F - this.globalData.compSize.h * (z / this.globalData.compSize.w)) / 2) : (X = F / this.globalData.compSize.h, K = F / this.globalData.compSize.h, J = (z - this.globalData.compSize.w * (F / this.globalData.compSize.h)) / 2, Z = 0); var Q = this.resizerElem.style; Q.webkitTransform = "matrix3d(" + X + ",0,0,0,0," + K + ",0,0,0,0,1,0," + J + "," + Z + ",0,1)", Q.transform = Q.webkitTransform }, HybridRendererBase.prototype.renderFrame = SVGRenderer.prototype.renderFrame, HybridRendererBase.prototype.hide = function () { this.resizerElem.style.display = "none" }, HybridRendererBase.prototype.show = function () { this.resizerElem.style.display = "block" }, HybridRendererBase.prototype.initItems = function () { if (this.buildAllItems(), this.camera) this.camera.setup(); else { var z = this.globalData.compSize.w, F = this.globalData.compSize.h, G, Y = this.threeDElements.length; for (G = 0; G < Y; G += 1) { var X = this.threeDElements[G].perspectiveElem.style; X.webkitPerspective = Math.sqrt(Math.pow(z, 2) + Math.pow(F, 2)) + "px", X.perspective = X.webkitPerspective } } }, HybridRendererBase.prototype.searchExtraCompositions = function (z) { var F, G = z.length, Y = createTag("div"); for (F = 0; F < G; F += 1)if (z[F].xt) { var X = this.createComp(z[F], Y, this.globalData.comp, null); X.initExpressions(), this.globalData.projectInterface.registerComposition(X) } }; function HCompElement(z, F, G) { this.layers = z.layers, this.supports3d = !z.hasMask, this.completeLayers = !1, this.pendingElements = [], this.elements = this.layers ? createSizedArray(this.layers.length) : [], this.initElement(z, F, G), this.tm = z.tm ? PropertyFactory.getProp(this, z.tm, 0, F.frameRate, this) : { _placeholder: !0 } } extendPrototype([HybridRendererBase, ICompElement, HBaseElement], HCompElement), HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements, HCompElement.prototype.createContainerElements = function () { this._createBaseContainerElements(), this.data.hasMask ? (this.svgElement.setAttribute("width", this.data.w), this.svgElement.setAttribute("height", this.data.h), this.transformedElement = this.baseElement) : this.transformedElement = this.layerElement }, HCompElement.prototype.addTo3dContainer = function (z, F) { for (var G = 0, Y; G < F;)this.elements[G] && this.elements[G].getBaseElement && (Y = this.elements[G].getBaseElement()), G += 1; Y ? this.layerElement.insertBefore(z, Y) : this.layerElement.appendChild(z) }, HCompElement.prototype.createComp = function (z) { return this.supports3d ? new HCompElement(z, this.globalData, this) : new SVGCompElement(z, this.globalData, this) }; function HybridRenderer(z, F) { this.animationItem = z, this.layers = null, this.renderedFrame = -1, this.renderConfig = { className: F && F.className || "", imagePreserveAspectRatio: F && F.imagePreserveAspectRatio || "xMidYMid slice", hideOnTransparent: !(F && F.hideOnTransparent === !1), filterSize: { width: F && F.filterSize && F.filterSize.width || "400%", height: F && F.filterSize && F.filterSize.height || "400%", x: F && F.filterSize && F.filterSize.x || "-100%", y: F && F.filterSize && F.filterSize.y || "-100%" }, runExpressions: !F || F.runExpressions === void 0 || F.runExpressions }, this.globalData = { _mdf: !1, frameNum: -1, renderConfig: this.renderConfig }, this.pendingElements = [], this.elements = [], this.threeDElements = [], this.destroyed = !1, this.camera = null, this.supports3d = !0, this.rendererType = "html" } extendPrototype([HybridRendererBase], HybridRenderer), HybridRenderer.prototype.createComp = function (z) { return this.supports3d ? new HCompElement(z, this.globalData, this) : new SVGCompElement(z, this.globalData, this) }; var CompExpressionInterface = function () { return function (z) { function F(G) { for (var Y = 0, X = z.layers.length; Y < X;) { if (z.layers[Y].nm === G || z.layers[Y].ind === G) return z.elements[Y].layerInterface; Y += 1 } return null } return Object.defineProperty(F, "_name", { value: z.data.nm }), F.layer = F, F.pixelAspect = 1, F.height = z.data.h || z.globalData.compSize.h, F.width = z.data.w || z.globalData.compSize.w, F.pixelAspect = 1, F.frameDuration = 1 / z.globalData.frameRate, F.displayStartTime = 0, F.numLayers = z.layers.length, F } }(); function _typeof$2(z) { "@babel/helpers - typeof"; return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$2 = function (G) { return typeof G } : _typeof$2 = function (G) { return G && typeof Symbol == "function" && G.constructor === Symbol && G !== Symbol.prototype ? "symbol" : typeof G }, _typeof$2(z) } function seedRandom(z, F) { var G = this, Y = 256, X = 6, K = 52, J = "random", Z = F.pow(Y, X), Q = F.pow(2, K), ee = Q * 2, te = Y - 1, oe; function ie(le, ce, ue) { var me = []; ce = ce === !0 ? { entropy: !0 } : ce || {}; var ge = fe(re(ce.entropy ? [le, he(z)] : le === null ? ae() : le, 3), me), ve = new se(me), Se = function () { for (var Ce = ve.g(X), Ee = Z, De = 0; Ce < Q;)Ce = (Ce + De) * Y, Ee *= Y, De = ve.g(1); for (; Ce >= ee;)Ce /= 2, Ee /= 2, De >>>= 1; return (Ce + De) / Ee }; return Se.int32 = function () { return ve.g(4) | 0 }, Se.quick = function () { return ve.g(4) / 4294967296 }, Se.double = Se, fe(he(ve.S), z), (ce.pass || ue || function (ke, Ce, Ee, De) { return De && (De.S && ne(De, ve), ke.state = function () { return ne(ve, {}) }), Ee ? (F[J] = ke, Ce) : ke })(Se, ge, "global" in ce ? ce.global : this == F, ce.state) } F["seed" + J] = ie; function se(le) { var ce, ue = le.length, me = this, ge = 0, ve = me.i = me.j = 0, Se = me.S = []; for (ue || (le = [ue++]); ge < Y;)Se[ge] = ge++; for (ge = 0; ge < Y; ge++)Se[ge] = Se[ve = te & ve + le[ge % ue] + (ce = Se[ge])], Se[ve] = ce; me.g = function (ke) { for (var Ce, Ee = 0, De = me.i, Pe = me.j, Te = me.S; ke--;)Ce = Te[De = te & De + 1], Ee = Ee * Y + Te[te & (Te[De] = Te[Pe = te & Pe + Ce]) + (Te[Pe] = Ce)]; return me.i = De, me.j = Pe, Ee } } function ne(le, ce) { return ce.i = le.i, ce.j = le.j, ce.S = le.S.slice(), ce } function re(le, ce) { var ue = [], me = _typeof$2(le), ge; if (ce && me == "object") for (ge in le) try { ue.push(re(le[ge], ce - 1)) } catch { } return ue.length ? ue : me == "string" ? le : le + "\0" } function fe(le, ce) { for (var ue = le + "", me, ge = 0; ge < ue.length;)ce[te & ge] = te & (me ^= ce[te & ge] * 19) + ue.charCodeAt(ge++); return he(ce) } function ae() { try { var le = new Uint8Array(Y); return (G.crypto || G.msCrypto).getRandomValues(le), he(le) } catch { var ce = G.navigator, ue = ce && ce.plugins; return [+new Date, G, ue, G.screen, he(z)] } } function he(le) { return String.fromCharCode.apply(0, le) } fe(F.random(), z) } function initialize$2(z) { seedRandom([], z) } var propTypes = { SHAPE: "shape" }; function _typeof$1(z) { "@babel/helpers - typeof"; return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$1 = function (G) { return typeof G } : _typeof$1 = function (G) { return G && typeof Symbol == "function" && G.constructor === Symbol && G !== Symbol.prototype ? "symbol" : typeof G }, _typeof$1(z) } var ExpressionManager = function () { var ob = {}, Math = BMMath, window = null, document = null, XMLHttpRequest = null, fetch = null, frames = null, _lottieGlobal = {}; initialize$2(BMMath); function resetFrame() { _lottieGlobal = {} } function $bm_isInstanceOfArray(z) { return z.constructor === Array || z.constructor === Float32Array } function isNumerable(z, F) { return z === "number" || F instanceof Number || z === "boolean" || z === "string" } function $bm_neg(z) { var F = _typeof$1(z); if (F === "number" || z instanceof Number || F === "boolean") return -z; if ($bm_isInstanceOfArray(z)) { var G, Y = z.length, X = []; for (G = 0; G < Y; G += 1)X[G] = -z[G]; return X } return z.propType ? z.v : -z } var easeInBez = BezierFactory.getBezierEasing(.333, 0, .833, .833, "easeIn").get, easeOutBez = BezierFactory.getBezierEasing(.167, .167, .667, 1, "easeOut").get, easeInOutBez = BezierFactory.getBezierEasing(.33, 0, .667, 1, "easeInOut").get; function sum(z, F) { var G = _typeof$1(z), Y = _typeof$1(F); if (isNumerable(G, z) && isNumerable(Y, F) || G === "string" || Y === "string") return z + F; if ($bm_isInstanceOfArray(z) && isNumerable(Y, F)) return z = z.slice(0), z[0] += F, z; if (isNumerable(G, z) && $bm_isInstanceOfArray(F)) return F = F.slice(0), F[0] = z + F[0], F; if ($bm_isInstanceOfArray(z) && $bm_isInstanceOfArray(F)) { for (var X = 0, K = z.length, J = F.length, Z = []; X < K || X < J;)(typeof z[X] == "number" || z[X] instanceof Number) && (typeof F[X] == "number" || F[X] instanceof Number) ? Z[X] = z[X] + F[X] : Z[X] = F[X] === void 0 ? z[X] : z[X] || F[X], X += 1; return Z } return 0 } var add = sum; function sub(z, F) { var G = _typeof$1(z), Y = _typeof$1(F); if (isNumerable(G, z) && isNumerable(Y, F)) return G === "string" && (z = parseInt(z, 10)), Y === "string" && (F = parseInt(F, 10)), z - F; if ($bm_isInstanceOfArray(z) && isNumerable(Y, F)) return z = z.slice(0), z[0] -= F, z; if (isNumerable(G, z) && $bm_isInstanceOfArray(F)) return F = F.slice(0), F[0] = z - F[0], F; if ($bm_isInstanceOfArray(z) && $bm_isInstanceOfArray(F)) { for (var X = 0, K = z.length, J = F.length, Z = []; X < K || X < J;)(typeof z[X] == "number" || z[X] instanceof Number) && (typeof F[X] == "number" || F[X] instanceof Number) ? Z[X] = z[X] - F[X] : Z[X] = F[X] === void 0 ? z[X] : z[X] || F[X], X += 1; return Z } return 0 } function mul(z, F) { var G = _typeof$1(z), Y = _typeof$1(F), X; if (isNumerable(G, z) && isNumerable(Y, F)) return z * F; var K, J; if ($bm_isInstanceOfArray(z) && isNumerable(Y, F)) { for (J = z.length, X = createTypedArray("float32", J), K = 0; K < J; K += 1)X[K] = z[K] * F; return X } if (isNumerable(G, z) && $bm_isInstanceOfArray(F)) { for (J = F.length, X = createTypedArray("float32", J), K = 0; K < J; K += 1)X[K] = z * F[K]; return X } return 0 } function div(z, F) { var G = _typeof$1(z), Y = _typeof$1(F), X; if (isNumerable(G, z) && isNumerable(Y, F)) return z / F; var K, J; if ($bm_isInstanceOfArray(z) && isNumerable(Y, F)) { for (J = z.length, X = createTypedArray("float32", J), K = 0; K < J; K += 1)X[K] = z[K] / F; return X } if (isNumerable(G, z) && $bm_isInstanceOfArray(F)) { for (J = F.length, X = createTypedArray("float32", J), K = 0; K < J; K += 1)X[K] = z / F[K]; return X } return 0 } function mod(z, F) { return typeof z == "string" && (z = parseInt(z, 10)), typeof F == "string" && (F = parseInt(F, 10)), z % F } var $bm_sum = sum, $bm_sub = sub, $bm_mul = mul, $bm_div = div, $bm_mod = mod; function clamp(z, F, G) { if (F > G) { var Y = G; G = F, F = Y } return Math.min(Math.max(z, F), G) } function radiansToDegrees(z) { return z / degToRads } var radians_to_degrees = radiansToDegrees; function degreesToRadians(z) { return z * degToRads } var degrees_to_radians = radiansToDegrees, helperLengthArray = [0, 0, 0, 0, 0, 0]; function length(z, F) { if (typeof z == "number" || z instanceof Number) return F = F || 0, Math.abs(z - F); F || (F = helperLengthArray); var G, Y = Math.min(z.length, F.length), X = 0; for (G = 0; G < Y; G += 1)X += Math.pow(F[G] - z[G], 2); return Math.sqrt(X) } function normalize(z) { return div(z, length(z)) } function rgbToHsl(z) { var F = z[0], G = z[1], Y = z[2], X = Math.max(F, G, Y), K = Math.min(F, G, Y), J, Z, Q = (X + K) / 2; if (X === K) J = 0, Z = 0; else { var ee = X - K; switch (Z = Q > .5 ? ee / (2 - X - K) : ee / (X + K), X) { case F: J = (G - Y) / ee + (G < Y ? 6 : 0); break; case G: J = (Y - F) / ee + 2; break; case Y: J = (F - G) / ee + 4; break }J /= 6 } return [J, Z, Q, z[3]] } function hue2rgb(z, F, G) { return G < 0 && (G += 1), G > 1 && (G -= 1), G < 1 / 6 ? z + (F - z) * 6 * G : G < 1 / 2 ? F : G < 2 / 3 ? z + (F - z) * (2 / 3 - G) * 6 : z } function hslToRgb(z) { var F = z[0], G = z[1], Y = z[2], X, K, J; if (G === 0) X = Y, J = Y, K = Y; else { var Z = Y < .5 ? Y * (1 + G) : Y + G - Y * G, Q = 2 * Y - Z; X = hue2rgb(Q, Z, F + 1 / 3), K = hue2rgb(Q, Z, F), J = hue2rgb(Q, Z, F - 1 / 3) } return [X, K, J, z[3]] } function linear(z, F, G, Y, X) { if ((Y === void 0 || X === void 0) && (Y = F, X = G, F = 0, G = 1), G < F) { var K = G; G = F, F = K } if (z <= F) return Y; if (z >= G) return X; var J = G === F ? 0 : (z - F) / (G - F); if (!Y.length) return Y + (X - Y) * J; var Z, Q = Y.length, ee = createTypedArray("float32", Q); for (Z = 0; Z < Q; Z += 1)ee[Z] = Y[Z] + (X[Z] - Y[Z]) * J; return ee } function random(z, F) { if (F === void 0 && (z === void 0 ? (z = 0, F = 1) : (F = z, z = void 0)), F.length) { var G, Y = F.length; z || (z = createTypedArray("float32", Y)); var X = createTypedArray("float32", Y), K = BMMath.random(); for (G = 0; G < Y; G += 1)X[G] = z[G] + K * (F[G] - z[G]); return X } z === void 0 && (z = 0); var J = BMMath.random(); return z + J * (F - z) } function createPath(z, F, G, Y) { var X, K = z.length, J = shapePool.newElement(); J.setPathData(!!Y, K); var Z = [0, 0], Q, ee; for (X = 0; X < K; X += 1)Q = F && F[X] ? F[X] : Z, ee = G && G[X] ? G[X] : Z, J.setTripleAt(z[X][0], z[X][1], ee[0] + z[X][0], ee[1] + z[X][1], Q[0] + z[X][0], Q[1] + z[X][1], X, !0); return J } function initiateExpression(elem, data, property) { function noOp(z) { return z } if (!elem.globalData.renderConfig.runExpressions) return noOp; var val = data.x, needsVelocity = /velocity(?![\w\d])/.test(val), _needsRandom = val.indexOf("random") !== -1, elemType = elem.data.ty, transform, $bm_transform, content, effect, thisProperty = property; thisProperty.valueAtTime = thisProperty.getValueAtTime, Object.defineProperty(thisProperty, "value", { get: function () { return thisProperty.v } }), elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate, elem.comp.displayStartTime = 0; var inPoint = elem.data.ip / elem.comp.globalData.frameRate, outPoint = elem.data.op / elem.comp.globalData.frameRate, width = elem.data.sw ? elem.data.sw : 0, height = elem.data.sh ? elem.data.sh : 0, name = elem.data.nm, loopIn, loop_in, loopOut, loop_out, smooth, toWorld, fromWorld, fromComp, toComp, fromCompToSurface, position, rotation, anchorPoint, scale, thisLayer, thisComp, mask, valueAtTime, velocityAtTime, scoped_bm_rt, expression_function = eval("[function _expression_function(){" + val + ";scoped_bm_rt=$bm_rt}]")[0], numKeys = property.kf ? data.k.length : 0, active = !this.data || this.data.hd !== !0, wiggle = function z(F, G) { var Y, X, K = this.pv.length ? this.pv.length : 1, J = createTypedArray("float32", K); F = 5; var Z = Math.floor(time * F); for (Y = 0, X = 0; Y < Z;) { for (X = 0; X < K; X += 1)J[X] += -G + G * 2 * BMMath.random(); Y += 1 } var Q = time * F, ee = Q - Math.floor(Q), te = createTypedArray("float32", K); if (K > 1) { for (X = 0; X < K; X += 1)te[X] = this.pv[X] + J[X] + (-G + G * 2 * BMMath.random()) * ee; return te } return this.pv + J[0] + (-G + G * 2 * BMMath.random()) * ee }.bind(this); thisProperty.loopIn && (loopIn = thisProperty.loopIn.bind(thisProperty), loop_in = loopIn), thisProperty.loopOut && (loopOut = thisProperty.loopOut.bind(thisProperty), loop_out = loopOut), thisProperty.smooth && (smooth = thisProperty.smooth.bind(thisProperty)); function loopInDuration(z, F) { return loopIn(z, F, !0) } function loopOutDuration(z, F) { return loopOut(z, F, !0) } this.getValueAtTime && (valueAtTime = this.getValueAtTime.bind(this)), this.getVelocityAtTime && (velocityAtTime = this.getVelocityAtTime.bind(this)); var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface); function lookAt(z, F) { var G = [F[0] - z[0], F[1] - z[1], F[2] - z[2]], Y = Math.atan2(G[0], Math.sqrt(G[1] * G[1] + G[2] * G[2])) / degToRads, X = -Math.atan2(G[1], G[2]) / degToRads; return [X, Y, 0] } function easeOut(z, F, G, Y, X) { return applyEase(easeOutBez, z, F, G, Y, X) } function easeIn(z, F, G, Y, X) { return applyEase(easeInBez, z, F, G, Y, X) } function ease(z, F, G, Y, X) { return applyEase(easeInOutBez, z, F, G, Y, X) } function applyEase(z, F, G, Y, X, K) { X === void 0 ? (X = G, K = Y) : F = (F - G) / (Y - G), F > 1 ? F = 1 : F < 0 && (F = 0); var J = z(F); if ($bm_isInstanceOfArray(X)) { var Z, Q = X.length, ee = createTypedArray("float32", Q); for (Z = 0; Z < Q; Z += 1)ee[Z] = (K[Z] - X[Z]) * J + X[Z]; return ee } return (K - X) * J + X } function nearestKey(z) { var F, G = data.k.length, Y, X; if (!data.k.length || typeof data.k[0] == "number") Y = 0, X = 0; else if (Y = -1, z *= elem.comp.globalData.frameRate, z < data.k[0].t) Y = 1, X = data.k[0].t; else { for (F = 0; F < G - 1; F += 1)if (z === data.k[F].t) { Y = F + 1, X = data.k[F].t; break } else if (z > data.k[F].t && z < data.k[F + 1].t) { z - data.k[F].t > data.k[F + 1].t - z ? (Y = F + 2, X = data.k[F + 1].t) : (Y = F + 1, X = data.k[F].t); break } Y === -1 && (Y = F + 1, X = data.k[F].t) } var K = {}; return K.index = Y, K.time = X / elem.comp.globalData.frameRate, K } function key(z) { var F, G, Y; if (!data.k.length || typeof data.k[0] == "number") throw new Error("The property has no keyframe at index " + z); z -= 1, F = { time: data.k[z].t / elem.comp.globalData.frameRate, value: [] }; var X = Object.prototype.hasOwnProperty.call(data.k[z], "s") ? data.k[z].s : data.k[z - 1].e; for (Y = X.length, G = 0; G < Y; G += 1)F[G] = X[G], F.value[G] = X[G]; return F } function framesToTime(z, F) { return F || (F = elem.comp.globalData.frameRate), z / F } function timeToFrames(z, F) { return !z && z !== 0 && (z = time), F || (F = elem.comp.globalData.frameRate), z * F } function seedRandom(z) { BMMath.seedrandom(randSeed + z) } function sourceRectAtTime() { return elem.sourceRectAtTime() } function substring(z, F) { return typeof value == "string" ? F === void 0 ? value.substring(z) : value.substring(z, F) : "" } function substr(z, F) { return typeof value == "string" ? F === void 0 ? value.substr(z) : value.substr(z, F) : "" } function posterizeTime(z) { time = z === 0 ? 0 : Math.floor(time * z) / z, value = valueAtTime(time) } var time, velocity, value, text, textIndex, textTotal, selectorValue, index = elem.data.ind, hasParent = !!(elem.hierarchy && elem.hierarchy.length), parent, randSeed = Math.floor(Math.random() * 1e6), globalData = elem.globalData; function executeExpression(z) { return value = z, this.frameExpressionId === elem.globalData.frameId && this.propType !== "textSelector" ? value : (this.propType === "textSelector" && (textIndex = this.textIndex, textTotal = this.textTotal, selectorValue = this.selectorValue), thisLayer || (text = elem.layerInterface.text, thisLayer = elem.layerInterface, thisComp = elem.comp.compInterface, toWorld = thisLayer.toWorld.bind(thisLayer), fromWorld = thisLayer.fromWorld.bind(thisLayer), fromComp = thisLayer.fromComp.bind(thisLayer), toComp = thisLayer.toComp.bind(thisLayer), mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null, fromCompToSurface = fromComp), transform || (transform = elem.layerInterface("ADBE Transform Group"), $bm_transform = transform, transform && (anchorPoint = transform.anchorPoint)), elemType === 4 && !content && (content = thisLayer("ADBE Root Vectors Group")), effect || (effect = thisLayer(4)), hasParent = !!(elem.hierarchy && elem.hierarchy.length), hasParent && !parent && (parent = elem.hierarchy[0].layerInterface), time = this.comp.renderedFrame / this.comp.globalData.frameRate, _needsRandom && seedRandom(randSeed + time), needsVelocity && (velocity = velocityAtTime(time)), expression_function(), this.frameExpressionId = elem.globalData.frameId, scoped_bm_rt = scoped_bm_rt.propType === propTypes.SHAPE ? scoped_bm_rt.v : scoped_bm_rt, scoped_bm_rt) } return executeExpression.__preventDeadCodeRemoval = [$bm_transform, anchorPoint, time, velocity, inPoint, outPoint, width, height, name, loop_in, loop_out, smooth, toComp, fromCompToSurface, toWorld, fromWorld, mask, position, rotation, scale, thisComp, numKeys, active, wiggle, loopInDuration, loopOutDuration, comp, lookAt, easeOut, easeIn, ease, nearestKey, key, text, textIndex, textTotal, selectorValue, framesToTime, timeToFrames, sourceRectAtTime, substring, substr, posterizeTime, index, globalData], executeExpression } return ob.initiateExpression = initiateExpression, ob.__preventDeadCodeRemoval = [window, document, XMLHttpRequest, fetch, frames, $bm_neg, add, $bm_sum, $bm_sub, $bm_mul, $bm_div, $bm_mod, clamp, radians_to_degrees, degreesToRadians, degrees_to_radians, normalize, rgbToHsl, hslToRgb, linear, random, createPath, _lottieGlobal], ob.resetFrame = resetFrame, ob }(), Expressions = function () { var z = {}; z.initExpressions = F, z.resetFrame = ExpressionManager.resetFrame; function F(G) { var Y = 0, X = []; function K() { Y += 1 } function J() { Y -= 1, Y === 0 && Q() } function Z(ee) { X.indexOf(ee) === -1 && X.push(ee) } function Q() { var ee, te = X.length; for (ee = 0; ee < te; ee += 1)X[ee].release(); X.length = 0 } G.renderer.compInterface = CompExpressionInterface(G.renderer), G.renderer.globalData.projectInterface.registerComposition(G.renderer), G.renderer.globalData.pushExpression = K, G.renderer.globalData.popExpression = J, G.renderer.globalData.registerExpressionProperty = Z } return z }(), MaskManagerInterface = function () { function z(G, Y) { this._mask = G, this._data = Y } Object.defineProperty(z.prototype, "maskPath", { get: function () { return this._mask.prop.k && this._mask.prop.getValue(), this._mask.prop } }), Object.defineProperty(z.prototype, "maskOpacity", { get: function () { return this._mask.op.k && this._mask.op.getValue(), this._mask.op.v * 100 } }); var F = function (Y) { var X = createSizedArray(Y.viewData.length), K, J = Y.viewData.length; for (K = 0; K < J; K += 1)X[K] = new z(Y.viewData[K], Y.masksProperties[K]); var Z = function (ee) { for (K = 0; K < J;) { if (Y.masksProperties[K].nm === ee) return X[K]; K += 1 } return null }; return Z }; return F }(), ExpressionPropertyInterface = function () { var z = { pv: 0, v: 0, mult: 1 }, F = { pv: [0, 0, 0], v: [0, 0, 0], mult: 1 }; function G(J, Z, Q) { Object.defineProperty(J, "velocity", { get: function () { return Z.getVelocityAtTime(Z.comp.currentFrame) } }), J.numKeys = Z.keyframes ? Z.keyframes.length : 0, J.key = function (ee) { if (!J.numKeys) return 0; var te = ""; "s" in Z.keyframes[ee - 1] ? te = Z.keyframes[ee - 1].s : "e" in Z.keyframes[ee - 2] ? te = Z.keyframes[ee - 2].e : te = Z.keyframes[ee - 2].s; var oe = Q === "unidimensional" ? new Number(te) : Object.assign({}, te); return oe.time = Z.keyframes[ee - 1].t / Z.elem.comp.globalData.frameRate, oe.value = Q === "unidimensional" ? te[0] : te, oe }, J.valueAtTime = Z.getValueAtTime, J.speedAtTime = Z.getSpeedAtTime, J.velocityAtTime = Z.getVelocityAtTime, J.propertyGroup = Z.propertyGroup } function Y(J) { (!J || !("pv" in J)) && (J = z); var Z = 1 / J.mult, Q = J.pv * Z, ee = new Number(Q); return ee.value = Q, G(ee, J, "unidimensional"), function () { return J.k && J.getValue(), Q = J.v * Z, ee.value !== Q && (ee = new Number(Q), ee.value = Q, G(ee, J, "unidimensional")), ee } } function X(J) { (!J || !("pv" in J)) && (J = F); var Z = 1 / J.mult, Q = J.data && J.data.l || J.pv.length, ee = createTypedArray("float32", Q), te = createTypedArray("float32", Q); return ee.value = te, G(ee, J, "multidimensional"), function () { J.k && J.getValue(); for (var oe = 0; oe < Q; oe += 1)te[oe] = J.v[oe] * Z, ee[oe] = te[oe]; return ee } } function K() { return z } return function (J) { return J ? J.propType === "unidimensional" ? Y(J) : X(J) : K } }(), TransformExpressionInterface = function () { return function (z) { function F(J) { switch (J) { case "scale": case "Scale": case "ADBE Scale": case 6: return F.scale; case "rotation": case "Rotation": case "ADBE Rotation": case "ADBE Rotate Z": case 10: return F.rotation; case "ADBE Rotate X": return F.xRotation; case "ADBE Rotate Y": return F.yRotation; case "position": case "Position": case "ADBE Position": case 2: return F.position; case "ADBE Position_0": return F.xPosition; case "ADBE Position_1": return F.yPosition; case "ADBE Position_2": return F.zPosition; case "anchorPoint": case "AnchorPoint": case "Anchor Point": case "ADBE AnchorPoint": case 1: return F.anchorPoint; case "opacity": case "Opacity": case 11: return F.opacity; default: return null } } Object.defineProperty(F, "rotation", { get: ExpressionPropertyInterface(z.r || z.rz) }), Object.defineProperty(F, "zRotation", { get: ExpressionPropertyInterface(z.rz || z.r) }), Object.defineProperty(F, "xRotation", { get: ExpressionPropertyInterface(z.rx) }), Object.defineProperty(F, "yRotation", { get: ExpressionPropertyInterface(z.ry) }), Object.defineProperty(F, "scale", { get: ExpressionPropertyInterface(z.s) }); var G, Y, X, K; return z.p ? K = ExpressionPropertyInterface(z.p) : (G = ExpressionPropertyInterface(z.px), Y = ExpressionPropertyInterface(z.py), z.pz && (X = ExpressionPropertyInterface(z.pz))), Object.defineProperty(F, "position", { get: function () { return z.p ? K() : [G(), Y(), X ? X() : 0] } }), Object.defineProperty(F, "xPosition", { get: ExpressionPropertyInterface(z.px) }), Object.defineProperty(F, "yPosition", { get: ExpressionPropertyInterface(z.py) }), Object.defineProperty(F, "zPosition", { get: ExpressionPropertyInterface(z.pz) }), Object.defineProperty(F, "anchorPoint", { get: ExpressionPropertyInterface(z.a) }), Object.defineProperty(F, "opacity", { get: ExpressionPropertyInterface(z.o) }), Object.defineProperty(F, "skew", { get: ExpressionPropertyInterface(z.sk) }), Object.defineProperty(F, "skewAxis", { get: ExpressionPropertyInterface(z.sa) }), Object.defineProperty(F, "orientation", { get: ExpressionPropertyInterface(z.or) }), F } }(), LayerExpressionInterface = function () { function z(ee) { var te = new Matrix; if (ee !== void 0) { var oe = this._elem.finalTransform.mProp.getValueAtTime(ee); oe.clone(te) } else { var ie = this._elem.finalTransform.mProp; ie.applyToMatrix(te) } return te } function F(ee, te) { var oe = this.getMatrix(te); return oe.props[12] = 0, oe.props[13] = 0, oe.props[14] = 0, this.applyPoint(oe, ee) } function G(ee, te) { var oe = this.getMatrix(te); return this.applyPoint(oe, ee) } function Y(ee, te) { var oe = this.getMatrix(te); return oe.props[12] = 0, oe.props[13] = 0, oe.props[14] = 0, this.invertPoint(oe, ee) } function X(ee, te) { var oe = this.getMatrix(te); return this.invertPoint(oe, ee) } function K(ee, te) { if (this._elem.hierarchy && this._elem.hierarchy.length) { var oe, ie = this._elem.hierarchy.length; for (oe = 0; oe < ie; oe += 1)this._elem.hierarchy[oe].finalTransform.mProp.applyToMatrix(ee) } return ee.applyToPointArray(te[0], te[1], te[2] || 0) } function J(ee, te) { if (this._elem.hierarchy && this._elem.hierarchy.length) { var oe, ie = this._elem.hierarchy.length; for (oe = 0; oe < ie; oe += 1)this._elem.hierarchy[oe].finalTransform.mProp.applyToMatrix(ee) } return ee.inversePoint(te) } function Z(ee) { var te = new Matrix; if (te.reset(), this._elem.finalTransform.mProp.applyToMatrix(te), this._elem.hierarchy && this._elem.hierarchy.length) { var oe, ie = this._elem.hierarchy.length; for (oe = 0; oe < ie; oe += 1)this._elem.hierarchy[oe].finalTransform.mProp.applyToMatrix(te); return te.inversePoint(ee) } return te.inversePoint(ee) } function Q() { return [1, 1, 1, 1] } return function (ee) { var te; function oe(re) { se.mask = new MaskManagerInterface(re, ee) } function ie(re) { se.effect = re } function se(re) { switch (re) { case "ADBE Root Vectors Group": case "Contents": case 2: return se.shapeInterface; case 1: case 6: case "Transform": case "transform": case "ADBE Transform Group": return te; case 4: case "ADBE Effect Parade": case "effects": case "Effects": return se.effect; case "ADBE Text Properties": return se.textInterface; default: return null } } se.getMatrix = z, se.invertPoint = J, se.applyPoint = K, se.toWorld = G, se.toWorldVec = F, se.fromWorld = X, se.fromWorldVec = Y, se.toComp = G, se.fromComp = Z, se.sampleImage = Q, se.sourceRectAtTime = ee.sourceRectAtTime.bind(ee), se._elem = ee, te = TransformExpressionInterface(ee.finalTransform.mProp); var ne = getDescriptor(te, "anchorPoint"); return Object.defineProperties(se, { hasParent: { get: function () { return ee.hierarchy.length } }, parent: { get: function () { return ee.hierarchy[0].layerInterface } }, rotation: getDescriptor(te, "rotation"), scale: getDescriptor(te, "scale"), position: getDescriptor(te, "position"), opacity: getDescriptor(te, "opacity"), anchorPoint: ne, anchor_point: ne, transform: { get: function () { return te } }, active: { get: function () { return ee.isInRange } } }), se.startTime = ee.data.st, se.index = ee.data.ind, se.source = ee.data.refId, se.height = ee.data.ty === 0 ? ee.data.h : 100, se.width = ee.data.ty === 0 ? ee.data.w : 100, se.inPoint = ee.data.ip / ee.comp.globalData.frameRate, se.outPoint = ee.data.op / ee.comp.globalData.frameRate, se._name = ee.data.nm, se.registerMaskInterface = oe, se.registerEffectsInterface = ie, se } }(), propertyGroupFactory = function () { return function (z, F) { return function (G) { return G = G === void 0 ? 1 : G, G <= 0 ? z : F(G - 1) } } }(), PropertyInterface = function () { return function (z, F) { var G = { _name: z }; function Y(X) { return X = X === void 0 ? 1 : X, X <= 0 ? G : F(X - 1) } return Y } }(), EffectsExpressionInterface = function () { var z = { createEffectsInterface: F }; function F(X, K) { if (X.effectsManager) { var J = [], Z = X.data.ef, Q, ee = X.effectsManager.effectElements.length; for (Q = 0; Q < ee; Q += 1)J.push(G(Z[Q], X.effectsManager.effectElements[Q], K, X)); var te = X.data.ef || [], oe = function (se) { for (Q = 0, ee = te.length; Q < ee;) { if (se === te[Q].nm || se === te[Q].mn || se === te[Q].ix) return J[Q]; Q += 1 } return null }; return Object.defineProperty(oe, "numProperties", { get: function () { return te.length } }), oe } return null } function G(X, K, J, Z) { function Q(se) { for (var ne = X.ef, re = 0, fe = ne.length; re < fe;) { if (se === ne[re].nm || se === ne[re].mn || se === ne[re].ix) return ne[re].ty === 5 ? te[re] : te[re](); re += 1 } throw new Error } var ee = propertyGroupFactory(Q, J), te = [], oe, ie = X.ef.length; for (oe = 0; oe < ie; oe += 1)X.ef[oe].ty === 5 ? te.push(G(X.ef[oe], K.effectElements[oe], K.effectElements[oe].propertyGroup, Z)) : te.push(Y(K.effectElements[oe], X.ef[oe].ty, Z, ee)); return X.mn === "ADBE Color Control" && Object.defineProperty(Q, "color", { get: function () { return te[0]() } }), Object.defineProperties(Q, { numProperties: { get: function () { return X.np } }, _name: { value: X.nm }, propertyGroup: { value: ee } }), Q.enabled = X.en !== 0, Q.active = Q.enabled, Q } function Y(X, K, J, Z) { var Q = ExpressionPropertyInterface(X.p); function ee() { return K === 10 ? J.comp.compInterface(X.p.v) : Q() } return X.p.setGroupProperty && X.p.setGroupProperty(PropertyInterface("", Z)), ee } return z }(), ShapePathInterface = function () { return function (F, G, Y) { var X = G.sh; function K(Z) { return Z === "Shape" || Z === "shape" || Z === "Path" || Z === "path" || Z === "ADBE Vector Shape" || Z === 2 ? K.path : null } var J = propertyGroupFactory(K, Y); return X.setGroupProperty(PropertyInterface("Path", J)), Object.defineProperties(K, { path: { get: function () { return X.k && X.getValue(), X } }, shape: { get: function () { return X.k && X.getValue(), X } }, _name: { value: F.nm }, ix: { value: F.ix }, propertyIndex: { value: F.ix }, mn: { value: F.mn }, propertyGroup: { value: Y } }), K } }(), ShapeExpressionInterface = function () { function z(ne, re, fe) { var ae = [], he, le = ne ? ne.length : 0; for (he = 0; he < le; he += 1)ne[he].ty === "gr" ? ae.push(G(ne[he], re[he], fe)) : ne[he].ty === "fl" ? ae.push(Y(ne[he], re[he], fe)) : ne[he].ty === "st" ? ae.push(J(ne[he], re[he], fe)) : ne[he].ty === "tm" ? ae.push(Z(ne[he], re[he], fe)) : ne[he].ty === "tr" || (ne[he].ty === "el" ? ae.push(ee(ne[he], re[he], fe)) : ne[he].ty === "sr" ? ae.push(te(ne[he], re[he], fe)) : ne[he].ty === "sh" ? ae.push(ShapePathInterface(ne[he], re[he], fe)) : ne[he].ty === "rc" ? ae.push(oe(ne[he], re[he], fe)) : ne[he].ty === "rd" ? ae.push(ie(ne[he], re[he], fe)) : ne[he].ty === "rp" ? ae.push(se(ne[he], re[he], fe)) : ne[he].ty === "gf" ? ae.push(X(ne[he], re[he], fe)) : ae.push(K(ne[he], re[he]))); return ae } function F(ne, re, fe) { var ae, he = function (ue) { for (var me = 0, ge = ae.length; me < ge;) { if (ae[me]._name === ue || ae[me].mn === ue || ae[me].propertyIndex === ue || ae[me].ix === ue || ae[me].ind === ue) return ae[me]; me += 1 } return typeof ue == "number" ? ae[ue - 1] : null }; he.propertyGroup = propertyGroupFactory(he, fe), ae = z(ne.it, re.it, he.propertyGroup), he.numProperties = ae.length; var le = Q(ne.it[ne.it.length - 1], re.it[re.it.length - 1], he.propertyGroup); return he.transform = le, he.propertyIndex = ne.cix, he._name = ne.nm, he } function G(ne, re, fe) { var ae = function (ue) { switch (ue) { case "ADBE Vectors Group": case "Contents": case 2: return ae.content; default: return ae.transform } }; ae.propertyGroup = propertyGroupFactory(ae, fe); var he = F(ne, re, ae.propertyGroup), le = Q(ne.it[ne.it.length - 1], re.it[re.it.length - 1], ae.propertyGroup); return ae.content = he, ae.transform = le, Object.defineProperty(ae, "_name", { get: function () { return ne.nm } }), ae.numProperties = ne.np, ae.propertyIndex = ne.ix, ae.nm = ne.nm, ae.mn = ne.mn, ae } function Y(ne, re, fe) { function ae(he) { return he === "Color" || he === "color" ? ae.color : he === "Opacity" || he === "opacity" ? ae.opacity : null } return Object.defineProperties(ae, { color: { get: ExpressionPropertyInterface(re.c) }, opacity: { get: ExpressionPropertyInterface(re.o) }, _name: { value: ne.nm }, mn: { value: ne.mn } }), re.c.setGroupProperty(PropertyInterface("Color", fe)), re.o.setGroupProperty(PropertyInterface("Opacity", fe)), ae } function X(ne, re, fe) { function ae(he) { return he === "Start Point" || he === "start point" ? ae.startPoint : he === "End Point" || he === "end point" ? ae.endPoint : he === "Opacity" || he === "opacity" ? ae.opacity : null } return Object.defineProperties(ae, { startPoint: { get: ExpressionPropertyInterface(re.s) }, endPoint: { get: ExpressionPropertyInterface(re.e) }, opacity: { get: ExpressionPropertyInterface(re.o) }, type: { get: function () { return "a" } }, _name: { value: ne.nm }, mn: { value: ne.mn } }), re.s.setGroupProperty(PropertyInterface("Start Point", fe)), re.e.setGroupProperty(PropertyInterface("End Point", fe)), re.o.setGroupProperty(PropertyInterface("Opacity", fe)), ae } function K() { function ne() { return null } return ne } function J(ne, re, fe) { var ae = propertyGroupFactory(ge, fe), he = propertyGroupFactory(me, ae); function le(ve) { Object.defineProperty(me, ne.d[ve].nm, { get: ExpressionPropertyInterface(re.d.dataProps[ve].p) }) } var ce, ue = ne.d ? ne.d.length : 0, me = {}; for (ce = 0; ce < ue; ce += 1)le(ce), re.d.dataProps[ce].p.setGroupProperty(he); function ge(ve) { return ve === "Color" || ve === "color" ? ge.color : ve === "Opacity" || ve === "opacity" ? ge.opacity : ve === "Stroke Width" || ve === "stroke width" ? ge.strokeWidth : null } return Object.defineProperties(ge, { color: { get: ExpressionPropertyInterface(re.c) }, opacity: { get: ExpressionPropertyInterface(re.o) }, strokeWidth: { get: ExpressionPropertyInterface(re.w) }, dash: { get: function () { return me } }, _name: { value: ne.nm }, mn: { value: ne.mn } }), re.c.setGroupProperty(PropertyInterface("Color", ae)), re.o.setGroupProperty(PropertyInterface("Opacity", ae)), re.w.setGroupProperty(PropertyInterface("Stroke Width", ae)), ge } function Z(ne, re, fe) { function ae(le) { return le === ne.e.ix || le === "End" || le === "end" ? ae.end : le === ne.s.ix ? ae.start : le === ne.o.ix ? ae.offset : null } var he = propertyGroupFactory(ae, fe); return ae.propertyIndex = ne.ix, re.s.setGroupProperty(PropertyInterface("Start", he)), re.e.setGroupProperty(PropertyInterface("End", he)), re.o.setGroupProperty(PropertyInterface("Offset", he)), ae.propertyIndex = ne.ix, ae.propertyGroup = fe, Object.defineProperties(ae, { start: { get: ExpressionPropertyInterface(re.s) }, end: { get: ExpressionPropertyInterface(re.e) }, offset: { get: ExpressionPropertyInterface(re.o) }, _name: { value: ne.nm } }), ae.mn = ne.mn, ae } function Q(ne, re, fe) { function ae(le) { return ne.a.ix === le || le === "Anchor Point" ? ae.anchorPoint : ne.o.ix === le || le === "Opacity" ? ae.opacity : ne.p.ix === le || le === "Position" ? ae.position : ne.r.ix === le || le === "Rotation" || le === "ADBE Vector Rotation" ? ae.rotation : ne.s.ix === le || le === "Scale" ? ae.scale : ne.sk && ne.sk.ix === le || le === "Skew" ? ae.skew : ne.sa && ne.sa.ix === le || le === "Skew Axis" ? ae.skewAxis : null } var he = propertyGroupFactory(ae, fe); return re.transform.mProps.o.setGroupProperty(PropertyInterface("Opacity", he)), re.transform.mProps.p.setGroupProperty(PropertyInterface("Position", he)), re.transform.mProps.a.setGroupProperty(PropertyInterface("Anchor Point", he)), re.transform.mProps.s.setGroupProperty(PropertyInterface("Scale", he)), re.transform.mProps.r.setGroupProperty(PropertyInterface("Rotation", he)), re.transform.mProps.sk && (re.transform.mProps.sk.setGroupProperty(PropertyInterface("Skew", he)), re.transform.mProps.sa.setGroupProperty(PropertyInterface("Skew Angle", he))), re.transform.op.setGroupProperty(PropertyInterface("Opacity", he)), Object.defineProperties(ae, { opacity: { get: ExpressionPropertyInterface(re.transform.mProps.o) }, position: { get: ExpressionPropertyInterface(re.transform.mProps.p) }, anchorPoint: { get: ExpressionPropertyInterface(re.transform.mProps.a) }, scale: { get: ExpressionPropertyInterface(re.transform.mProps.s) }, rotation: { get: ExpressionPropertyInterface(re.transform.mProps.r) }, skew: { get: ExpressionPropertyInterface(re.transform.mProps.sk) }, skewAxis: { get: ExpressionPropertyInterface(re.transform.mProps.sa) }, _name: { value: ne.nm } }), ae.ty = "tr", ae.mn = ne.mn, ae.propertyGroup = fe, ae } function ee(ne, re, fe) { function ae(ce) { return ne.p.ix === ce ? ae.position : ne.s.ix === ce ? ae.size : null } var he = propertyGroupFactory(ae, fe); ae.propertyIndex = ne.ix; var le = re.sh.ty === "tm" ? re.sh.prop : re.sh; return le.s.setGroupProperty(PropertyInterface("Size", he)), le.p.setGroupProperty(PropertyInterface("Position", he)), Object.defineProperties(ae, { size: { get: ExpressionPropertyInterface(le.s) }, position: { get: ExpressionPropertyInterface(le.p) }, _name: { value: ne.nm } }), ae.mn = ne.mn, ae } function te(ne, re, fe) { function ae(ce) { return ne.p.ix === ce ? ae.position : ne.r.ix === ce ? ae.rotation : ne.pt.ix === ce ? ae.points : ne.or.ix === ce || ce === "ADBE Vector Star Outer Radius" ? ae.outerRadius : ne.os.ix === ce ? ae.outerRoundness : ne.ir && (ne.ir.ix === ce || ce === "ADBE Vector Star Inner Radius") ? ae.innerRadius : ne.is && ne.is.ix === ce ? ae.innerRoundness : null } var he = propertyGroupFactory(ae, fe), le = re.sh.ty === "tm" ? re.sh.prop : re.sh; return ae.propertyIndex = ne.ix, le.or.setGroupProperty(PropertyInterface("Outer Radius", he)), le.os.setGroupProperty(PropertyInterface("Outer Roundness", he)), le.pt.setGroupProperty(PropertyInterface("Points", he)), le.p.setGroupProperty(PropertyInterface("Position", he)), le.r.setGroupProperty(PropertyInterface("Rotation", he)), ne.ir && (le.ir.setGroupProperty(PropertyInterface("Inner Radius", he)), le.is.setGroupProperty(PropertyInterface("Inner Roundness", he))), Object.defineProperties(ae, { position: { get: ExpressionPropertyInterface(le.p) }, rotation: { get: ExpressionPropertyInterface(le.r) }, points: { get: ExpressionPropertyInterface(le.pt) }, outerRadius: { get: ExpressionPropertyInterface(le.or) }, outerRoundness: { get: ExpressionPropertyInterface(le.os) }, innerRadius: { get: ExpressionPropertyInterface(le.ir) }, innerRoundness: { get: ExpressionPropertyInterface(le.is) }, _name: { value: ne.nm } }), ae.mn = ne.mn, ae } function oe(ne, re, fe) { function ae(ce) { return ne.p.ix === ce ? ae.position : ne.r.ix === ce ? ae.roundness : ne.s.ix === ce || ce === "Size" || ce === "ADBE Vector Rect Size" ? ae.size : null } var he = propertyGroupFactory(ae, fe), le = re.sh.ty === "tm" ? re.sh.prop : re.sh; return ae.propertyIndex = ne.ix, le.p.setGroupProperty(PropertyInterface("Position", he)), le.s.setGroupProperty(PropertyInterface("Size", he)), le.r.setGroupProperty(PropertyInterface("Rotation", he)), Object.defineProperties(ae, { position: { get: ExpressionPropertyInterface(le.p) }, roundness: { get: ExpressionPropertyInterface(le.r) }, size: { get: ExpressionPropertyInterface(le.s) }, _name: { value: ne.nm } }), ae.mn = ne.mn, ae } function ie(ne, re, fe) { function ae(ce) { return ne.r.ix === ce || ce === "Round Corners 1" ? ae.radius : null } var he = propertyGroupFactory(ae, fe), le = re; return ae.propertyIndex = ne.ix, le.rd.setGroupProperty(PropertyInterface("Radius", he)), Object.defineProperties(ae, { radius: { get: ExpressionPropertyInterface(le.rd) }, _name: { value: ne.nm } }), ae.mn = ne.mn, ae } function se(ne, re, fe) { function ae(ce) { return ne.c.ix === ce || ce === "Copies" ? ae.copies : ne.o.ix === ce || ce === "Offset" ? ae.offset : null } var he = propertyGroupFactory(ae, fe), le = re; return ae.propertyIndex = ne.ix, le.c.setGroupProperty(PropertyInterface("Copies", he)), le.o.setGroupProperty(PropertyInterface("Offset", he)), Object.defineProperties(ae, { copies: { get: ExpressionPropertyInterface(le.c) }, offset: { get: ExpressionPropertyInterface(le.o) }, _name: { value: ne.nm } }), ae.mn = ne.mn, ae } return function (ne, re, fe) { var ae; function he(ce) { if (typeof ce == "number") return ce = ce === void 0 ? 1 : ce, ce === 0 ? fe : ae[ce - 1]; for (var ue = 0, me = ae.length; ue < me;) { if (ae[ue]._name === ce) return ae[ue]; ue += 1 } return null } function le() { return fe } return he.propertyGroup = propertyGroupFactory(he, le), ae = z(ne, re, he.propertyGroup), he.numProperties = ae.length, he._name = "Contents", he } }(), TextExpressionInterface = function () { return function (z) { var F; function G(Y) { switch (Y) { case "ADBE Text Document": return G.sourceText; default: return null } } return Object.defineProperty(G, "sourceText", { get: function () { z.textProperty.getValue(); var X = z.textProperty.currentData.t; return (!F || X !== F.value) && (F = new String(X), F.value = X || new String(X), Object.defineProperty(F, "style", { get: function () { return { fillColor: z.textProperty.currentData.fc } } })), F } }), G } }(); function _typeof(z) { "@babel/helpers - typeof"; return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof = function (G) { return typeof G } : _typeof = function (G) { return G && typeof Symbol == "function" && G.constructor === Symbol && G !== Symbol.prototype ? "symbol" : typeof G }, _typeof(z) } var FootageInterface = function () { var z = function (Y) { var X = "", K = Y.getFootageData(); function J() { return X = "", K = Y.getFootageData(), Z } function Z(Q) { if (K[Q]) return X = Q, K = K[Q], _typeof(K) === "object" ? Z : K; var ee = Q.indexOf(X); if (ee !== -1) { var te = parseInt(Q.substr(ee + X.length), 10); return K = K[te], _typeof(K) === "object" ? Z : K } return "" } return J }, F = function (Y) { function X(K) { return K === "Outline" ? X.outlineInterface() : null } return X._name = "Outline", X.outlineInterface = z(Y), X }; return function (G) { function Y(X) { return X === "Data" ? Y.dataInterface : null } return Y._name = "Data", Y.dataInterface = F(G), Y } }(), interfaces = { layer: LayerExpressionInterface, effects: EffectsExpressionInterface, comp: CompExpressionInterface, shape: ShapeExpressionInterface, text: TextExpressionInterface, footage: FootageInterface }; function getInterface(z) { return interfaces[z] || null } var expressionHelpers = function () { function z(J, Z, Q) { Z.x && (Q.k = !0, Q.x = !0, Q.initiateExpression = ExpressionManager.initiateExpression, Q.effectsSequence.push(Q.initiateExpression(J, Z, Q).bind(Q))) } function F(J) { return J *= this.elem.globalData.frameRate, J -= this.offsetTime, J !== this._cachingAtTime.lastFrame && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < J ? this._cachingAtTime.lastIndex : 0, this._cachingAtTime.value = this.interpolateValue(J, this._cachingAtTime), this._cachingAtTime.lastFrame = J), this._cachingAtTime.value } function G(J) { var Z = -.01, Q = this.getValueAtTime(J), ee = this.getValueAtTime(J + Z), te = 0; if (Q.length) { var oe; for (oe = 0; oe < Q.length; oe += 1)te += Math.pow(ee[oe] - Q[oe], 2); te = Math.sqrt(te) * 100 } else te = 0; return te } function Y(J) { if (this.vel !== void 0) return this.vel; var Z = -.001, Q = this.getValueAtTime(J), ee = this.getValueAtTime(J + Z), te; if (Q.length) { te = createTypedArray("float32", Q.length); var oe; for (oe = 0; oe < Q.length; oe += 1)te[oe] = (ee[oe] - Q[oe]) / Z } else te = (ee - Q) / Z; return te } function X() { return this.pv } function K(J) { this.propertyGroup = J } return { searchExpressions: z, getSpeedAtTime: G, getVelocityAtTime: Y, getValueAtTime: F, getStaticValueAtTime: X, setGroupProperty: K } }(); function addPropertyDecorator() { function z(ie, se, ne) { if (!this.k || !this.keyframes) return this.pv; ie = ie ? ie.toLowerCase() : ""; var re = this.comp.renderedFrame, fe = this.keyframes, ae = fe[fe.length - 1].t; if (re <= ae) return this.pv; var he, le; ne ? (se ? he = Math.abs(ae - this.elem.comp.globalData.frameRate * se) : he = Math.max(0, ae - this.elem.data.ip), le = ae - he) : ((!se || se > fe.length - 1) && (se = fe.length - 1), le = fe[fe.length - 1 - se].t, he = ae - le); var ce, ue, me; if (ie === "pingpong") { var ge = Math.floor((re - le) / he); if (ge % 2 !== 0) return this.getValueAtTime((he - (re - le) % he + le) / this.comp.globalData.frameRate, 0) } else if (ie === "offset") { var ve = this.getValueAtTime(le / this.comp.globalData.frameRate, 0), Se = this.getValueAtTime(ae / this.comp.globalData.frameRate, 0), ke = this.getValueAtTime(((re - le) % he + le) / this.comp.globalData.frameRate, 0), Ce = Math.floor((re - le) / he); if (this.pv.length) { for (me = new Array(ve.length), ue = me.length, ce = 0; ce < ue; ce += 1)me[ce] = (Se[ce] - ve[ce]) * Ce + ke[ce]; return me } return (Se - ve) * Ce + ke } else if (ie === "continue") { var Ee = this.getValueAtTime(ae / this.comp.globalData.frameRate, 0), De = this.getValueAtTime((ae - .001) / this.comp.globalData.frameRate, 0); if (this.pv.length) { for (me = new Array(Ee.length), ue = me.length, ce = 0; ce < ue; ce += 1)me[ce] = Ee[ce] + (Ee[ce] - De[ce]) * ((re - ae) / this.comp.globalData.frameRate) / 5e-4; return me } return Ee + (Ee - De) * ((re - ae) / .001) } return this.getValueAtTime(((re - le) % he + le) / this.comp.globalData.frameRate, 0) } function F(ie, se, ne) { if (!this.k) return this.pv; ie = ie ? ie.toLowerCase() : ""; var re = this.comp.renderedFrame, fe = this.keyframes, ae = fe[0].t; if (re >= ae) return this.pv; var he, le; ne ? (se ? he = Math.abs(this.elem.comp.globalData.frameRate * se) : he = Math.max(0, this.elem.data.op - ae), le = ae + he) : ((!se || se > fe.length - 1) && (se = fe.length - 1), le = fe[se].t, he = le - ae); var ce, ue, me; if (ie === "pingpong") { var ge = Math.floor((ae - re) / he); if (ge % 2 === 0) return this.getValueAtTime(((ae - re) % he + ae) / this.comp.globalData.frameRate, 0) } else if (ie === "offset") { var ve = this.getValueAtTime(ae / this.comp.globalData.frameRate, 0), Se = this.getValueAtTime(le / this.comp.globalData.frameRate, 0), ke = this.getValueAtTime((he - (ae - re) % he + ae) / this.comp.globalData.frameRate, 0), Ce = Math.floor((ae - re) / he) + 1; if (this.pv.length) { for (me = new Array(ve.length), ue = me.length, ce = 0; ce < ue; ce += 1)me[ce] = ke[ce] - (Se[ce] - ve[ce]) * Ce; return me } return ke - (Se - ve) * Ce } else if (ie === "continue") { var Ee = this.getValueAtTime(ae / this.comp.globalData.frameRate, 0), De = this.getValueAtTime((ae + .001) / this.comp.globalData.frameRate, 0); if (this.pv.length) { for (me = new Array(Ee.length), ue = me.length, ce = 0; ce < ue; ce += 1)me[ce] = Ee[ce] + (Ee[ce] - De[ce]) * (ae - re) / .001; return me } return Ee + (Ee - De) * (ae - re) / .001 } return this.getValueAtTime((he - ((ae - re) % he + ae)) / this.comp.globalData.frameRate, 0) } function G(ie, se) { if (!this.k) return this.pv; if (ie = (ie || .4) * .5, se = Math.floor(se || 5), se <= 1) return this.pv; var ne = this.comp.renderedFrame / this.comp.globalData.frameRate, re = ne - ie, fe = ne + ie, ae = se > 1 ? (fe - re) / (se - 1) : 1, he = 0, le = 0, ce; this.pv.length ? ce = createTypedArray("float32", this.pv.length) : ce = 0; for (var ue; he < se;) { if (ue = this.getValueAtTime(re + he * ae), this.pv.length) for (le = 0; le < this.pv.length; le += 1)ce[le] += ue[le]; else ce += ue; he += 1 } if (this.pv.length) for (le = 0; le < this.pv.length; le += 1)ce[le] /= se; else ce /= se; return ce } function Y(ie) { this._transformCachingAtTime || (this._transformCachingAtTime = { v: new Matrix }); var se = this._transformCachingAtTime.v; if (se.cloneFromProps(this.pre.props), this.appliedTransformations < 1) { var ne = this.a.getValueAtTime(ie); se.translate(-ne[0] * this.a.mult, -ne[1] * this.a.mult, ne[2] * this.a.mult) } if (this.appliedTransformations < 2) { var re = this.s.getValueAtTime(ie); se.scale(re[0] * this.s.mult, re[1] * this.s.mult, re[2] * this.s.mult) } if (this.sk && this.appliedTransformations < 3) { var fe = this.sk.getValueAtTime(ie), ae = this.sa.getValueAtTime(ie); se.skewFromAxis(-fe * this.sk.mult, ae * this.sa.mult) } if (this.r && this.appliedTransformations < 4) { var he = this.r.getValueAtTime(ie); se.rotate(-he * this.r.mult) } else if (!this.r && this.appliedTransformations < 4) { var le = this.rz.getValueAtTime(ie), ce = this.ry.getValueAtTime(ie), ue = this.rx.getValueAtTime(ie), me = this.or.getValueAtTime(ie); se.rotateZ(-le * this.rz.mult).rotateY(ce * this.ry.mult).rotateX(ue * this.rx.mult).rotateZ(-me[2] * this.or.mult).rotateY(me[1] * this.or.mult).rotateX(me[0] * this.or.mult) } if (this.data.p && this.data.p.s) { var ge = this.px.getValueAtTime(ie), ve = this.py.getValueAtTime(ie); if (this.data.p.z) { var Se = this.pz.getValueAtTime(ie); se.translate(ge * this.px.mult, ve * this.py.mult, -Se * this.pz.mult) } else se.translate(ge * this.px.mult, ve * this.py.mult, 0) } else { var ke = this.p.getValueAtTime(ie); se.translate(ke[0] * this.p.mult, ke[1] * this.p.mult, -ke[2] * this.p.mult) } return se } function X() { return this.v.clone(new Matrix) } var K = TransformPropertyFactory.getTransformProperty; TransformPropertyFactory.getTransformProperty = function (ie, se, ne) { var re = K(ie, se, ne); return re.dynamicProperties.length ? re.getValueAtTime = Y.bind(re) : re.getValueAtTime = X.bind(re), re.setGroupProperty = expressionHelpers.setGroupProperty, re }; var J = PropertyFactory.getProp; PropertyFactory.getProp = function (ie, se, ne, re, fe) { var ae = J(ie, se, ne, re, fe); ae.kf ? ae.getValueAtTime = expressionHelpers.getValueAtTime.bind(ae) : ae.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(ae), ae.setGroupProperty = expressionHelpers.setGroupProperty, ae.loopOut = z, ae.loopIn = F, ae.smooth = G, ae.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(ae), ae.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(ae), ae.numKeys = se.a === 1 ? se.k.length : 0, ae.propertyIndex = se.ix; var he = 0; return ne !== 0 && (he = createTypedArray("float32", se.a === 1 ? se.k[0].s.length : se.k.length)), ae._cachingAtTime = { lastFrame: initialDefaultFrame, lastIndex: 0, value: he }, expressionHelpers.searchExpressions(ie, se, ae), ae.k && fe.addDynamicProperty(ae), ae }; function Z(ie) { return this._cachingAtTime || (this._cachingAtTime = { shapeValue: shapePool.clone(this.pv), lastIndex: 0, lastTime: initialDefaultFrame }), ie *= this.elem.globalData.frameRate, ie -= this.offsetTime, ie !== this._cachingAtTime.lastTime && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < ie ? this._caching.lastIndex : 0, this._cachingAtTime.lastTime = ie, this.interpolateShape(ie, this._cachingAtTime.shapeValue, this._cachingAtTime)), this._cachingAtTime.shapeValue } var Q = ShapePropertyFactory.getConstructorFunction(), ee = ShapePropertyFactory.getKeyframedConstructorFunction(); function te() { } te.prototype = { vertices: function (se, ne) { this.k && this.getValue(); var re = this.v; ne !== void 0 && (re = this.getValueAtTime(ne, 0)); var fe, ae = re._length, he = re[se], le = re.v, ce = createSizedArray(ae); for (fe = 0; fe < ae; fe += 1)se === "i" || se === "o" ? ce[fe] = [he[fe][0] - le[fe][0], he[fe][1] - le[fe][1]] : ce[fe] = [he[fe][0], he[fe][1]]; return ce }, points: function (se) { return this.vertices("v", se) }, inTangents: function (se) { return this.vertices("i", se) }, outTangents: function (se) { return this.vertices("o", se) }, isClosed: function () { return this.v.c }, pointOnPath: function (se, ne) { var re = this.v; ne !== void 0 && (re = this.getValueAtTime(ne, 0)), this._segmentsLength || (this._segmentsLength = bez.getSegmentsLength(re)); for (var fe = this._segmentsLength, ae = fe.lengths, he = fe.totalLength * se, le = 0, ce = ae.length, ue = 0, me; le < ce;) { if (ue + ae[le].addedLength > he) { var ge = le, ve = re.c && le === ce - 1 ? 0 : le + 1, Se = (he - ue) / ae[le].addedLength; me = bez.getPointInSegment(re.v[ge], re.v[ve], re.o[ge], re.i[ve], Se, ae[le]); break } else ue += ae[le].addedLength; le += 1 } return me || (me = re.c ? [re.v[0][0], re.v[0][1]] : [re.v[re._length - 1][0], re.v[re._length - 1][1]]), me }, vectorOnPath: function (se, ne, re) { se == 1 ? se = this.v.c : se == 0 && (se = .999); var fe = this.pointOnPath(se, ne), ae = this.pointOnPath(se + .001, ne), he = ae[0] - fe[0], le = ae[1] - fe[1], ce = Math.sqrt(Math.pow(he, 2) + Math.pow(le, 2)); if (ce === 0) return [0, 0]; var ue = re === "tangent" ? [he / ce, le / ce] : [-le / ce, he / ce]; return ue }, tangentOnPath: function (se, ne) { return this.vectorOnPath(se, ne, "tangent") }, normalOnPath: function (se, ne) { return this.vectorOnPath(se, ne, "normal") }, setGroupProperty: expressionHelpers.setGroupProperty, getValueAtTime: expressionHelpers.getStaticValueAtTime }, extendPrototype([te], Q), extendPrototype([te], ee), ee.prototype.getValueAtTime = Z, ee.prototype.initiateExpression = ExpressionManager.initiateExpression; var oe = ShapePropertyFactory.getShapeProp; ShapePropertyFactory.getShapeProp = function (ie, se, ne, re, fe) { var ae = oe(ie, se, ne, re, fe); return ae.propertyIndex = se.ix, ae.lock = !1, ne === 3 ? expressionHelpers.searchExpressions(ie, se.pt, ae) : ne === 4 && expressionHelpers.searchExpressions(ie, se.ks, ae), ae.k && ie.addDynamicProperty(ae), ae } } function initialize$1() { addPropertyDecorator() } function addDecorator() { function z() { return this.data.d.x ? (this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this), this.addEffect(this.getExpressionValue.bind(this)), !0) : null } TextProperty.prototype.getExpressionValue = function (F, G) { var Y = this.calculateExpression(G); if (F.t !== Y) { var X = {}; return this.copyData(X, F), X.t = Y.toString(), X.__complete = !1, X } return F }, TextProperty.prototype.searchProperty = function () { var F = this.searchKeyframes(), G = this.searchExpressions(); return this.kf = F || G, this.kf }, TextProperty.prototype.searchExpressions = z } function initialize() { addDecorator() } function SVGComposableEffect() { } SVGComposableEffect.prototype = { createMergeNode: function z(F, G) { var Y = createNS("feMerge"); Y.setAttribute("result", F); var X, K; for (K = 0; K < G.length; K += 1)X = createNS("feMergeNode"), X.setAttribute("in", G[K]), Y.appendChild(X), Y.appendChild(X); return Y } }; var linearFilterValue = "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0"; function SVGTintFilter(z, F, G, Y, X) { this.filterManager = F; var K = createNS("feColorMatrix"); K.setAttribute("type", "matrix"), K.setAttribute("color-interpolation-filters", "linearRGB"), K.setAttribute("values", linearFilterValue + " 1 0"), this.linearFilter = K, K.setAttribute("result", Y + "_tint_1"), z.appendChild(K), K = createNS("feColorMatrix"), K.setAttribute("type", "matrix"), K.setAttribute("color-interpolation-filters", "sRGB"), K.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"), K.setAttribute("result", Y + "_tint_2"), z.appendChild(K), this.matrixFilter = K; var J = this.createMergeNode(Y, [X, Y + "_tint_1", Y + "_tint_2"]); z.appendChild(J) } extendPrototype([SVGComposableEffect], SVGTintFilter), SVGTintFilter.prototype.renderFrame = function (z) { if (z || this.filterManager._mdf) { var F = this.filterManager.effectElements[0].p.v, G = this.filterManager.effectElements[1].p.v, Y = this.filterManager.effectElements[2].p.v / 100; this.linearFilter.setAttribute("values", linearFilterValue + " " + Y + " 0"), this.matrixFilter.setAttribute("values", G[0] - F[0] + " 0 0 0 " + F[0] + " " + (G[1] - F[1]) + " 0 0 0 " + F[1] + " " + (G[2] - F[2]) + " 0 0 0 " + F[2] + " 0 0 0 1 0") } }; function SVGFillFilter(z, F, G, Y) { this.filterManager = F; var X = createNS("feColorMatrix"); X.setAttribute("type", "matrix"), X.setAttribute("color-interpolation-filters", "sRGB"), X.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"), X.setAttribute("result", Y), z.appendChild(X), this.matrixFilter = X } SVGFillFilter.prototype.renderFrame = function (z) { if (z || this.filterManager._mdf) { var F = this.filterManager.effectElements[2].p.v, G = this.filterManager.effectElements[6].p.v; this.matrixFilter.setAttribute("values", "0 0 0 0 " + F[0] + " 0 0 0 0 " + F[1] + " 0 0 0 0 " + F[2] + " 0 0 0 " + G + " 0") } }; function SVGStrokeEffect(z, F, G) { this.initialized = !1, this.filterManager = F, this.elem = G, this.paths = [] } SVGStrokeEffect.prototype.initialize = function () { var z = this.elem.layerElement.children || this.elem.layerElement.childNodes, F, G, Y, X; for (this.filterManager.effectElements[1].p.v === 1 ? (X = this.elem.maskManager.masksProperties.length, Y = 0) : (Y = this.filterManager.effectElements[0].p.v - 1, X = Y + 1), G = createNS("g"), G.setAttribute("fill", "none"), G.setAttribute("stroke-linecap", "round"), G.setAttribute("stroke-dashoffset", 1), Y; Y < X; Y += 1)F = createNS("path"), G.appendChild(F), this.paths.push({ p: F, m: Y }); if (this.filterManager.effectElements[10].p.v === 3) { var K = createNS("mask"), J = createElementID(); K.setAttribute("id", J), K.setAttribute("mask-type", "alpha"), K.appendChild(G), this.elem.globalData.defs.appendChild(K); var Z = createNS("g"); for (Z.setAttribute("mask", "url(" + getLocationHref() + "#" + J + ")"); z[0];)Z.appendChild(z[0]); this.elem.layerElement.appendChild(Z), this.masker = K, G.setAttribute("stroke", "#fff") } else if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) { if (this.filterManager.effectElements[10].p.v === 2) for (z = this.elem.layerElement.children || this.elem.layerElement.childNodes; z.length;)this.elem.layerElement.removeChild(z[0]); this.elem.layerElement.appendChild(G), this.elem.layerElement.removeAttribute("mask"), G.setAttribute("stroke", "#fff") } this.initialized = !0, this.pathMasker = G }, SVGStrokeEffect.prototype.renderFrame = function (z) { this.initialized || this.initialize(); var F, G = this.paths.length, Y, X; for (F = 0; F < G; F += 1)if (this.paths[F].m !== -1 && (Y = this.elem.maskManager.viewData[this.paths[F].m], X = this.paths[F].p, (z || this.filterManager._mdf || Y.prop._mdf) && X.setAttribute("d", Y.lastPath), z || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || Y.prop._mdf)) { var K; if (this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100) { var J = Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * .01, Z = Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * .01, Q = X.getTotalLength(); K = "0 0 0 " + Q * J + " "; var ee = Q * (Z - J), te = 1 + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * .01, oe = Math.floor(ee / te), ie; for (ie = 0; ie < oe; ie += 1)K += "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * .01 + " "; K += "0 " + Q * 10 + " 0 0" } else K = "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * .01; X.setAttribute("stroke-dasharray", K) } if ((z || this.filterManager.effectElements[4].p._mdf) && this.pathMasker.setAttribute("stroke-width", this.filterManager.effectElements[4].p.v * 2), (z || this.filterManager.effectElements[6].p._mdf) && this.pathMasker.setAttribute("opacity", this.filterManager.effectElements[6].p.v), (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) && (z || this.filterManager.effectElements[3].p._mdf)) { var se = this.filterManager.effectElements[3].p.v; this.pathMasker.setAttribute("stroke", "rgb(" + bmFloor(se[0] * 255) + "," + bmFloor(se[1] * 255) + "," + bmFloor(se[2] * 255) + ")") } }; function SVGTritoneFilter(z, F, G, Y) { this.filterManager = F; var X = createNS("feColorMatrix"); X.setAttribute("type", "matrix"), X.setAttribute("color-interpolation-filters", "linearRGB"), X.setAttribute("values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"), z.appendChild(X); var K = createNS("feComponentTransfer"); K.setAttribute("color-interpolation-filters", "sRGB"), K.setAttribute("result", Y), this.matrixFilter = K; var J = createNS("feFuncR"); J.setAttribute("type", "table"), K.appendChild(J), this.feFuncR = J; var Z = createNS("feFuncG"); Z.setAttribute("type", "table"), K.appendChild(Z), this.feFuncG = Z; var Q = createNS("feFuncB"); Q.setAttribute("type", "table"), K.appendChild(Q), this.feFuncB = Q, z.appendChild(K) } SVGTritoneFilter.prototype.renderFrame = function (z) { if (z || this.filterManager._mdf) { var F = this.filterManager.effectElements[0].p.v, G = this.filterManager.effectElements[1].p.v, Y = this.filterManager.effectElements[2].p.v, X = Y[0] + " " + G[0] + " " + F[0], K = Y[1] + " " + G[1] + " " + F[1], J = Y[2] + " " + G[2] + " " + F[2]; this.feFuncR.setAttribute("tableValues", X), this.feFuncG.setAttribute("tableValues", K), this.feFuncB.setAttribute("tableValues", J) } }; function SVGProLevelsFilter(z, F, G, Y) { this.filterManager = F; var X = this.filterManager.effectElements, K = createNS("feComponentTransfer"); (X[10].p.k || X[10].p.v !== 0 || X[11].p.k || X[11].p.v !== 1 || X[12].p.k || X[12].p.v !== 1 || X[13].p.k || X[13].p.v !== 0 || X[14].p.k || X[14].p.v !== 1) && (this.feFuncR = this.createFeFunc("feFuncR", K)), (X[17].p.k || X[17].p.v !== 0 || X[18].p.k || X[18].p.v !== 1 || X[19].p.k || X[19].p.v !== 1 || X[20].p.k || X[20].p.v !== 0 || X[21].p.k || X[21].p.v !== 1) && (this.feFuncG = this.createFeFunc("feFuncG", K)), (X[24].p.k || X[24].p.v !== 0 || X[25].p.k || X[25].p.v !== 1 || X[26].p.k || X[26].p.v !== 1 || X[27].p.k || X[27].p.v !== 0 || X[28].p.k || X[28].p.v !== 1) && (this.feFuncB = this.createFeFunc("feFuncB", K)), (X[31].p.k || X[31].p.v !== 0 || X[32].p.k || X[32].p.v !== 1 || X[33].p.k || X[33].p.v !== 1 || X[34].p.k || X[34].p.v !== 0 || X[35].p.k || X[35].p.v !== 1) && (this.feFuncA = this.createFeFunc("feFuncA", K)), (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) && (K.setAttribute("color-interpolation-filters", "sRGB"), z.appendChild(K)), (X[3].p.k || X[3].p.v !== 0 || X[4].p.k || X[4].p.v !== 1 || X[5].p.k || X[5].p.v !== 1 || X[6].p.k || X[6].p.v !== 0 || X[7].p.k || X[7].p.v !== 1) && (K = createNS("feComponentTransfer"), K.setAttribute("color-interpolation-filters", "sRGB"), K.setAttribute("result", Y), z.appendChild(K), this.feFuncRComposed = this.createFeFunc("feFuncR", K), this.feFuncGComposed = this.createFeFunc("feFuncG", K), this.feFuncBComposed = this.createFeFunc("feFuncB", K)) } SVGProLevelsFilter.prototype.createFeFunc = function (z, F) { var G = createNS(z); return G.setAttribute("type", "table"), F.appendChild(G), G }, SVGProLevelsFilter.prototype.getTableValue = function (z, F, G, Y, X) { for (var K = 0, J = 256, Z, Q = Math.min(z, F), ee = Math.max(z, F), te = Array.call(null, { length: J }), oe, ie = 0, se = X - Y, ne = F - z; K <= 256;)Z = K / 256, Z <= Q ? oe = ne < 0 ? X : Y : Z >= ee ? oe = ne < 0 ? Y : X : oe = Y + se * Math.pow((Z - z) / ne, 1 / G), te[ie] = oe, ie += 1, K += 256 / (J - 1); return te.join(" ") }, SVGProLevelsFilter.prototype.renderFrame = function (z) { if (z || this.filterManager._mdf) { var F, G = this.filterManager.effectElements; this.feFuncRComposed && (z || G[3].p._mdf || G[4].p._mdf || G[5].p._mdf || G[6].p._mdf || G[7].p._mdf) && (F = this.getTableValue(G[3].p.v, G[4].p.v, G[5].p.v, G[6].p.v, G[7].p.v), this.feFuncRComposed.setAttribute("tableValues", F), this.feFuncGComposed.setAttribute("tableValues", F), this.feFuncBComposed.setAttribute("tableValues", F)), this.feFuncR && (z || G[10].p._mdf || G[11].p._mdf || G[12].p._mdf || G[13].p._mdf || G[14].p._mdf) && (F = this.getTableValue(G[10].p.v, G[11].p.v, G[12].p.v, G[13].p.v, G[14].p.v), this.feFuncR.setAttribute("tableValues", F)), this.feFuncG && (z || G[17].p._mdf || G[18].p._mdf || G[19].p._mdf || G[20].p._mdf || G[21].p._mdf) && (F = this.getTableValue(G[17].p.v, G[18].p.v, G[19].p.v, G[20].p.v, G[21].p.v), this.feFuncG.setAttribute("tableValues", F)), this.feFuncB && (z || G[24].p._mdf || G[25].p._mdf || G[26].p._mdf || G[27].p._mdf || G[28].p._mdf) && (F = this.getTableValue(G[24].p.v, G[25].p.v, G[26].p.v, G[27].p.v, G[28].p.v), this.feFuncB.setAttribute("tableValues", F)), this.feFuncA && (z || G[31].p._mdf || G[32].p._mdf || G[33].p._mdf || G[34].p._mdf || G[35].p._mdf) && (F = this.getTableValue(G[31].p.v, G[32].p.v, G[33].p.v, G[34].p.v, G[35].p.v), this.feFuncA.setAttribute("tableValues", F)) } }; function SVGDropShadowEffect(z, F, G, Y, X) { var K = F.container.globalData.renderConfig.filterSize, J = F.data.fs || K; z.setAttribute("x", J.x || K.x), z.setAttribute("y", J.y || K.y), z.setAttribute("width", J.width || K.width), z.setAttribute("height", J.height || K.height), this.filterManager = F; var Z = createNS("feGaussianBlur"); Z.setAttribute("in", "SourceAlpha"), Z.setAttribute("result", Y + "_drop_shadow_1"), Z.setAttribute("stdDeviation", "0"), this.feGaussianBlur = Z, z.appendChild(Z); var Q = createNS("feOffset"); Q.setAttribute("dx", "25"), Q.setAttribute("dy", "0"), Q.setAttribute("in", Y + "_drop_shadow_1"), Q.setAttribute("result", Y + "_drop_shadow_2"), this.feOffset = Q, z.appendChild(Q); var ee = createNS("feFlood"); ee.setAttribute("flood-color", "#00ff00"), ee.setAttribute("flood-opacity", "1"), ee.setAttribute("result", Y + "_drop_shadow_3"), this.feFlood = ee, z.appendChild(ee); var te = createNS("feComposite"); te.setAttribute("in", Y + "_drop_shadow_3"), te.setAttribute("in2", Y + "_drop_shadow_2"), te.setAttribute("operator", "in"), te.setAttribute("result", Y + "_drop_shadow_4"), z.appendChild(te); var oe = this.createMergeNode(Y, [Y + "_drop_shadow_4", X]); z.appendChild(oe) } extendPrototype([SVGComposableEffect], SVGDropShadowEffect), SVGDropShadowEffect.prototype.renderFrame = function (z) { if (z || this.filterManager._mdf) { if ((z || this.filterManager.effectElements[4].p._mdf) && this.feGaussianBlur.setAttribute("stdDeviation", this.filterManager.effectElements[4].p.v / 4), z || this.filterManager.effectElements[0].p._mdf) { var F = this.filterManager.effectElements[0].p.v; this.feFlood.setAttribute("flood-color", rgbToHex(Math.round(F[0] * 255), Math.round(F[1] * 255), Math.round(F[2] * 255))) } if ((z || this.filterManager.effectElements[1].p._mdf) && this.feFlood.setAttribute("flood-opacity", this.filterManager.effectElements[1].p.v / 255), z || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) { var G = this.filterManager.effectElements[3].p.v, Y = (this.filterManager.effectElements[2].p.v - 90) * degToRads, X = G * Math.cos(Y), K = G * Math.sin(Y); this.feOffset.setAttribute("dx", X), this.feOffset.setAttribute("dy", K) } } }; var _svgMatteSymbols = []; function SVGMatte3Effect(z, F, G) { this.initialized = !1, this.filterManager = F, this.filterElem = z, this.elem = G, G.matteElement = createNS("g"), G.matteElement.appendChild(G.layerElement), G.matteElement.appendChild(G.transformedElement), G.baseElement = G.matteElement } SVGMatte3Effect.prototype.findSymbol = function (z) { for (var F = 0, G = _svgMatteSymbols.length; F < G;) { if (_svgMatteSymbols[F] === z) return _svgMatteSymbols[F]; F += 1 } return null }, SVGMatte3Effect.prototype.replaceInParent = function (z, F) { var G = z.layerElement.parentNode; if (G) { for (var Y = G.children, X = 0, K = Y.length; X < K && Y[X] !== z.layerElement;)X += 1; var J; X <= K - 2 && (J = Y[X + 1]); var Z = createNS("use"); Z.setAttribute("href", "#" + F), J ? G.insertBefore(Z, J) : G.appendChild(Z) } }, SVGMatte3Effect.prototype.setElementAsMask = function (z, F) { if (!this.findSymbol(F)) { var G = createElementID(), Y = createNS("mask"); Y.setAttribute("id", F.layerId), Y.setAttribute("mask-type", "alpha"), _svgMatteSymbols.push(F); var X = z.globalData.defs; X.appendChild(Y); var K = createNS("symbol"); K.setAttribute("id", G), this.replaceInParent(F, G), K.appendChild(F.layerElement), X.appendChild(K); var J = createNS("use"); J.setAttribute("href", "#" + G), Y.appendChild(J), F.data.hd = !1, F.show() } z.setMatte(F.layerId) }, SVGMatte3Effect.prototype.initialize = function () { for (var z = this.filterManager.effectElements[0].p.v, F = this.elem.comp.elements, G = 0, Y = F.length; G < Y;)F[G] && F[G].data.ind === z && this.setElementAsMask(this.elem, F[G]), G += 1; this.initialized = !0 }, SVGMatte3Effect.prototype.renderFrame = function () { this.initialized || this.initialize() }; function SVGGaussianBlurEffect(z, F, G, Y) { z.setAttribute("x", "-100%"), z.setAttribute("y", "-100%"), z.setAttribute("width", "300%"), z.setAttribute("height", "300%"), this.filterManager = F; var X = createNS("feGaussianBlur"); X.setAttribute("result", Y), z.appendChild(X), this.feGaussianBlur = X } SVGGaussianBlurEffect.prototype.renderFrame = function (z) { if (z || this.filterManager._mdf) { var F = .3, G = this.filterManager.effectElements[0].p.v * F, Y = this.filterManager.effectElements[1].p.v, X = Y == 3 ? 0 : G, K = Y == 2 ? 0 : G; this.feGaussianBlur.setAttribute("stdDeviation", X + " " + K); var J = this.filterManager.effectElements[2].p.v == 1 ? "wrap" : "duplicate"; this.feGaussianBlur.setAttribute("edgeMode", J) } }; function TransformEffect() { } TransformEffect.prototype.init = function (z) { this.effectsManager = z, this.type = effectTypes.TRANSFORM_EFFECT, this.matrix = new Matrix, this.opacity = -1, this._mdf = !1, this._opMdf = !1 }, TransformEffect.prototype.renderFrame = function (z) { if (this._opMdf = !1, this._mdf = !1, z || this.effectsManager._mdf) { var F = this.effectsManager.effectElements, G = F[0].p.v, Y = F[1].p.v, X = F[2].p.v === 1, K = F[3].p.v, J = X ? K : F[4].p.v, Z = F[5].p.v, Q = F[6].p.v, ee = F[7].p.v; this.matrix.reset(), this.matrix.translate(-G[0], -G[1], G[2]), this.matrix.scale(J * .01, K * .01, 1), this.matrix.rotate(-ee * degToRads), this.matrix.skewFromAxis(-Z * degToRads, (Q + 90) * degToRads), this.matrix.translate(Y[0], Y[1], 0), this._mdf = !0, this.opacity !== F[8].p.v && (this.opacity = F[8].p.v, this._opMdf = !0) } }; function SVGTransformEffect(z, F) { this.init(F) } extendPrototype([TransformEffect], SVGTransformEffect); function CVTransformEffect(z) { this.init(z) } return extendPrototype([TransformEffect], CVTransformEffect), registerRenderer("canvas", CanvasRenderer), registerRenderer("html", HybridRenderer), registerRenderer("svg", SVGRenderer), ShapeModifiers.registerModifier("tm", TrimModifier), ShapeModifiers.registerModifier("pb", PuckerAndBloatModifier), ShapeModifiers.registerModifier("rp", RepeaterModifier), ShapeModifiers.registerModifier("rd", RoundCornersModifier), ShapeModifiers.registerModifier("zz", ZigZagModifier), ShapeModifiers.registerModifier("op", OffsetPathModifier), setExpressionsPlugin(Expressions), setExpressionInterfaces(getInterface), initialize$1(), initialize(), registerEffect$1(20, SVGTintFilter, !0), registerEffect$1(21, SVGFillFilter, !0), registerEffect$1(22, SVGStrokeEffect, !1), registerEffect$1(23, SVGTritoneFilter, !0), registerEffect$1(24, SVGProLevelsFilter, !0), registerEffect$1(25, SVGDropShadowEffect, !0), registerEffect$1(28, SVGMatte3Effect, !1), registerEffect$1(29, SVGGaussianBlurEffect, !0), registerEffect$1(35, SVGTransformEffect, !1), registerEffect(35, CVTransformEffect), lottie
    })
})(lottie$1, lottie$1.exports); var lottieExports = lottie$1.exports; const lottie = getDefaultExportFromCjs(lottieExports), v$1 = "5.12.1", fr$1 = 60, ip$1 = 0, op$1 = 348, w$2 = 1040, h$2 = 1040, nm$1 = "Master", ddd$1 = 0, assets$1 = [{ id: "comp_0", nm: "Innter", fr: 60, layers: [{ ddd: 0, ind: 1, ty: 0, nm: "C03", refId: "comp_1", sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { s: !0, x: { a: 0, k: 520, ix: 3 }, y: { a: 0, k: 520, ix: 4 } }, a: { a: 0, k: [520, 520, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, w: 1040, h: 1040, ip: 195, op: 376, st: 195, bm: 0 }, { ddd: 0, ind: 2, ty: 0, nm: "C02", refId: "comp_2", sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { s: !0, x: { a: 0, k: 520, ix: 3 }, y: { a: 0, k: 520, ix: 4 } }, a: { a: 0, k: [520, 520, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, w: 1040, h: 1040, ip: 88, op: 208, st: 88, bm: 0 }, { ddd: 0, ind: 3, ty: 0, nm: "C01", refId: "comp_3", sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { s: !0, x: { a: 0, k: 520, ix: 3 }, y: { a: 0, k: 520, ix: 4 } }, a: { a: 0, k: [520, 520, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, w: 1040, h: 1040, ip: 0, op: 111, st: 0, bm: 0 }] }, { id: "comp_1", nm: "C03", fr: 60, layers: [{ ddd: 0, ind: 1, ty: 3, nm: "Null 5", sr: 1, ks: { o: { a: 0, k: 0, ix: 11 }, r: { a: 1, k: [{ i: { x: [.088], y: [1] }, o: { x: [.145], y: [.318] }, t: 0, s: [45.87] }, { t: 60, s: [0] }], ix: 10 }, p: { s: !0, x: { a: 0, k: 520, ix: 3 }, y: { a: 0, k: 520, ix: 4 } }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, ip: 0, op: 181, st: 0, bm: 0 }, { ddd: 0, ind: 2, ty: 4, nm: "fill circle 15", parent: 1, sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { s: !0, x: { a: 0, k: 0, ix: 3 }, y: { a: 1, k: [{ i: { x: [.13], y: [1] }, o: { x: [.277], y: [.918] }, t: 0, s: [0] }, { i: { x: [0], y: [1] }, o: { x: [.797], y: [0] }, t: 50, s: [-250] }, { i: { x: [.393], y: [1] }, o: { x: [.714], y: [0] }, t: 81, s: [-250] }, { t: 114, s: [0] }], ix: 4 } }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [80, 80, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ d: 1, ty: "el", s: { a: 1, k: [{ i: { x: [.833, .833], y: [.833, .833] }, o: { x: [.167, .167], y: [.167, .167] }, t: 104, s: [16, 16] }, { t: 114, s: [0, 0] }], ix: 2 }, p: { a: 0, k: [0, 0], ix: 3 }, nm: "Ellipse Path 1", mn: "ADBE Vector Shape - Ellipse", hd: !1 }, { ty: "fl", c: { a: 0, k: [1, 1, 1, 1], ix: 4 }, o: { a: 0, k: 100, ix: 5 }, r: 1, bm: 0, nm: "Fill 1", mn: "ADBE Vector Graphic - Fill", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [0, 0], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "Ellipse 1", np: 3, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 0, op: 136, st: 13, ct: 1, bm: 0 }, { ddd: 0, ind: 3, ty: 4, nm: "fill circle 14", parent: 1, sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { s: !0, x: { a: 0, k: 0, ix: 3 }, y: { a: 1, k: [{ i: { x: [0], y: [1] }, o: { x: [.146], y: [.756] }, t: 0, s: [0] }, { i: { x: [.393], y: [1] }, o: { x: [.714], y: [0] }, t: 81, s: [250] }, { t: 114, s: [0] }], ix: 4 } }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [80, 80, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ d: 1, ty: "el", s: { a: 1, k: [{ i: { x: [.833, .833], y: [.833, .833] }, o: { x: [.167, .167], y: [.167, .167] }, t: 104, s: [16, 16] }, { t: 114, s: [0, 0] }], ix: 2 }, p: { a: 0, k: [0, 0], ix: 3 }, nm: "Ellipse Path 1", mn: "ADBE Vector Shape - Ellipse", hd: !1 }, { ty: "fl", c: { a: 0, k: [1, 1, 1, 1], ix: 4 }, o: { a: 0, k: 100, ix: 5 }, r: 1, bm: 0, nm: "Fill 1", mn: "ADBE Vector Graphic - Fill", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [0, 0], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "Ellipse 1", np: 3, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 0, op: 136, st: 13, ct: 1, bm: 0 }, { ddd: 0, ind: 4, ty: 4, nm: "dasshed line 6", parent: 1, sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 90, ix: 10 }, p: { a: 0, k: [0, 0, 0], ix: 2, l: 2 }, a: { a: 0, k: [-.506, -4.557, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ ind: 0, ty: "sh", ix: 1, ks: { a: 0, k: { i: [[0, 0], [0, 0]], o: [[0, 0], [0, 0]], v: [[-514.937, -4.557], [513.924, -4.557]], c: !1 }, ix: 2 }, nm: "Path 1", mn: "ADBE Vector Shape - Group", hd: !1 }, { ty: "st", c: { a: 0, k: [1, 1, 1, 1], ix: 3 }, o: { a: 0, k: 100, ix: 4 }, w: { a: 0, k: 1, ix: 5 }, lc: 1, lj: 1, ml: 4, bm: 0, d: [{ n: "d", nm: "dash", v: { a: 0, k: 5, ix: 1 } }, { n: "o", nm: "offset", v: { a: 0, k: 0, ix: 7 } }], nm: "Stroke 1", mn: "ADBE Vector Graphic - Stroke", hd: !1 }, { ty: "fl", c: { a: 0, k: [1, 1, 1, 1], ix: 4 }, o: { a: 0, k: 100, ix: 5 }, r: 1, bm: 0, nm: "Fill 1", mn: "ADBE Vector Graphic - Fill", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [0, 0], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "Shape 1", np: 3, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }, { ty: "tm", s: { a: 1, k: [{ i: { x: [0], y: [1] }, o: { x: [.146], y: [.756] }, t: 0, s: [50] }, { i: { x: [.393], y: [1] }, o: { x: [.714], y: [0] }, t: 81, s: [75] }, { t: 114, s: [50] }], ix: 1 }, e: { a: 1, k: [{ i: { x: [0], y: [1] }, o: { x: [.146], y: [.756] }, t: 0, s: [50] }, { i: { x: [.393], y: [1] }, o: { x: [.714], y: [0] }, t: 81, s: [25] }, { t: 114, s: [50] }], ix: 2 }, o: { a: 0, k: 0, ix: 3 }, m: 1, ix: 2, nm: "Mid Trim In Path", mn: "ADBE Vector Filter - Trim", hd: !1 }], ip: 0, op: 136, st: 40, ct: 1, bm: 0 }, { ddd: 0, ind: 5, ty: 4, nm: "circle 19", parent: 1, sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { s: !0, x: { a: 0, k: 0, ix: 3 }, y: { a: 1, k: [{ i: { x: [0], y: [1] }, o: { x: [.17], y: [.793] }, t: 5, s: [0] }, { i: { x: [.393], y: [1] }, o: { x: [.714], y: [0] }, t: 81, s: [248] }, { t: 114, s: [0] }], ix: 4 } }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ d: 1, ty: "el", s: { a: 1, k: [{ i: { x: [0, 0], y: [1, 1] }, o: { x: [.146, .108], y: [.826, .839] }, t: 5, s: [0, 0] }, { i: { x: [.393, .393], y: [1, 1] }, o: { x: [.714, .714], y: [0, 0] }, t: 81, s: [714, 140] }, { t: 114, s: [0, 0] }], ix: 2 }, p: { a: 0, k: [0, 0], ix: 3 }, nm: "Ellipse Path 1", mn: "ADBE Vector Shape - Ellipse", hd: !1 }, { ty: "st", c: { a: 0, k: [1, 1, 1, 1], ix: 3 }, o: { a: 0, k: 100, ix: 4 }, w: { a: 0, k: 1, ix: 5 }, lc: 1, lj: 1, ml: 4, bm: 0, nm: "Stroke 1", mn: "ADBE Vector Graphic - Stroke", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [0, 0], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "Ellipse 1", np: 3, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 5, op: 136, st: 50, ct: 1, bm: 0 }, { ddd: 0, ind: 6, ty: 4, nm: "circle 20", parent: 1, sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { s: !0, x: { a: 0, k: 0, ix: 3 }, y: { a: 1, k: [{ i: { x: [0], y: [1] }, o: { x: [.17], y: [.793] }, t: 5, s: [0] }, { i: { x: [.393], y: [1] }, o: { x: [.714], y: [0] }, t: 81, s: [-246] }, { t: 114, s: [0] }], ix: 4 } }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ d: 1, ty: "el", s: { a: 1, k: [{ i: { x: [0, 0], y: [1, 1] }, o: { x: [.146, .108], y: [.826, .839] }, t: 5, s: [0, 0] }, { i: { x: [.393, .393], y: [1, 1] }, o: { x: [.714, .714], y: [0, 0] }, t: 81, s: [714, 140] }, { t: 114, s: [0, 0] }], ix: 2 }, p: { a: 0, k: [0, 0], ix: 3 }, nm: "Ellipse Path 1", mn: "ADBE Vector Shape - Ellipse", hd: !1 }, { ty: "st", c: { a: 0, k: [1, 1, 1, 1], ix: 3 }, o: { a: 0, k: 100, ix: 4 }, w: { a: 0, k: 1, ix: 5 }, lc: 1, lj: 1, ml: 4, bm: 0, nm: "Stroke 1", mn: "ADBE Vector Graphic - Stroke", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [0, 0], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "Ellipse 1", np: 3, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 5, op: 136, st: 50, ct: 1, bm: 0 }, { ddd: 0, ind: 7, ty: 4, nm: "fill circle 11", parent: 1, sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { a: 0, k: [0, 0, 0], ix: 2, l: 2 }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [140, 32, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ d: 1, ty: "el", s: { a: 1, k: [{ i: { x: [0, 0], y: [1, 1] }, o: { x: [.243, .243], y: [.297, .297] }, t: 37.266, s: [0, 0] }, { i: { x: [.5, .5], y: [1, 1] }, o: { x: [.791, .791], y: [0, 0] }, t: 81.24, s: [24, 24] }, { t: 90.189453125, s: [0, 0] }], ix: 2 }, p: { a: 0, k: [0, 0], ix: 3 }, nm: "Ellipse Path 1", mn: "ADBE Vector Shape - Ellipse", hd: !1 }, { ty: "fl", c: { a: 0, k: [1, 1, 1, 1], ix: 4 }, o: { a: 0, k: 100, ix: 5 }, r: 1, bm: 0, nm: "Fill 1", mn: "ADBE Vector Graphic - Fill", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [0, 0], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "Ellipse 1", np: 3, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 43, op: 169, st: 48, ct: 1, bm: 0 }, { ddd: 0, ind: 8, ty: 4, nm: "circle 21", parent: 1, sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { s: !0, x: { a: 0, k: 0, ix: 3 }, y: { a: 0, k: 0, ix: 4 } }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ d: 1, ty: "el", s: { a: 1, k: [{ i: { x: [0, 0], y: [1, 1] }, o: { x: [.243, .243], y: [.297, .297] }, t: 30.252, s: [0, 0] }, { i: { x: [0, 0], y: [1, 1] }, o: { x: [.759, .759], y: [0, 0] }, t: 74.225, s: [320, 40] }, { i: { x: [.5, .5], y: [1, 1] }, o: { x: [.791, .791], y: [0, 0] }, t: 81.24, s: [320, 40] }, { t: 95, s: [0, 0] }], ix: 2 }, p: { a: 0, k: [0, 0], ix: 3 }, nm: "Ellipse Path 1", mn: "ADBE Vector Shape - Ellipse", hd: !1 }, { ty: "st", c: { a: 0, k: [1, 1, 1, 1], ix: 3 }, o: { a: 0, k: 100, ix: 4 }, w: { a: 0, k: 1, ix: 5 }, lc: 1, lj: 1, ml: 4, bm: 0, nm: "Stroke 1", mn: "ADBE Vector Graphic - Stroke", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [0, 0], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "Ellipse 1", np: 3, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 34, op: 160, st: 74, ct: 1, bm: 0 }, { ddd: 0, ind: 9, ty: 4, nm: "circle 22", parent: 1, sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { s: !0, x: { a: 0, k: 0, ix: 3 }, y: { a: 0, k: 0, ix: 4 } }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ d: 1, ty: "el", s: { a: 1, k: [{ i: { x: [0, 0], y: [1, 1] }, o: { x: [.243, .243], y: [.297, .297] }, t: 24.016, s: [0, 0] }, { i: { x: [0, 0], y: [1, 1] }, o: { x: [.759, .759], y: [0, 0] }, t: 67.988, s: [480, 80] }, { i: { x: [.5, .5], y: [1, 1] }, o: { x: [.791, .791], y: [0, 0] }, t: 81.24, s: [480, 80] }, { t: 99, s: [0, 0] }], ix: 2 }, p: { a: 0, k: [0, 0], ix: 3 }, nm: "Ellipse Path 1", mn: "ADBE Vector Shape - Ellipse", hd: !1 }, { ty: "st", c: { a: 0, k: [1, 1, 1, 1], ix: 3 }, o: { a: 0, k: 100, ix: 4 }, w: { a: 0, k: 1, ix: 5 }, lc: 1, lj: 1, ml: 4, bm: 0, nm: "Stroke 1", mn: "ADBE Vector Graphic - Stroke", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [0, 0], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "Ellipse 1", np: 3, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 26, op: 152, st: 66, ct: 1, bm: 0 }, { ddd: 0, ind: 10, ty: 4, nm: "circle 15", parent: 1, sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { a: 0, k: [0, 0, 0], ix: 2, l: 2 }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ d: 1, ty: "el", s: { a: 1, k: [{ i: { x: [0, 0], y: [1, 1] }, o: { x: [.243, .243], y: [.297, .297] }, t: 17, s: [0, 0] }, { i: { x: [0, 0], y: [1, 1] }, o: { x: [.759, .759], y: [0, 0] }, t: 60.973, s: [680, 120] }, { i: { x: [.5, .5], y: [1, 1] }, o: { x: [.791, .791], y: [0, 0] }, t: 81.24, s: [680, 120] }, { t: 105, s: [0, 0] }], ix: 2 }, p: { a: 0, k: [0, 0], ix: 3 }, nm: "Ellipse Path 1", mn: "ADBE Vector Shape - Ellipse", hd: !1 }, { ty: "st", c: { a: 0, k: [1, 1, 1, 1], ix: 3 }, o: { a: 0, k: 100, ix: 4 }, w: { a: 0, k: 1, ix: 5 }, lc: 1, lj: 1, ml: 4, bm: 0, nm: "Stroke 1", mn: "ADBE Vector Graphic - Stroke", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [0, 0], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "Ellipse 1", np: 3, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 17, op: 143, st: 22, ct: 1, bm: 0 }, { ddd: 0, ind: 11, ty: 4, nm: "circle 17", parent: 1, sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { a: 0, k: [0, 0, 0], ix: 2, l: 2 }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ d: 1, ty: "el", s: { a: 1, k: [{ i: { x: [0, 0], y: [1, 1] }, o: { x: [.243, .243], y: [.242, .242] }, t: 9, s: [0, 0] }, { i: { x: [.667, .667], y: [1, 1] }, o: { x: [.333, .333], y: [0, 0] }, t: 55, s: [880, 174.667] }, { i: { x: [.5, .5], y: [1, 1] }, o: { x: [.873, .87], y: [0, 0] }, t: 81.24, s: [880, 174.667] }, { t: 111, s: [0, 0] }], ix: 2 }, p: { a: 0, k: [0, 0], ix: 3 }, nm: "Ellipse Path 1", mn: "ADBE Vector Shape - Ellipse", hd: !1 }, { ty: "st", c: { a: 0, k: [1, 1, 1, 1], ix: 3 }, o: { a: 0, k: 100, ix: 4 }, w: { a: 0, k: 1, ix: 5 }, lc: 1, lj: 1, ml: 4, bm: 0, nm: "Stroke 1", mn: "ADBE Vector Graphic - Stroke", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [0, 0], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "Ellipse 1", np: 3, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 9, op: 147, st: 54, ct: 1, bm: 0 }, { ddd: 0, ind: 12, ty: 4, nm: "circle 18", parent: 1, sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { s: !0, x: { a: 0, k: 0, ix: 3 }, y: { a: 0, k: 0, ix: 4 } }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ d: 1, ty: "el", s: { a: 1, k: [{ i: { x: [.001, .001], y: [1, 1] }, o: { x: [.242, .242], y: [.581, .581] }, t: 0, s: [0, 0] }, { i: { x: [.001, .001], y: [1, 1] }, o: { x: [.714, .714], y: [0, 0] }, t: 68, s: [880, 880] }, { i: { x: [.393, .393], y: [1, 1] }, o: { x: [.714, .714], y: [0, 0] }, t: 81, s: [880, 880] }, { t: 120, s: [0, 0] }], ix: 2 }, p: { a: 0, k: [0, 0], ix: 3 }, nm: "Ellipse Path 1", mn: "ADBE Vector Shape - Ellipse", hd: !1 }, { ty: "st", c: { a: 0, k: [1, 1, 1, 1], ix: 3 }, o: { a: 0, k: 100, ix: 4 }, w: { a: 0, k: 1, ix: 5 }, lc: 1, lj: 1, ml: 4, bm: 0, d: [{ n: "d", nm: "dash", v: { a: 0, k: 5, ix: 1 } }, { n: "o", nm: "offset", v: { a: 0, k: 0, ix: 7 } }], nm: "Stroke 1", mn: "ADBE Vector Graphic - Stroke", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [0, 0], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "Ellipse 1", np: 3, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 0, op: 140, st: 51, ct: 1, bm: 0 }] }, { id: "comp_2", nm: "C02", fr: 60, layers: [{ ddd: 0, ind: 1, ty: 3, nm: "Null 4", sr: 1, ks: { o: { a: 0, k: 0, ix: 11 }, r: { a: 1, k: [{ i: { x: [.255], y: [1] }, o: { x: [.128], y: [0] }, t: 0, s: [270] }, { i: { x: [.871], y: [1.003] }, o: { x: [.834], y: [0] }, t: 61, s: [0] }, { t: 119, s: [-180] }], ix: 10 }, p: { s: !0, x: { a: 0, k: 520, ix: 3 }, y: { a: 0, k: 520, ix: 4 } }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, ip: 0, op: 120, st: 0, bm: 0 }, { ddd: 0, ind: 2, ty: 4, nm: "circle 10", parent: 1, sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: -141, ix: 10 }, p: { s: !0, x: { a: 0, k: 199.333, ix: 3 }, y: { a: 0, k: 0, ix: 4 } }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ d: 1, ty: "el", s: { a: 1, k: [{ i: { x: [.255, .255], y: [1, 1] }, o: { x: [.128, .128], y: [0, 0] }, t: 0, s: [0, 0] }, { i: { x: [.667, .667], y: [1, 1] }, o: { x: [.834, .834], y: [.001, .001] }, t: 61, s: [640, 640] }, { i: { x: [.707, .707], y: [1, 1] }, o: { x: [.657, .657], y: [0, 0] }, t: 73, s: [640, 640] }, { t: 119, s: [0, 0] }], ix: 2 }, p: { a: 0, k: [0, 0], ix: 3 }, nm: "Ellipse Path 1", mn: "ADBE Vector Shape - Ellipse", hd: !1 }, { ty: "st", c: { a: 0, k: [1, 1, 1, 1], ix: 3 }, o: { a: 0, k: 100, ix: 4 }, w: { a: 0, k: 1, ix: 5 }, lc: 1, lj: 1, ml: 4, bm: 0, d: [{ n: "d", nm: "dash", v: { a: 0, k: 5, ix: 1 } }, { n: "o", nm: "offset", v: { a: 0, k: 0, ix: 7 } }], nm: "Stroke 1", mn: "ADBE Vector Graphic - Stroke", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [0, 0], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "Ellipse 1", np: 3, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }, { ty: "tm", s: { a: 0, k: 0, ix: 1 }, e: { a: 0, k: 100, ix: 2 }, o: { a: 0, k: 0, ix: 3 }, m: 1, ix: 2, nm: "Trim In Path", mn: "ADBE Vector Filter - Trim", hd: !1 }, { ty: "tm", s: { a: 0, k: 0, ix: 1 }, e: { a: 0, k: 100, ix: 2 }, o: { a: 0, k: 0, ix: 3 }, m: 1, ix: 3, nm: "Trim In Path", mn: "ADBE Vector Filter - Trim", hd: !1 }], ip: 0, op: 120, st: -60, ct: 1, bm: 0 }, { ddd: 0, ind: 3, ty: 4, nm: "circle 7", parent: 1, sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 39, ix: 10 }, p: { s: !0, x: { a: 0, k: -199.405, ix: 3 }, y: { a: 0, k: 0, ix: 4 } }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ d: 1, ty: "el", s: { a: 1, k: [{ i: { x: [.255, .255], y: [1, 1] }, o: { x: [.128, .128], y: [0, 0] }, t: 0, s: [0, 0] }, { i: { x: [.667, .667], y: [1, 1] }, o: { x: [.834, .834], y: [.001, .001] }, t: 61, s: [640, 640] }, { i: { x: [.707, .707], y: [1, 1] }, o: { x: [.657, .657], y: [0, 0] }, t: 73, s: [640, 640] }, { t: 119, s: [0, 0] }], ix: 2 }, p: { a: 0, k: [0, 0], ix: 3 }, nm: "Ellipse Path 1", mn: "ADBE Vector Shape - Ellipse", hd: !1 }, { ty: "st", c: { a: 0, k: [1, 1, 1, 1], ix: 3 }, o: { a: 0, k: 100, ix: 4 }, w: { a: 0, k: 1, ix: 5 }, lc: 1, lj: 1, ml: 4, bm: 0, d: [{ n: "d", nm: "dash", v: { a: 0, k: 5, ix: 1 } }, { n: "o", nm: "offset", v: { a: 0, k: 0, ix: 7 } }], nm: "Stroke 1", mn: "ADBE Vector Graphic - Stroke", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [0, 0], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "Ellipse 1", np: 3, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }, { ty: "tm", s: { a: 0, k: 0, ix: 1 }, e: { a: 0, k: 100, ix: 2 }, o: { a: 0, k: 0, ix: 3 }, m: 1, ix: 2, nm: "Trim In Path", mn: "ADBE Vector Filter - Trim", hd: !1 }], ip: 0, op: 120, st: 9, ct: 1, bm: 0 }, { ddd: 0, ind: 4, ty: 4, nm: "circle 9", sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { a: 0, k: [520, 520, 0], ix: 2, l: 2 }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ d: 1, ty: "el", s: { a: 1, k: [{ i: { x: [.13, .413], y: [1, 1] }, o: { x: [.406, .219], y: [.162, 0] }, t: 0, s: [0, 0] }, { i: { x: [.13, .413], y: [1, 1] }, o: { x: [.797, .797], y: [0, 0] }, t: 61, s: [1038.761, 148.923] }, { i: { x: [.649, .649], y: [1, 1] }, o: { x: [.797, .797], y: [0, 0] }, t: 73, s: [1038.761, 148.923] }, { t: 119, s: [0, 0] }], ix: 2 }, p: { a: 0, k: [0, 0], ix: 3 }, nm: "Ellipse Path 1", mn: "ADBE Vector Shape - Ellipse", hd: !1 }, { ty: "st", c: { a: 0, k: [1, 1, 1, 1], ix: 3 }, o: { a: 0, k: 100, ix: 4 }, w: { a: 0, k: 1, ix: 5 }, lc: 1, lj: 1, ml: 4, bm: 0, nm: "Stroke 1", mn: "ADBE Vector Graphic - Stroke", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [0, 0], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "Ellipse 1", np: 3, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 0, op: 120, st: -71, ct: 1, bm: 0 }, { ddd: 0, ind: 5, ty: 4, nm: "circle 8", sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { a: 0, k: [520, 520, 0], ix: 2, l: 2 }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ d: 1, ty: "el", s: { a: 1, k: [{ i: { x: [.13, .413], y: [1, 1] }, o: { x: [.406, .219], y: [.135, 0] }, t: 7, s: [0, 0] }, { i: { x: [.13, .413], y: [1, 1] }, o: { x: [.797, .797], y: [0, 0] }, t: 58, s: [680, 83.799] }, { i: { x: [.649, .649], y: [1, 1] }, o: { x: [.797, .797], y: [0, 0] }, t: 73, s: [680, 83.799] }, { t: 113, s: [0, 0] }], ix: 2 }, p: { a: 0, k: [0, 0], ix: 3 }, nm: "Ellipse Path 1", mn: "ADBE Vector Shape - Ellipse", hd: !1 }, { ty: "st", c: { a: 0, k: [1, 1, 1, 1], ix: 3 }, o: { a: 0, k: 100, ix: 4 }, w: { a: 0, k: 1, ix: 5 }, lc: 1, lj: 1, ml: 4, bm: 0, nm: "Stroke 1", mn: "ADBE Vector Graphic - Stroke", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [0, 0], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "Ellipse 1", np: 3, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 7, op: 120, st: -104, ct: 1, bm: 0 }, { ddd: 0, ind: 6, ty: 4, nm: "fill circle 6", sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { a: 0, k: [520, 520, 0], ix: 2, l: 2 }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [140, 32, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ d: 1, ty: "el", s: { a: 1, k: [{ i: { x: [.13, .413], y: [1, 1] }, o: { x: [.406, .219], y: [.109, 0] }, t: 15, s: [0, 0] }, { i: { x: [.13, .413], y: [1, 1] }, o: { x: [.797, .797], y: [0, 0] }, t: 56, s: [24, 24] }, { i: { x: [.649, .649], y: [1, 1] }, o: { x: [.797, .797], y: [0, 0] }, t: 73, s: [24, 24] }, { t: 108, s: [0, 0] }], ix: 2 }, p: { a: 0, k: [0, 0], ix: 3 }, nm: "Ellipse Path 1", mn: "ADBE Vector Shape - Ellipse", hd: !1 }, { ty: "fl", c: { a: 0, k: [1, 1, 1, 1], ix: 4 }, o: { a: 0, k: 100, ix: 5 }, r: 1, bm: 0, nm: "Fill 1", mn: "ADBE Vector Graphic - Fill", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [0, 0], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "Ellipse 1", np: 3, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 15, op: 120, st: -96, ct: 1, bm: 0 }] }, { id: "comp_3", nm: "C01", fr: 60, layers: [{ ddd: 0, ind: 1, ty: 4, nm: "dasshed line 2", sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 90, ix: 10 }, p: { a: 0, k: [520, 520, 0], ix: 2, l: 2 }, a: { a: 0, k: [-.506, -4.557, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ ind: 0, ty: "sh", ix: 1, ks: { a: 0, k: { i: [[0, 0], [0, 0]], o: [[0, 0], [0, 0]], v: [[-514.937, -4.557], [513.924, -4.557]], c: !1 }, ix: 2 }, nm: "Path 1", mn: "ADBE Vector Shape - Group", hd: !1 }, { ty: "st", c: { a: 0, k: [1, 1, 1, 1], ix: 3 }, o: { a: 0, k: 100, ix: 4 }, w: { a: 0, k: 1, ix: 5 }, lc: 1, lj: 1, ml: 4, bm: 0, d: [{ n: "d", nm: "dash", v: { a: 0, k: 5, ix: 1 } }, { n: "o", nm: "offset", v: { a: 0, k: 0, ix: 7 } }], nm: "Stroke 1", mn: "ADBE Vector Graphic - Stroke", hd: !1 }, { ty: "fl", c: { a: 0, k: [1, 1, 1, 1], ix: 4 }, o: { a: 0, k: 100, ix: 5 }, r: 1, bm: 0, nm: "Fill 1", mn: "ADBE Vector Graphic - Fill", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [0, 0], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "Shape 1", np: 3, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }, { ty: "tm", s: { a: 0, k: .444, ix: 1 }, e: { a: 0, k: 99.51, ix: 2 }, o: { a: 0, k: 0, ix: 3 }, m: 1, ix: 2, nm: "Mid Trim In Path", mn: "ADBE Vector Filter - Trim", hd: !1 }, { ty: "tm", s: { a: 1, k: [{ i: { x: [0], y: [1] }, o: { x: [.37], y: [.916] }, t: 1, s: [50] }, { i: { x: [0], y: [1] }, o: { x: [.588], y: [0] }, t: 67, s: [0] }, { t: 110, s: [50] }], ix: 1 }, e: { a: 1, k: [{ i: { x: [0], y: [1] }, o: { x: [.37], y: [.916] }, t: 1, s: [50] }, { i: { x: [0], y: [1] }, o: { x: [.588], y: [0] }, t: 67, s: [100] }, { t: 110, s: [50] }], ix: 2 }, o: { a: 0, k: 0, ix: 3 }, m: 1, ix: 3, nm: "Mid Trim In Path", mn: "ADBE Vector Filter - Trim", hd: !1 }], ip: 1, op: 112, st: 41, ct: 1, bm: 0 }, { ddd: 0, ind: 2, ty: 4, nm: "dasshed line", sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { a: 0, k: [520, 520, 0], ix: 2, l: 2 }, a: { a: 0, k: [-.506, -4.557, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ ind: 0, ty: "sh", ix: 1, ks: { a: 0, k: { i: [[0, 0], [0, 0]], o: [[0, 0], [0, 0]], v: [[-514.937, -4.557], [513.924, -4.557]], c: !1 }, ix: 2 }, nm: "Path 1", mn: "ADBE Vector Shape - Group", hd: !1 }, { ty: "st", c: { a: 0, k: [1, 1, 1, 1], ix: 3 }, o: { a: 0, k: 100, ix: 4 }, w: { a: 0, k: 1, ix: 5 }, lc: 1, lj: 1, ml: 4, bm: 0, d: [{ n: "d", nm: "dash", v: { a: 0, k: 5, ix: 1 } }, { n: "o", nm: "offset", v: { a: 0, k: 0, ix: 7 } }], nm: "Stroke 1", mn: "ADBE Vector Graphic - Stroke", hd: !1 }, { ty: "fl", c: { a: 0, k: [1, 1, 1, 1], ix: 4 }, o: { a: 0, k: 100, ix: 5 }, r: 1, bm: 0, nm: "Fill 1", mn: "ADBE Vector Graphic - Fill", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [0, 0], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "Shape 1", np: 3, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }, { ty: "tm", s: { a: 0, k: .21, ix: 1 }, e: { a: 0, k: 99.685, ix: 2 }, o: { a: 0, k: 0, ix: 3 }, m: 1, ix: 2, nm: "Mid Trim In Path", mn: "ADBE Vector Filter - Trim", hd: !1 }, { ty: "tm", s: { a: 1, k: [{ i: { x: [0], y: [1] }, o: { x: [.37], y: [.916] }, t: 1, s: [50] }, { i: { x: [0], y: [1] }, o: { x: [.588], y: [0] }, t: 67, s: [0] }, { t: 110, s: [50] }], ix: 1 }, e: { a: 1, k: [{ i: { x: [0], y: [1] }, o: { x: [.37], y: [.916] }, t: 1, s: [50] }, { i: { x: [0], y: [1] }, o: { x: [.588], y: [0] }, t: 67, s: [100] }, { t: 110, s: [50] }], ix: 2 }, o: { a: 0, k: 0, ix: 3 }, m: 1, ix: 3, nm: "Mid Trim In Path", mn: "ADBE Vector Filter - Trim", hd: !1 }], ip: 1, op: 112, st: 41, ct: 1, bm: 0 }, { ddd: 0, ind: 3, ty: 4, nm: "circle 3", sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { s: !0, x: { a: 1, k: [{ i: { x: [0], y: [.956] }, o: { x: [.239], y: [.249] }, t: 9, s: [520] }, { i: { x: [0], y: [-.812] }, o: { x: [1], y: [1.311] }, t: 50, s: [688.358] }, { i: { x: [.51], y: [.651] }, o: { x: [1], y: [-.023] }, t: 60, s: [688.358] }, { t: 89, s: [520] }], ix: 3 }, y: { a: 0, k: 520, ix: 4 } }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ d: 1, ty: "el", s: { a: 1, k: [{ i: { x: [0, 0], y: [1, 1] }, o: { x: [.364, .364], y: [.482, .482] }, t: 1, s: [0, 0] }, { i: { x: [.171, .171], y: [1, 1] }, o: { x: [.606, .606], y: [0, 0] }, t: 30, s: [340, 340] }, { i: { x: [.171, .171], y: [1, 1] }, o: { x: [.606, .606], y: [0, 0] }, t: 50, s: [340, 340] }, { i: { x: [.171, .171], y: [1, 1] }, o: { x: [.606, .606], y: [0, 0] }, t: 60, s: [340, 340] }, { i: { x: [.402, .402], y: [1, 1] }, o: { x: [.606, .606], y: [0, 0] }, t: 75, s: [340, 340] }, { t: 103, s: [0, 0] }], ix: 2 }, p: { a: 0, k: [0, 0], ix: 3 }, nm: "Ellipse Path 1", mn: "ADBE Vector Shape - Ellipse", hd: !1 }, { ty: "st", c: { a: 0, k: [1, 1, 1, 1], ix: 3 }, o: { a: 0, k: 100, ix: 4 }, w: { a: 0, k: 1, ix: 5 }, lc: 1, lj: 1, ml: 4, bm: 0, nm: "Stroke 1", mn: "ADBE Vector Graphic - Stroke", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [0, 0], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "Ellipse 1", np: 3, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 1, op: 112, st: 36, ct: 1, bm: 0 }, { ddd: 0, ind: 4, ty: 4, nm: "circle 4", sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { s: !0, x: { a: 1, k: [{ i: { x: [0], y: [.956] }, o: { x: [.239], y: [.249] }, t: 9, s: [520] }, { i: { x: [0], y: [2.812] }, o: { x: [1], y: [-1.311] }, t: 50, s: [351.642] }, { i: { x: [.51], y: [.651] }, o: { x: [1], y: [-.023] }, t: 60, s: [351.642] }, { t: 89, s: [520] }], ix: 3 }, y: { a: 0, k: 520, ix: 4 } }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ d: 1, ty: "el", s: { a: 1, k: [{ i: { x: [0, 0], y: [1, 1] }, o: { x: [.364, .364], y: [.482, .482] }, t: 1, s: [0, 0] }, { i: { x: [.171, .171], y: [1, 1] }, o: { x: [.606, .606], y: [0, 0] }, t: 30, s: [340, 340] }, { i: { x: [.171, .171], y: [1, 1] }, o: { x: [.606, .606], y: [0, 0] }, t: 50, s: [340, 340] }, { i: { x: [.171, .171], y: [1, 1] }, o: { x: [.606, .606], y: [0, 0] }, t: 60, s: [340, 340] }, { i: { x: [.402, .402], y: [1, 1] }, o: { x: [.606, .606], y: [0, 0] }, t: 75, s: [340, 340] }, { t: 103, s: [0, 0] }], ix: 2 }, p: { a: 0, k: [0, 0], ix: 3 }, nm: "Ellipse Path 1", mn: "ADBE Vector Shape - Ellipse", hd: !1 }, { ty: "st", c: { a: 0, k: [1, 1, 1, 1], ix: 3 }, o: { a: 0, k: 100, ix: 4 }, w: { a: 0, k: 1, ix: 5 }, lc: 1, lj: 1, ml: 4, bm: 0, nm: "Stroke 1", mn: "ADBE Vector Graphic - Stroke", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [0, 0], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "Ellipse 1", np: 3, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 1, op: 112, st: 36, ct: 1, bm: 0 }, { ddd: 0, ind: 5, ty: 4, nm: "circle 5", sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { s: !0, x: { a: 0, k: 520, ix: 3 }, y: { a: 1, k: [{ i: { x: [0], y: [.956] }, o: { x: [.239], y: [.249] }, t: 9, s: [520] }, { i: { x: [0], y: [2.812] }, o: { x: [1], y: [-1.311] }, t: 50, s: [351.642] }, { i: { x: [.51], y: [.651] }, o: { x: [1], y: [-.023] }, t: 60, s: [351.642] }, { t: 89, s: [520] }], ix: 4 } }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ d: 1, ty: "el", s: { a: 1, k: [{ i: { x: [0, 0], y: [1, 1] }, o: { x: [.364, .364], y: [.482, .482] }, t: 1, s: [0, 0] }, { i: { x: [.171, .171], y: [1, 1] }, o: { x: [.606, .606], y: [0, 0] }, t: 30, s: [340, 340] }, { i: { x: [.171, .171], y: [1, 1] }, o: { x: [.606, .606], y: [0, 0] }, t: 50, s: [340, 340] }, { i: { x: [.171, .171], y: [1, 1] }, o: { x: [.606, .606], y: [0, 0] }, t: 60, s: [340, 340] }, { i: { x: [.402, .402], y: [1, 1] }, o: { x: [.606, .606], y: [0, 0] }, t: 75, s: [340, 340] }, { t: 103, s: [0, 0] }], ix: 2 }, p: { a: 0, k: [0, 0], ix: 3 }, nm: "Ellipse Path 1", mn: "ADBE Vector Shape - Ellipse", hd: !1 }, { ty: "st", c: { a: 0, k: [1, 1, 1, 1], ix: 3 }, o: { a: 0, k: 100, ix: 4 }, w: { a: 0, k: 1, ix: 5 }, lc: 1, lj: 1, ml: 4, bm: 0, nm: "Stroke 1", mn: "ADBE Vector Graphic - Stroke", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [0, 0], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "Ellipse 1", np: 3, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 1, op: 112, st: 36, ct: 1, bm: 0 }, { ddd: 0, ind: 6, ty: 4, nm: "circle 2", sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { s: !0, x: { a: 0, k: 520, ix: 3 }, y: { a: 1, k: [{ i: { x: [0], y: [.956] }, o: { x: [.239], y: [.249] }, t: 9, s: [520] }, { i: { x: [0], y: [-.812] }, o: { x: [1], y: [1.311] }, t: 50, s: [688.358] }, { i: { x: [.51], y: [.651] }, o: { x: [1], y: [-.023] }, t: 60, s: [688.358] }, { t: 89, s: [520] }], ix: 4 } }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ d: 1, ty: "el", s: { a: 1, k: [{ i: { x: [0, 0], y: [1, 1] }, o: { x: [.364, .364], y: [.482, .482] }, t: 1, s: [0, 0] }, { i: { x: [.171, .171], y: [1, 1] }, o: { x: [.606, .606], y: [0, 0] }, t: 30, s: [340, 340] }, { i: { x: [.171, .171], y: [1, 1] }, o: { x: [.606, .606], y: [0, 0] }, t: 50, s: [340, 340] }, { i: { x: [.171, .171], y: [1, 1] }, o: { x: [.606, .606], y: [0, 0] }, t: 60, s: [340, 340] }, { i: { x: [.402, .402], y: [1, 1] }, o: { x: [.606, .606], y: [0, 0] }, t: 75, s: [340, 340] }, { t: 103, s: [0, 0] }], ix: 2 }, p: { a: 0, k: [0, 0], ix: 3 }, nm: "Ellipse Path 1", mn: "ADBE Vector Shape - Ellipse", hd: !1 }, { ty: "st", c: { a: 0, k: [1, 1, 1, 1], ix: 3 }, o: { a: 0, k: 100, ix: 4 }, w: { a: 0, k: 1, ix: 5 }, lc: 1, lj: 1, ml: 4, bm: 0, nm: "Stroke 1", mn: "ADBE Vector Graphic - Stroke", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [0, 0], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "Ellipse 1", np: 3, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 1, op: 112, st: 36, ct: 1, bm: 0 }, { ddd: 0, ind: 7, ty: 4, nm: "fill circle 5", sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { s: !0, x: { a: 0, k: 520, ix: 3 }, y: { a: 1, k: [{ i: { x: [0], y: [1] }, o: { x: [.37], y: [.931] }, t: 1, s: [520] }, { i: { x: [0], y: [1] }, o: { x: [.588], y: [0] }, t: 67, s: [1027.608] }, { t: 110, s: [520] }], ix: 4 } }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ d: 1, ty: "el", s: { a: 1, k: [{ i: { x: [.952, .952], y: [-.049, -.049] }, o: { x: [.333, .333], y: [0, 0] }, t: 91, s: [16, 16] }, { t: 110, s: [0, 0] }], ix: 2 }, p: { a: 0, k: [0, 0], ix: 3 }, nm: "Ellipse Path 1", mn: "ADBE Vector Shape - Ellipse", hd: !1 }, { ty: "fl", c: { a: 0, k: [1, 1, 1, 1], ix: 4 }, o: { a: 0, k: 100, ix: 5 }, r: 1, bm: 0, nm: "Fill 1", mn: "ADBE Vector Graphic - Fill", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [0, 0], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "Ellipse 1", np: 3, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 1, op: 112, st: 14, ct: 1, bm: 0 }, { ddd: 0, ind: 8, ty: 4, nm: "fill circle 4", sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { s: !0, x: { a: 0, k: 520, ix: 3 }, y: { a: 1, k: [{ i: { x: [0], y: [1] }, o: { x: [.37], y: [.931] }, t: 1, s: [520] }, { i: { x: [0], y: [1] }, o: { x: [.588], y: [0] }, t: 67, s: [10.251] }, { t: 110, s: [520] }], ix: 4 } }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ d: 1, ty: "el", s: { a: 1, k: [{ i: { x: [.952, .952], y: [-.049, -.049] }, o: { x: [.333, .333], y: [0, 0] }, t: 91, s: [16, 16] }, { t: 110, s: [0, 0] }], ix: 2 }, p: { a: 0, k: [0, 0], ix: 3 }, nm: "Ellipse Path 1", mn: "ADBE Vector Shape - Ellipse", hd: !1 }, { ty: "fl", c: { a: 0, k: [1, 1, 1, 1], ix: 4 }, o: { a: 0, k: 100, ix: 5 }, r: 1, bm: 0, nm: "Fill 1", mn: "ADBE Vector Graphic - Fill", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [0, 0], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "Ellipse 1", np: 3, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 1, op: 112, st: 14, ct: 1, bm: 0 }, { ddd: 0, ind: 9, ty: 4, nm: "fill circle 3", sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { s: !0, x: { a: 1, k: [{ i: { x: [0], y: [1] }, o: { x: [.37], y: [.931] }, t: 1, s: [520] }, { i: { x: [0], y: [1] }, o: { x: [.588], y: [0] }, t: 67, s: [10.51] }, { t: 110, s: [520] }], ix: 3 }, y: { a: 0, k: 520, ix: 4 } }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ d: 1, ty: "el", s: { a: 1, k: [{ i: { x: [.952, .952], y: [-.049, -.049] }, o: { x: [.333, .333], y: [0, 0] }, t: 91, s: [16, 16] }, { t: 110, s: [0, 0] }], ix: 2 }, p: { a: 0, k: [0, 0], ix: 3 }, nm: "Ellipse Path 1", mn: "ADBE Vector Shape - Ellipse", hd: !1 }, { ty: "fl", c: { a: 0, k: [1, 1, 1, 1], ix: 4 }, o: { a: 0, k: 100, ix: 5 }, r: 1, bm: 0, nm: "Fill 1", mn: "ADBE Vector Graphic - Fill", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [0, 0], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "Ellipse 1", np: 3, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 1, op: 112, st: 14, ct: 1, bm: 0 }, { ddd: 0, ind: 10, ty: 4, nm: "fill circle 2", sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { s: !0, x: { a: 1, k: [{ i: { x: [0], y: [1] }, o: { x: [.37], y: [.931] }, t: 1, s: [520] }, { i: { x: [0], y: [1] }, o: { x: [.588], y: [0] }, t: 67, s: [1029.371] }, { t: 110, s: [520] }], ix: 3 }, y: { a: 0, k: 520, ix: 4 } }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ d: 1, ty: "el", s: { a: 1, k: [{ i: { x: [.952, .952], y: [-.049, -.049] }, o: { x: [.333, .333], y: [0, 0] }, t: 91, s: [16, 16] }, { t: 110, s: [0, 0] }], ix: 2 }, p: { a: 0, k: [0, 0], ix: 3 }, nm: "Ellipse Path 1", mn: "ADBE Vector Shape - Ellipse", hd: !1 }, { ty: "fl", c: { a: 0, k: [1, 1, 1, 1], ix: 4 }, o: { a: 0, k: 100, ix: 5 }, r: 1, bm: 0, nm: "Fill 1", mn: "ADBE Vector Graphic - Fill", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [0, 0], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "Ellipse 1", np: 3, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 1, op: 112, st: 14, ct: 1, bm: 0 }, { ddd: 0, ind: 11, ty: 4, nm: "fill circle", sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { a: 0, k: [520, 520, 0], ix: 2, l: 2 }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ d: 1, ty: "el", s: { a: 1, k: [{ i: { x: [0, 0], y: [1, 1] }, o: { x: [.014, .014], y: [.919, .919] }, t: 0, s: [0, 0] }, { i: { x: [.667, .667], y: [1, 1] }, o: { x: [.167, .167], y: [0, 0] }, t: 67, s: [24, 24] }, { i: { x: [.952, .952], y: [.393, .393] }, o: { x: [.333, .333], y: [0, 0] }, t: 91, s: [24, 24] }, { t: 102, s: [0, 0] }], ix: 2 }, p: { a: 0, k: [0, 0], ix: 3 }, nm: "Ellipse Path 1", mn: "ADBE Vector Shape - Ellipse", hd: !1 }, { ty: "fl", c: { a: 0, k: [1, 1, 1, 1], ix: 4 }, o: { a: 0, k: 100, ix: 5 }, r: 1, bm: 0, nm: "Fill 1", mn: "ADBE Vector Graphic - Fill", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [0, 0], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "Ellipse 1", np: 3, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 0, op: 111, st: 0, ct: 1, bm: 0 }, { ddd: 0, ind: 12, ty: 4, nm: "circle 6", sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { s: !0, x: { a: 0, k: 520, ix: 3 }, y: { a: 0, k: 520, ix: 4 } }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ d: 1, ty: "el", s: { a: 1, k: [{ i: { x: [.042, .042], y: [.934, .934] }, o: { x: [.37, .37], y: [.742, .742] }, t: 1, s: [0, 0] }, { i: { x: [.667, .667], y: [1, 1] }, o: { x: [.698, .698], y: [-.012, -.012] }, t: 67, s: [455.842, 455.842] }, { t: 96, s: [0, 0] }], ix: 2 }, p: { a: 0, k: [0, 0], ix: 3 }, nm: "Ellipse Path 1", mn: "ADBE Vector Shape - Ellipse", hd: !1 }, { ty: "st", c: { a: 0, k: [1, 1, 1, 1], ix: 3 }, o: { a: 0, k: 100, ix: 4 }, w: { a: 0, k: 1, ix: 5 }, lc: 1, lj: 1, ml: 4, bm: 0, d: [{ n: "d", nm: "dash", v: { a: 0, k: 5, ix: 1 } }, { n: "o", nm: "offset", v: { a: 0, k: 0, ix: 7 } }], nm: "Stroke 1", mn: "ADBE Vector Graphic - Stroke", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [0, 0], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "Ellipse 1", np: 3, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 0, op: 111, st: 51, ct: 1, bm: 0 }, { ddd: 0, ind: 13, ty: 4, nm: "circle", sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { a: 0, k: [520, 520, 0], ix: 2, l: 2 }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ d: 1, ty: "el", s: { a: 1, k: [{ i: { x: [.171, .171], y: [1, 1] }, o: { x: [.085, .085], y: [.972, .972] }, t: 0, s: [0, 0] }, { i: { x: [.402, .402], y: [1, 1] }, o: { x: [.606, .606], y: [0, 0] }, t: 67, s: [673.914, 673.914] }, { t: 110, s: [0, 0] }], ix: 2 }, p: { a: 0, k: [0, 0], ix: 3 }, nm: "Ellipse Path 1", mn: "ADBE Vector Shape - Ellipse", hd: !1 }, { ty: "st", c: { a: 0, k: [1, 1, 1, 1], ix: 3 }, o: { a: 0, k: 100, ix: 4 }, w: { a: 0, k: 1, ix: 5 }, lc: 1, lj: 1, ml: 4, bm: 0, nm: "Stroke 1", mn: "ADBE Vector Graphic - Stroke", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [0, 0], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "Ellipse 1", np: 3, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 0, op: 111, st: 40, ct: 1, bm: 0 }] }], layers$1 = [{ ddd: 0, ind: 1, ty: 0, nm: "Innter", refId: "comp_0", sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { s: !0, x: { a: 0, k: 520, ix: 3 }, y: { a: 0, k: 519, ix: 4 } }, a: { a: 0, k: [520, 520, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, tm: { a: 1, k: [{ i: { x: [.833], y: [.833] }, o: { x: [.167], y: [.167] }, t: 0, s: [0] }, { i: { x: [.833], y: [.833] }, o: { x: [.167], y: [.167] }, t: 333, s: [5] }, { t: 393, s: [6.117] }], ix: 2 }, w: 1040, h: 1040, ip: 0, op: 600, st: 0, bm: 0 }], markers$1 = [], props$1 = {}, serviceData = { v: v$1, fr: fr$1, ip: ip$1, op: op$1, w: w$2, h: h$2, nm: nm$1, ddd: ddd$1, assets: assets$1, layers: layers$1, markers: markers$1, props: props$1 }, v = "5.12.1", fr = 60, ip = 0, op = 300, w$1 = 1616, h$1 = 200, nm = "Pre-comp 1", ddd = 0, assets = [{ id: "comp_0", nm: "Pre-comp 2", fr: 60, layers: [{ ddd: 0, ind: 1, ty: 4, nm: "h Outline 2", sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { s: !0, x: { a: 0, k: 1452.616, ix: 3 }, y: { a: 1, k: [{ i: { x: [.325], y: [1] }, o: { x: [.221], y: [.943] }, t: 131.983, s: [302] }, { t: 195.80322705518, s: [100.239] }], ix: 4 } }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ ind: 0, ty: "sh", ix: 1, ks: { a: 0, k: { i: [[28.849, 0], [8.314, -14.613], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [-21.29, 0], [0, -28.723], [0, 0], [0, 0], [0, 0]], o: [[-17.889, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [.252, -26.203], [21.29, 0], [0, 0], [0, 0], [0, 0], [0, -36.533]], v: [[829.062, -137.993], [788.75, -115.192], [788.75, -195.565], [773.129, -195.565], [773.129, -2.065], [788.75, -2.065], [788.75, -81.682], [827.173, -122.75], [865.721, -80.548], [865.721, -2.065], [881.091, -2.065], [881.091, -81.682]], c: !0 }, ix: 2 }, nm: "h", mn: "ADBE Vector Shape - Group", hd: !1 }, { ty: "fl", c: { a: 0, k: [1, 1, 1, 1], ix: 4 }, o: { a: 0, k: 100, ix: 5 }, r: 1, bm: 0, nm: "Fill 1", mn: "ADBE Vector Graphic - Fill", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [827.11, -98.815], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "h", np: 3, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 127, op: 608.604604604605, st: 184.18018018018, ct: 1, bm: 0 }, { ddd: 0, ind: 2, ty: 4, nm: "c Outline 2", sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { s: !0, x: { a: 0, k: 1299.278, ix: 3 }, y: { a: 1, k: [{ i: { x: [.325], y: [1] }, o: { x: [.221], y: [.943] }, t: 121.008, s: [331.919] }, { t: 188.832426176176, s: [129.999] }], ix: 4 } }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ ind: 0, ty: "sh", ix: 1, ks: { a: 0, k: { i: [[-38.549, 0], [-12.598, 17.511], [0, 0], [18.393, 0], [0, 29.73], [-29.856, 0], [-9.574, -13.857], [0, 0], [23.432, 0], [0, -38.423]], o: [[23.432, 0], [0, 0], [-9.574, 13.857], [-29.856, 0], [0, -29.73], [18.393, 0], [0, 0], [-12.598, -17.511], [-38.549, 0], [0, 38.297]], v: [[685.197, .203], [741.886, -28.646], [728.533, -38.472], [685.197, -15.796], [632.035, -68.832], [685.197, -121.994], [728.533, -99.319], [741.886, -109.145], [685.197, -137.993], [615.658, -68.832]], c: !0 }, ix: 2 }, nm: "c", mn: "ADBE Vector Shape - Group", hd: !1 }, { ty: "fl", c: { a: 0, k: [1, 1, 1, 1], ix: 4 }, o: { a: 0, k: 100, ix: 5 }, r: 1, bm: 0, nm: "Fill 1", mn: "ADBE Vector Graphic - Fill", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [678.772, -68.895], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "c", np: 3, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 119, op: 604.604604604605, st: 176.176176176176, ct: 1, bm: 0 }, { ddd: 0, ind: 3, ty: 4, nm: "u Outline 2", sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { s: !0, x: { a: 0, k: 1155.34, ix: 3 }, y: { a: 1, k: [{ i: { x: [.325], y: [1] }, o: { x: [.221], y: [.943] }, t: 113, s: [333.305] }, { t: 186.838090043168, s: [131.305] }], ix: 4 } }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ ind: 0, ty: "sh", ix: 1, ks: { a: 0, k: { i: [[-30.36, 0], [0, 29.73], [0, 0], [0, 0], [0, 0], [20.66, 0], [0, 21.164], [0, 0], [0, 0], [0, 0]], o: [[30.486, 0], [0, 0], [0, 0], [0, 0], [0, 21.164], [-20.408, 0], [0, 0], [0, 0], [0, 0], [0, 29.856]], v: [[444.834, .455], [497.114, -46.408], [497.114, -135.474], [481.115, -135.474], [481.115, -46.786], [444.834, -15.418], [408.552, -46.786], [408.552, -135.474], [392.553, -135.474], [392.553, -46.408]], c: !0 }, ix: 2 }, nm: "u", mn: "ADBE Vector Shape - Group", hd: !1 }, { ty: "fl", c: { a: 0, k: [1, 1, 1, 1], ix: 4 }, o: { a: 0, k: 100, ix: 5 }, r: 1, bm: 0, nm: "Fill 1", mn: "ADBE Vector Graphic - Fill", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [444.834, -67.509], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "u", np: 3, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 111, op: 604.604604604605, st: 168.168168168168, ct: 1, bm: 0 }, { ddd: 0, ind: 4, ty: 4, nm: "o Outline 2", sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { s: !0, x: { a: 0, k: 1001.774, ix: 3 }, y: { a: 1, k: [{ i: { x: [.325], y: [1] }, o: { x: [.221], y: [.943] }, t: 108.996, s: [332.045] }, { t: 180.832132914164, s: [130.045] }], ix: 4 } }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ ind: 0, ty: "sh", ix: 1, ks: { a: 0, k: { i: [[-38.549, 0], [0, 38.297], [38.549, 0], [0, -38.297]], o: [[38.549, 0], [0, -38.171], [-38.549, 0], [0, 38.297]], v: [[291.268, .455], [360.807, -68.832], [291.268, -137.993], [221.729, -68.832]], c: !0 }, ix: 2 }, nm: "o", mn: "ADBE Vector Shape - Group", hd: !1 }, { ind: 1, ty: "sh", ix: 2, ks: { a: 0, k: { i: [[29.353, 0], [0, 29.604], [-29.479, 0], [0, -29.353]], o: [[-29.604, 0], [0, -29.353], [29.353, 0], [0, 29.479]], v: [[291.268, -15.418], [238.106, -68.832], [291.268, -121.994], [344.43, -68.832]], c: !0 }, ix: 2 }, nm: "o", mn: "ADBE Vector Shape - Group", hd: !1 }, { ty: "mm", mm: 1, nm: "Merge Paths 1", mn: "ADBE Vector Filter - Merge", hd: !1 }, { ty: "fl", c: { a: 0, k: [1, 1, 1, 1], ix: 4 }, o: { a: 0, k: 100, ix: 5 }, r: 1, bm: 0, nm: "Fill 1", mn: "ADBE Vector Graphic - Fill", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [291.268, -68.769], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "o", np: 5, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 107, op: 604.604604604605, st: 164.164164164164, ct: 1, bm: 0 }, { ddd: 0, ind: 5, ty: 4, nm: "T Outline 3", sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { s: !0, x: { a: 0, k: 873.845, ix: 3 }, y: { a: 1, k: [{ i: { x: [.325], y: [1] }, o: { x: [.221], y: [.943] }, t: 108.996, s: [301.937] }, { t: 180.832132914164, s: [99.937] }], ix: 4 } }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ ind: 0, ty: "sh", ix: 1, ks: { a: 0, k: { i: [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]], o: [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]], v: [[226.264, -195.691], [100.414, -195.691], [100.414, -178.81], [154.458, -178.81], [154.458, -2.065], [172.22, -2.065], [172.22, -178.81], [226.264, -178.81]], c: !0 }, ix: 2 }, nm: "T", mn: "ADBE Vector Shape - Group", hd: !1 }, { ty: "fl", c: { a: 0, k: [1, 1, 1, 1], ix: 4 }, o: { a: 0, k: 100, ix: 5 }, r: 1, bm: 0, nm: "Fill 1", mn: "ADBE Vector Graphic - Fill", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [163.339, -98.878], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "T", np: 3, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 107, op: 604.604604604605, st: 164.164164164164, ct: 1, bm: 0 }, { ddd: 0, ind: 6, ty: 3, nm: "Null 1", sr: 1, ks: { o: { a: 0, k: 0, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { s: !0, x: { a: 0, k: 699.213, ix: 3 }, y: { a: 1, k: [{ i: { x: [.474], y: [1] }, o: { x: [.466], y: [0] }, t: 108.017, s: [100] }, { t: 158.99536255005, s: [-104] }], ix: 4 } }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, ip: 50.05005005005, op: 604.604604604605, st: 50.05005005005, bm: 0 }, { ddd: 0, ind: 7, ty: 3, nm: "Null 1", sr: 1, ks: { o: { a: 0, k: 0, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { s: !0, x: { a: 0, k: 699.213, ix: 3 }, y: { a: 1, k: [{ i: { x: [.474], y: [1] }, o: { x: [.466], y: [0] }, t: 104.013, s: [100] }, { t: 154.991163038038, s: [-104] }], ix: 4 } }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, ip: 38.038038038038, op: 604.604604604605, st: 38.038038038038, bm: 0 }, { ddd: 0, ind: 8, ty: 3, nm: "Null 1", sr: 1, ks: { o: { a: 0, k: 0, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { s: !0, x: { a: 0, k: 784.213, ix: 3 }, y: { a: 1, k: [{ i: { x: [.474], y: [1] }, o: { x: [.466], y: [0] }, t: 100.009, s: [100] }, { t: 150.987110157032, s: [-104] }], ix: 4 } }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, ip: 32.032032032032, op: 604.604604604605, st: 32.032032032032, bm: 0 }, { ddd: 0, ind: 9, ty: 3, nm: "Null 1", sr: 1, ks: { o: { a: 0, k: 0, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { s: !0, x: { a: 0, k: 784.213, ix: 3 }, y: { a: 1, k: [{ i: { x: [.474], y: [1] }, o: { x: [.466], y: [0] }, t: 96.005, s: [100] }, { t: 146.983106153028, s: [-104] }], ix: 4 } }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, ip: 28.028028028028, op: 604.604604604605, st: 28.028028028028, bm: 0 }, { ddd: 0, ind: 10, ty: 3, nm: "Null 1", sr: 1, ks: { o: { a: 0, k: 0, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { s: !0, x: { a: 0, k: 784.213, ix: 3 }, y: { a: 1, k: [{ i: { x: [.474], y: [1] }, o: { x: [.466], y: [0] }, t: 92.001, s: [100] }, { t: 142.979102149024, s: [-104] }], ix: 4 } }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, ip: 24.024024024024, op: 604.604604604605, st: 24.024024024024, bm: 0 }, { ddd: 0, ind: 11, ty: 3, nm: "Null 1", sr: 1, ks: { o: { a: 0, k: 0, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { s: !0, x: { a: 0, k: 784.213, ix: 3 }, y: { a: 1, k: [{ i: { x: [.474], y: [1] }, o: { x: [.466], y: [0] }, t: 88.001, s: [100] }, { t: 138.979102149024, s: [-104] }], ix: 4 } }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, ip: 20.024024024024, op: 600.604604604605, st: 20.024024024024, bm: 0 }, { ddd: 0, ind: 12, ty: 4, nm: "h Outline", parent: 6, sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { s: !0, x: { a: 0, k: 753.403, ix: 3 }, y: { a: 1, k: [{ i: { x: [.188], y: [1] }, o: { x: [.007], y: [.616] }, t: 49.999, s: [212] }, { t: 114.11450317505, s: [0] }], ix: 4 } }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ ind: 0, ty: "sh", ix: 1, ks: { a: 0, k: { i: [[28.849, 0], [8.314, -14.613], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [-21.29, 0], [0, -28.723], [0, 0], [0, 0], [0, 0]], o: [[-17.889, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [.252, -26.203], [21.29, 0], [0, 0], [0, 0], [0, 0], [0, -36.533]], v: [[829.062, -137.993], [788.75, -115.192], [788.75, -195.565], [773.129, -195.565], [773.129, -2.065], [788.75, -2.065], [788.75, -81.682], [827.173, -122.75], [865.721, -80.548], [865.721, -2.065], [881.091, -2.065], [881.091, -81.682]], c: !0 }, ix: 2 }, nm: "h", mn: "ADBE Vector Shape - Group", hd: !1 }, { ty: "fl", c: { a: 0, k: [1, 1, 1, 1], ix: 4 }, o: { a: 0, k: 100, ix: 5 }, r: 1, bm: 0, nm: "Fill 1", mn: "ADBE Vector Graphic - Fill", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [827.11, -98.815], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "h", np: 3, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 50.05005005005, op: 604.604604604605, st: 50.05005005005, ct: 1, bm: 0 }, { ddd: 0, ind: 13, ty: 4, nm: "c Outline", parent: 7, sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { s: !0, x: { a: 0, k: 605.065, ix: 3 }, y: { a: 1, k: [{ i: { x: [.188], y: [1] }, o: { x: [.014], y: [.826] }, t: 38.001, s: [241.919] }, { t: 96.096631788038, s: [29.919] }], ix: 4 } }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ ind: 0, ty: "sh", ix: 1, ks: { a: 0, k: { i: [[-38.549, 0], [-12.598, 17.511], [0, 0], [18.393, 0], [0, 29.73], [-29.856, 0], [-9.574, -13.857], [0, 0], [23.432, 0], [0, -38.423]], o: [[23.432, 0], [0, 0], [-9.574, 13.857], [-29.856, 0], [0, -29.73], [18.393, 0], [0, 0], [-12.598, -17.511], [-38.549, 0], [0, 38.297]], v: [[685.197, .203], [741.886, -28.646], [728.533, -38.472], [685.197, -15.796], [632.035, -68.832], [685.197, -121.994], [728.533, -99.319], [741.886, -109.145], [685.197, -137.993], [615.658, -68.832]], c: !0 }, ix: 2 }, nm: "c", mn: "ADBE Vector Shape - Group", hd: !1 }, { ty: "fl", c: { a: 0, k: [1, 1, 1, 1], ix: 4 }, o: { a: 0, k: 100, ix: 5 }, r: 1, bm: 0, nm: "Fill 1", mn: "ADBE Vector Graphic - Fill", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [678.772, -68.895], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "c", np: 3, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 38.038038038038, op: 604.604604604605, st: 38.038038038038, ct: 1, bm: 0 }, { ddd: 0, ind: 14, ty: 4, nm: "u Outline", parent: 9, sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { s: !0, x: { a: 0, k: 371.127, ix: 3 }, y: { a: 1, k: [{ i: { x: [.188], y: [1] }, o: { x: [.014], y: [.826] }, t: 28.001, s: [243.305] }, { t: 86.086621778028, s: [31.305] }], ix: 4 } }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ ind: 0, ty: "sh", ix: 1, ks: { a: 0, k: { i: [[-30.36, 0], [0, 29.73], [0, 0], [0, 0], [0, 0], [20.66, 0], [0, 21.164], [0, 0], [0, 0], [0, 0]], o: [[30.486, 0], [0, 0], [0, 0], [0, 0], [0, 21.164], [-20.408, 0], [0, 0], [0, 0], [0, 0], [0, 29.856]], v: [[444.834, .455], [497.114, -46.408], [497.114, -135.474], [481.115, -135.474], [481.115, -46.786], [444.834, -15.418], [408.552, -46.786], [408.552, -135.474], [392.553, -135.474], [392.553, -46.408]], c: !0 }, ix: 2 }, nm: "u", mn: "ADBE Vector Shape - Group", hd: !1 }, { ty: "fl", c: { a: 0, k: [1, 1, 1, 1], ix: 4 }, o: { a: 0, k: 100, ix: 5 }, r: 1, bm: 0, nm: "Fill 1", mn: "ADBE Vector Graphic - Fill", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [444.834, -67.509], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "u", np: 3, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 28.028028028028, op: 604.604604604605, st: 28.028028028028, ct: 1, bm: 0 }, { ddd: 0, ind: 15, ty: 4, nm: "o Outline", parent: 10, sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { s: !0, x: { a: 0, k: 217.562, ix: 3 }, y: { a: 1, k: [{ i: { x: [.188], y: [1] }, o: { x: [.014], y: [.826] }, t: 24.001, s: [242.045] }, { t: 82.082617774024, s: [30.045] }], ix: 4 } }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ ind: 0, ty: "sh", ix: 1, ks: { a: 0, k: { i: [[-38.549, 0], [0, 38.297], [38.549, 0], [0, -38.297]], o: [[38.549, 0], [0, -38.171], [-38.549, 0], [0, 38.297]], v: [[291.268, .455], [360.807, -68.832], [291.268, -137.993], [221.729, -68.832]], c: !0 }, ix: 2 }, nm: "o", mn: "ADBE Vector Shape - Group", hd: !1 }, { ind: 1, ty: "sh", ix: 2, ks: { a: 0, k: { i: [[29.353, 0], [0, 29.604], [-29.479, 0], [0, -29.353]], o: [[-29.604, 0], [0, -29.353], [29.353, 0], [0, 29.479]], v: [[291.268, -15.418], [238.106, -68.832], [291.268, -121.994], [344.43, -68.832]], c: !0 }, ix: 2 }, nm: "o", mn: "ADBE Vector Shape - Group", hd: !1 }, { ty: "mm", mm: 1, nm: "Merge Paths 1", mn: "ADBE Vector Filter - Merge", hd: !1 }, { ty: "fl", c: { a: 0, k: [1, 1, 1, 1], ix: 4 }, o: { a: 0, k: 100, ix: 5 }, r: 1, bm: 0, nm: "Fill 1", mn: "ADBE Vector Graphic - Fill", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [291.268, -68.769], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "o", np: 5, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 24.024024024024, op: 604.604604604605, st: 24.024024024024, ct: 1, bm: 0 }, { ddd: 0, ind: 16, ty: 4, nm: "T Outline", parent: 11, sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { s: !0, x: { a: 0, k: 89.632, ix: 3 }, y: { a: 1, k: [{ i: { x: [.188], y: [1] }, o: { x: [.014], y: [.826] }, t: 20, s: [211.937] }, { t: 78.07861377002, s: [-.063] }], ix: 4 } }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ ind: 0, ty: "sh", ix: 1, ks: { a: 0, k: { i: [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]], o: [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0]], v: [[226.264, -195.691], [100.414, -195.691], [100.414, -178.81], [154.458, -178.81], [154.458, -2.065], [172.22, -2.065], [172.22, -178.81], [226.264, -178.81]], c: !0 }, ix: 2 }, nm: "T", mn: "ADBE Vector Shape - Group", hd: !1 }, { ty: "fl", c: { a: 0, k: [1, 1, 1, 1], ix: 4 }, o: { a: 0, k: 100, ix: 5 }, r: 1, bm: 0, nm: "Fill 1", mn: "ADBE Vector Graphic - Fill", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [163.339, -98.878], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "T", np: 3, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 20.02002002002, op: 604.604604604605, st: 20.02002002002, ct: 1, bm: 0 }, { ddd: 0, ind: 17, ty: 4, nm: "n Outline", sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { s: !0, x: { a: 0, k: 699.425, ix: 3 }, y: { a: 1, k: [{ i: { x: [.188], y: [1] }, o: { x: [.014], y: [.826] }, t: 16, s: [340.786] }, { t: 74.074609766016, s: [128.786] }], ix: 4 } }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ ind: 0, ty: "sh", ix: 1, ks: { a: 0, k: { i: [[28.849, 0], [8.314, -14.739], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [-21.29, 0], [0, -28.723], [0, 0], [0, 0], [0, 0]], o: [[-17.763, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [.252, -26.203], [21.29, 0], [0, 0], [0, 0], [0, 0], [0, -36.533]], v: [[-55.167, -137.993], [-95.48, -115.066], [-95.48, -135.474], [-111.857, -135.474], [-111.857, -2.065], [-95.48, -2.065], [-95.48, -81.682], [-57.057, -122.75], [-19.39, -80.548], [-19.39, -2.065], [-3.013, -2.065], [-3.013, -81.682]], c: !0 }, ix: 2 }, nm: "n", mn: "ADBE Vector Shape - Group", hd: !1 }, { ty: "fl", c: { a: 0, k: [1, 1, 1, 1], ix: 4 }, o: { a: 0, k: 100, ix: 5 }, r: 1, bm: 0, nm: "Fill 1", mn: "ADBE Vector Graphic - Fill", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [-57.435, -70.029], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "n", np: 3, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 16.016016016016, op: 604.604604604605, st: 16.016016016016, ct: 1, bm: 0 }, { ddd: 0, ind: 18, ty: 4, nm: "i Outline", sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { s: !0, x: { a: 0, k: 590.455, ix: 3 }, y: { a: 1, k: [{ i: { x: [.188], y: [1] }, o: { x: [.014], y: [.826] }, t: 12, s: [310.74] }, { t: 70.070605762012, s: [98.74] }], ix: 4 } }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ ind: 0, ty: "sh", ix: 1, ks: { a: 0, k: { i: [[-6.803, 0], [0, 6.929], [6.803, 0], [0, -7.181]], o: [[6.803, 0], [0, -7.181], [-6.803, 0], [0, 6.929]], v: [[-166.405, -172.763], [-153.681, -185.361], [-166.405, -198.084], [-179.128, -185.361]], c: !0 }, ix: 2 }, nm: "i", mn: "ADBE Vector Shape - Group", hd: !1 }, { ind: 1, ty: "sh", ix: 2, ks: { a: 0, k: { i: [[0, 0], [0, 0], [0, 0], [0, 0]], o: [[0, 0], [0, 0], [0, 0], [0, 0]], v: [[-174.593, -2.065], [-158.216, -2.065], [-158.216, -135.474], [-174.593, -135.474]], c: !0 }, ix: 2 }, nm: "i", mn: "ADBE Vector Shape - Group", hd: !1 }, { ty: "mm", mm: 1, nm: "Merge Paths 1", mn: "ADBE Vector Filter - Merge", hd: !1 }, { ty: "fl", c: { a: 0, k: [1, 1, 1, 1], ix: 4 }, o: { a: 0, k: 100, ix: 5 }, r: 1, bm: 0, nm: "Fill 1", mn: "ADBE Vector Graphic - Fill", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [-166.405, -100.074], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "i", np: 5, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 12.012012012012, op: 604.604604604605, st: 12.012012012012, ct: 1, bm: 0 }, { ddd: 0, ind: 19, ty: 4, nm: "t Outline", sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { s: !0, x: { a: 0, k: 437.205, ix: 3 }, y: { a: 1, k: [{ i: { x: [.188], y: [1] }, o: { x: [.014], y: [.826] }, t: 8, s: [323.59] }, { t: 66.066601758008, s: [111.59] }], ix: 4 } }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ ind: 0, ty: "sh", ix: 1, ks: { a: 0, k: { i: [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [-21.038, 0], [0, 0], [0, 0], [0, 0], [0, 13.857], [0, 0]], o: [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 0], [0, 22.298], [0, 0], [0, 0], [0, 0], [-12.598, 0], [0, 0], [0, 0]], v: [[-282.177, -120.609], [-282.177, -135.474], [-318.332, -135.474], [-318.332, -172.385], [-334.709, -172.385], [-334.709, -135.474], [-357.133, -135.474], [-357.133, -120.609], [-334.709, -120.609], [-334.709, -36.582], [-298.428, -2.065], [-282.177, -2.065], [-282.177, -16.552], [-296.664, -16.552], [-318.332, -38.346], [-318.332, -120.609]], c: !0 }, ix: 2 }, nm: "t", mn: "ADBE Vector Shape - Group", hd: !1 }, { ty: "fl", c: { a: 0, k: [1, 1, 1, 1], ix: 4 }, o: { a: 0, k: 100, ix: 5 }, r: 1, bm: 0, nm: "Fill 1", mn: "ADBE Vector Graphic - Fill", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [-319.655, -87.225], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "t", np: 3, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 8.00800800800801, op: 604.604604604605, st: 8.00800800800801, ct: 1, bm: 0 }, { ddd: 0, ind: 20, ty: 4, nm: "e Outline", sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { s: !0, x: { a: 0, k: 315.638, ix: 3 }, y: { a: 1, k: [{ i: { x: [.188], y: [1] }, o: { x: [.014], y: [.826] }, t: 4, s: [342.045] }, { t: 62.062597754004, s: [130.045] }], ix: 4 } }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ ind: 0, ty: "sh", ix: 1, ks: { a: 0, k: { i: [[0, 0], [37.919, 0], [0, -38.297], [-38.927, 0], [-12.094, 21.164], [0, 0], [19.022, 0], [1.512, 29.604], [0, 0]], o: [[-1.134, -37.919], [-38.675, 0], [0, 38.297], [25.447, 0], [0, 0], [-9.7, 15.747], [-28.723, 0], [0, 0], [0, 0]], v: [[-371.872, -70.47], [-441.159, -137.993], [-510.573, -68.832], [-441.033, .455], [-381.321, -34.189], [-395.304, -40.11], [-441.159, -14.536], [-495.203, -66.313], [-372.124, -66.313]], c: !0 }, ix: 2 }, nm: "e", mn: "ADBE Vector Shape - Group", hd: !1 }, { ind: 1, ty: "sh", ix: 2, ks: { a: 0, k: { i: [[-26.455, 0], [-4.787, -24.817], [0, 0]], o: [[26.329, 0], [0, 0], [5.039, -25.069]], v: [[-441.159, -123.002], [-388.879, -79.666], [-494.07, -79.666]], c: !0 }, ix: 2 }, nm: "e", mn: "ADBE Vector Shape - Group", hd: !1 }, { ty: "mm", mm: 1, nm: "Merge Paths 1", mn: "ADBE Vector Filter - Merge", hd: !1 }, { ty: "fl", c: { a: 0, k: [1, 1, 1, 1], ix: 4 }, o: { a: 0, k: 100, ix: 5 }, r: 1, bm: 0, nm: "Fill 1", mn: "ADBE Vector Graphic - Fill", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [-441.222, -68.769], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "e", np: 5, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 4.004004004004, op: 604.604604604605, st: 4.004004004004, ct: 1, bm: 0 }, { ddd: 0, ind: 21, ty: 4, nm: "G Outline", sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { s: !0, x: { a: 0, k: 122.516, ix: 3 }, y: { a: 1, k: [{ i: { x: [.188], y: [1] }, o: { x: [.014], y: [.826] }, t: 0, s: [312] }, { t: 62.0625, s: [100] }], ix: 4 } }, a: { a: 0, k: [0, 0, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, shapes: [{ ty: "gr", it: [{ ind: 0, ty: "sh", ix: 1, ks: { a: 0, k: { i: [[0, 0], [0, 0], [0, 0], [0, 0], [40.942, 0], [0, 45.352], [-45.226, 0], [-14.361, -22.676], [0, 0], [35.777, 0], [0, -54.926], [-54.926, 0], [0, 55.052]], o: [[0, 0], [0, 0], [0, 0], [-6.299, 39.053], [-45.226, 0], [0, -45.352], [29.227, 0], [0, 0], [-17.385, -28.093], [-54.926, 0], [0, 54.926], [55.178, 0], [0, 0]], v: [[-535.012, -102.468], [-617.023, -102.468], [-617.023, -85.713], [-553.656, -85.713], [-634.281, -17.182], [-715.914, -98.815], [-634.281, -180.447], [-565.246, -142.528], [-549.877, -151.221], [-634.281, -198.084], [-733.677, -98.815], [-634.281, .455], [-535.012, -98.941]], c: !0 }, ix: 2 }, nm: "G", mn: "ADBE Vector Shape - Group", hd: !1 }, { ty: "fl", c: { a: 0, k: [1, 1, 1, 1], ix: 4 }, o: { a: 0, k: 100, ix: 5 }, r: 1, bm: 0, nm: "Fill 1", mn: "ADBE Vector Graphic - Fill", hd: !1 }, { ty: "tr", p: { a: 0, k: [0, 0], ix: 2 }, a: { a: 0, k: [-634.344, -98.815], ix: 1 }, s: { a: 0, k: [100, 100], ix: 3 }, r: { a: 0, k: 0, ix: 6 }, o: { a: 0, k: 100, ix: 7 }, sk: { a: 0, k: 0, ix: 4 }, sa: { a: 0, k: 0, ix: 5 }, nm: "Transform" }], nm: "G", np: 3, cix: 2, bm: 0, ix: 1, mn: "ADBE Vector Group", hd: !1 }], ip: 0, op: 604.604604604605, st: 0, ct: 1, bm: 0 }] }], layers = [{ ddd: 0, ind: 1, ty: 0, nm: "Pre-comp 2", refId: "comp_0", sr: 1, ks: { o: { a: 0, k: 100, ix: 11 }, r: { a: 0, k: 0, ix: 10 }, p: { s: !0, x: { a: 0, k: 840.597, ix: 3 }, y: { a: 0, k: 100, ix: 4 } }, a: { a: 0, k: [808, 100, 0], ix: 1, l: 2 }, s: { a: 0, k: [100, 100, 100], ix: 6, l: 2 } }, ao: 0, w: 1616, h: 200, ip: 0, op: 604, st: 0, bm: 0 }], markers = [], props = {}, contactData = { v, fr, ip, op, w: w$1, h: h$1, nm, ddd, assets, layers, markers, props }; gsapWithCSS.registerPlugin(ScrollTrigger$1, ScrollToPlugin, CustomEase, ScrambleTextPlugin, TextPlugin, DrawSVGPlugin); let App$8 = class { constructor() { } init() { $$1("[data-container='index']") !== null && (this.firstDirection(), this.profileDirection(), this.reelDirection(), this.serviceDirection(), this.worksDirection(), this.contactDirection()) } firstDirection() { const F = document.querySelector("[data-first]"), G = document.querySelector("[data-first-gradation-inner]"), Y = document.querySelector("[data-first-gradation-image]"), X = document.querySelector("[data-first-cover]"), K = document.querySelector("[data-first-cover-half]"), J = document.querySelector("[data-first-cover-wrap]"), Z = document.querySelectorAll("[data-first-blur]"), Q = document.querySelector("[data-first-circles]"), ee = document.querySelector("[data-first-circle-center]"), te = document.querySelector("[data-first-circle-center] svg"), oe = document.querySelector("[data-first-circle-center-top]"), ie = document.querySelector("[data-first-circle-center-bottom]"), se = document.querySelectorAll("[data-first-circle]"), ne = document.querySelectorAll("[data-first-circle] svg ellipse"), re = document.querySelectorAll("[data-first-circle-s]"), fe = document.querySelectorAll("[data-first-circle-s] svg ellipse"), ae = document.querySelectorAll("[data-line-vertical]"), he = document.querySelectorAll("[data-first-line-horizontal]"), le = document.querySelector("[data-copy-01]"), ce = splitText(le, "lines"), ue = splitText(ce.lines, "lines"), me = document.querySelectorAll("[data-copy-02-words]"), ge = me[0], ve = splitText(ge, "lines"), Se = splitText(ve.lines, "lines"), ke = me[1], Ce = splitText(ke, "chars"), Ee = me[2], De = splitText(Ee, "lines"), Pe = splitText(De.lines, "lines"), Te = document.querySelector("[data-copy-03]"), ye = document.querySelectorAll("[data-copy-03-words]"), xe = ye[0], pe = splitText(xe, "chars"), de = ye[1], _e = splitText(de, "lines"), be = splitText(_e.lines, "chars"), Ae = ye[2], $e = splitText(Ae, "chars"), Fe = ye[3], Ie = splitText(Fe, "lines"), Be = splitText(Ie.lines, "chars"), Ve = document.querySelectorAll("[data-first-service]"), Ze = document.querySelector("[data-first-text]"), Qe = splitText(Ze, "lines"), Ue = splitText(Qe.lines, "lines"), Ye = document.querySelector("[data-first-progress-gradation]"), Xe = document.querySelector("[data-header-progress]"), Re = document.querySelector("[data-header-back]"), Me = document.querySelector("header"); window.isLoading = !1, ScrollTrigger$1.clearScrollMemory("manual"), window.history.scrollRestoration = "manual"; const it = sessionStorage.getItem("visited"); Xe && (Xe.style.opacity = "0"), Re && getDeviceType() === "sp" && (Re.style.opacity = "0"), ae.forEach(ot => { gsapWithCSS.set(ot, { scaleY: 0 }) }), he.forEach(ot => { gsapWithCSS.set(ot, { scaleX: 0 }) }), gsapWithCSS.set(Ye, { scale: .6 }), gsapWithCSS.set(te, { rotate: 90 }), gsapWithCSS.set(ne, { drawSVG: 0 }), gsapWithCSS.set(fe, { drawSVG: 0 }), gsapWithCSS.set(Te, { x: "40%" }), gsapWithCSS.effects.setTitle([le, ue.lines, Se.lines, Pe.lines, be.chars, Be.chars]), gsapWithCSS.effects.setTextSerif([Ce.chars, pe.chars, $e.chars]), gsapWithCSS.effects.setText(Ue.lines), it ? (gsapWithCSS.set(G, { scale: 1, opacity: 0 }), gsapWithCSS.set(K, { opacity: 0 }), gsapWithCSS.set(ee, { width: "100%", scale: 1, opacity: 1 }), gsapWithCSS.set([oe, ie], { strokeWidth: 1 }), gsapWithCSS.set(ee, { opacity: 0 })) : (scrollSet("stop"), gsapWithCSS.set(G, { scale: .25, opacity: 0 }), gsapWithCSS.set(K, { opacity: 0 }), gsapWithCSS.set(oe, { drawSVG: "0% 0%" }), gsapWithCSS.set(ie, { drawSVG: "0% 0%" })); const nt = CustomEase.create("custom", "M0,0 C0.11,0.282 0.063,0.508 0.22,0.797 0.342,1.022 0.468,1.004 1,1 "), we = CustomEase.create("custom", "M0,0 C0.154,0.052 0.249,0.347 0.302,0.521 0.448,1 0.744,1 1,1 "), Ge = it ? -3.55 : 0, Oe = gsapWithCSS.timeline(); Oe.set(ee, { visibility: "visible" }, "show"), it || (Oe.to('[data-first-progress-number="one"]', { y: "-90%", duration: 2.75, ease: we }, "show"), Oe.to('[data-first-progress-number="ten"]', { y: "-90%", duration: 2.75, ease: we }, "show+=0.2"), Oe.to('[data-first-progress-number="hundred"]', { y: "-90%", duration: 2.75, ease: we }, "show+=0.4"), Oe.to(te, { rotate: 540, duration: 2.5, ease: we }, "show"), Oe.to(oe, { drawSVG: "0% 100%", duration: 2.5, ease: we }, "show"), Oe.to(ie, { drawSVG: "0% 100%", duration: 2.5, ease: we }, "show"), Oe.to(Ye, { opacity: 1, duration: 2, scale: 1 }, "show+=0.2"), Oe.to(['[data-first-progress-number="hundred"]', '[data-first-progress-number="ten"]', '[data-first-progress-number="one"]'], { opacity: 0, duration: .4, ease: "power3.inOut" }, "show+=3.55")), Oe.to([oe, ie], { strokeWidth: 1, duration: 1.5, ease: "power3.out" }, `show+=${3.6 + Ge}`), Oe.to(G, { scale: 1, opacity: 1, duration: 3, ease: nt, overwrite: "auto" }, `show+=${3.75 + Ge}`), Oe.to(ee, { width: "100%", opacity: .5, duration: 3, ease: nt, delay: getDeviceType() === "sp" ? .05 : 0, overwrite: "auto" }, `show+=${3.75 + Ge}`), Oe.to(Ye, { opacity: 0, duration: 2, ease: nt }, `show+=${3.8 + Ge}`), Oe.to(X, { opacity: 0, duration: .5 }, `show+=${3.4 + Ge}`), Oe.to(he, { scaleX: 1, duration: 2.5, ease: we }, `show+=${3.75 + Ge}`), Oe.to(ne, { drawSVG: "100% live", duration: 1, ease: "power1.in", onStart: () => { window.isLoading = !0 } }, `show+=${3.75 + Ge}`), Oe.to(fe, { drawSVG: "100% live", duration: 1.5, ease: "power3.out" }, `show+=${4.75 + Ge}`), Oe.to(ae, { scaleY: 1, duration: 2, ease: we }, `show+=${5 + Ge}`), Oe.to(K, { opacity: 1, duration: 1 }, `show+=${4.75 + Ge}`), Oe.inText(ue.lines, { duration: 2.5, stagger: .1 }, `show+=${4.4 + Ge}`), Oe.to(le, { duration: 1, y: "0", ease: "power3.inOut" }, `show+=${4.6 + Ge}`), Oe.inTitle(Se.lines, { duration: 2, ease: "power3.out" }, `show+=${4.75 + Ge}`), Oe.inTextSerif(Ce.chars, `show+=${5.25 + Ge}`), Oe.inText(Pe.lines, { duration: 2.5, stagger: .1 }, `show+=${5.5 + Ge}`), Oe.inText(be.chars, { duration: 2.5, stagger: .1 }, `show+=${5.25 + Ge}`), Oe.inTextSerif(pe.chars, `show+=${5.5 + Ge}`), Oe.to(Te, { duration: 1.2, x: "0", ease: we }, `show+=${5.6 + Ge}`), Oe.inTextSerif($e.chars, `show+=${6 + Ge}`), Oe.inText(Be.chars, { duration: 2, stagger: .1 }, `show+=${6.2 + Ge}`), Oe.inText(Ue.lines, `show+=${5 + Ge}`), Oe.to({}, { onStart: () => { SERVICE?.forEach((ot, dt) => { gsapWithCSS.effects.inScrambleText([...Ve][dt], { text: `{${ot.title.toUpperCase()}}`, delay: Math.random() * 1 }) }) } }, `show+=${5 + Ge}`), Oe.to([Me], { opacity: 1, duration: 1, onComplete: () => { scrollSet("start"), sessionStorage.setItem("visited", "true") } }, "<"); const at = CustomEase.create("custom", "M0,0 C0.138,0.085 0.262,0.362 0.347,0.6 0.477,0.967 0.643,1 1,1 "), We = gsapWithCSS.timeline({ scrollTrigger: { trigger: F, start: "top top", end: "bottom top-=50%", scrub: 1.8, anticipatePin: 1, invalidateOnRefresh: !0, fastScrollEnd: !1, onEnter: () => { Re && getDeviceType() === "sp" && (Re.style.opacity = "1"), Xe && (Xe.style.opacity = "1"), Xe && (Xe.style.color = "var(--color-sub)") }, onLeaveBack: () => { Re && getDeviceType() === "sp" && (Re.style.opacity = "0"), Xe && (Xe.style.opacity = "0") } } }); We.to(se, { top: 0, right: 0, left: 0, bottom: 0, ease: at }, "<"), We.to(re, { top: 0, right: 0, left: 0, bottom: 0, opacity: .25, scale: 2, ease: at }, "<"), We.to(J, { opacity: 0 }, "<"), We.to(Y, { width: getDeviceType() === "sp" ? "1244rem" : "auto", height: getDeviceType() === "sp" ? "700rem" : "2040rem", opacity: 1, ease: at }, "<"), We.to(Q, { scale: getDeviceType() === "sp" ? 1.5 : 2, ease: at }, "<"), We.to(ee, { scale: getDeviceType() === "sp" ? 1.5 : 2, ease: at }, "<"), We.fromTo(Z, { opacity: 0 }, { opacity: 1 }, "<+=0.075") } profileDirection() { const F = document.querySelector("[data-profile-hello]"), G = splitText(F, "chars"), Y = document.querySelector("[data-profile-text-en]"), X = splitText(Y, "lines"), K = splitText(X.lines, "lines"), J = document.querySelector("[data-profile-text-ja]"), Z = new OneLineSplit({ target: J }), Q = splitText(Z.lines, "lines"), ee = document.querySelector("[data-profile-title]"); wrapSpecificText(Y, ["Kaito Note", "Web", "Video", "blue flame"], "font-noto italic"), gsapWithCSS.effects.setTitle(G.chars, { y: "100%" }), gsapWithCSS.effects.setText(Q.lines, { y: "100%" }), K.lines.forEach(se => { const ne = se.cloneNode(!0); ne.style.position = "absolute", ne.classList.add("top-0", "left-0", "text-[var(--color-gray-dark)]", "mix-blend-difference", "z-[-1]", "w-fit", "h-fit"), se.parentNode && se.parentNode.appendChild(ne), se.setAttribute("data-mask-text", "") }), gsapWithCSS.effects.setImageMaskToRight("[data-mask-text]"); const te = gsapWithCSS.timeline({ scrollTrigger: { trigger: F, start: "top center+=25%" } }); te.inTitle(G.chars, "show"), te.to({}, { delay: .5, onStart: () => { gsapWithCSS.effects.inScrambleText(ee, { text: "{PROFILE}" }) } }, "<"), gsapWithCSS.timeline({ scrollTrigger: { trigger: J, start: "top center+=35%" } }).inText(Q.lines, { stagger: .1 }), gsapWithCSS.timeline({ scrollTrigger: { trigger: Y, start: "top bottom", end: "bottom center+=15%", scrub: 1.8 } }).inImageMask("[data-mask-text]", { duration: 2, stagger: .1, ease: "power1.inOut" }) } reelDirection() { const F = document.querySelector("[data-reel]"), G = document.querySelector("[data-reel-container]"), Y = document.querySelector("[data-first-gradation]"), X = document.querySelector("[data-first-gradation-wrap]"), K = document.querySelector("[data-first-circle-center-inner]"), J = document.querySelectorAll("[data-first-circle-inner]"), Z = document.querySelectorAll("[data-first-circle-s-inner]"), Q = document.querySelector("[data-reel-blur]"), ee = document.querySelector("[data-reel-copy]"), te = document.querySelector("[data-reel-copy-01]"), oe = splitText(te, "chars"), ie = document.querySelector("[data-reel-copy-02]"), se = splitText(ie, "chars"), ne = document.querySelector("[data-reel-copy-03]"), re = splitText(ne, "chars"), fe = document.querySelector("[data-reel-copy-04]"), ae = splitText(fe, "chars"), he = document.querySelector("[data-reel-copy-05]"), le = splitText(he, "chars"), ce = document.querySelector("[data-reel-copy-06]"), ue = splitText(ce, "chars"), me = document.querySelector("[data-reel-copy-07]"), ge = splitText(me, "chars"), ve = document.querySelector("[data-reel-copy-08]"), Se = splitText(ve, "chars"), ke = document.querySelector("[data-reel-link]"), Ce = splitText(ke, "chars"), Ee = document.querySelector("[data-reel-movie]"), De = document.querySelectorAll("[data-reel-work]"), Pe = document.querySelector('[data-parts-transition-bg="light"]'), Te = document.querySelector("[data-header-progress]"), ye = document.querySelectorAll("[data-first-blur-wrap]"); let xe = !1, pe = !1; gsapWithCSS.effects.setTitle([se.chars, ne, re.chars, le.chars, ge.chars, Se.chars, Ce.chars], { y: "100%" }), gsapWithCSS.set(ie, { x: "50%" }), gsapWithCSS.set(ne, { y: "100%" }), gsapWithCSS.effects.setTextSerif([oe.chars, ae.chars, ue.chars], { opacity: 0 }), gsapWithCSS.set([ee, ke], { opacity: 0 }), gsapWithCSS.set(Ee, { scale: 0 }); const de = gsapWithCSS.timeline({ paused: !0 }); de.inTextSerif(oe.chars, "show"), de.inTitle(se.chars, "show"), de.to(ie, { duration: 1, x: "0", ease: "power3.inOut" }, "<0.4"), de.inTitle(re.chars, "show+=0.1"), de.to(ne, { duration: 1, y: "0", ease: "power3.inOut" }, "show+=0.4"), de.inTextSerif(ae.chars, "show+=0.6"), de.inTitle(le.chars, { stagger: 0 }, "show+=0.7"), de.inTextSerif(ue.chars, "show+=1"), de.inTitle(ge.chars, { stagger: 0 }, "show+=0.9"), de.inTitle(Se.chars, "show+=1"); const _e = gsapWithCSS.timeline({ ease: "linear", scrollTrigger: { trigger: F, start: "top-=15% top", end: "bottom bottom", scrub: !0, anticipatePin: 1, invalidateOnRefresh: !0, fastScrollEnd: !1, onLeave: () => { Te && (Te.style.color = "var(--color-main)"), gsapWithCSS.set(Pe, { opacity: 1 }) }, onEnterBack: () => { Te && (Te.style.color = "var(--color-sub)"), gsapWithCSS.set(Pe, { opacity: 0 }) } } }); _e.fromTo(Y, { opacity: 1 }, { opacity: 0, duration: 1, ease: "power3.in", overwrite: "auto" }, "first"), _e.fromTo(X, { scale: 1 }, { scale: 0, duration: getDeviceType() === "sp" ? 1.5 : 2, ease: "power3.in", overwrite: "auto" }, "first"), _e.to([J, Z], { scale: 0, duration: getDeviceType() === "sp" ? 1.5 : 2, ease: "power3.in" }, "first"), _e.to(K, { scale: 0, duration: getDeviceType() === "sp" ? 1.5 : 2, ease: "power3.in" }, "first"), _e.to(ee, { opacity: 1, duration: .75 }, "first+=0.65"), _e.to({}, { onStart: () => { xe || (xe = !0, de.play()) } }, getDeviceType() === "sp" ? "first+=0.7" : "first+=0.85"), De.forEach((be, Ae) => { const $e = parseFloat(be.getAttribute("data-x") ?? "0"), Fe = parseFloat(be.getAttribute("data-y") ?? "0"), Ie = parseFloat(be.getAttribute("data-z") ?? "0"); _e.fromTo(be, { x: () => 0, y: () => 0, z: () => `${Ie}rem` }, { x: () => `${$e}rem`, y: () => `${Fe}rem`, z: () => "1000rem", duration: 1.5, ease: "expo.out" }, getDeviceType() === "sp" ? `first+=${.65 + Ae * .05}` : `first+=${.65 + Ae * .075}`), _e.fromTo(be, { opacity: 0 }, { opacity: 1, duration: .5, ease: "expo.out" }, getDeviceType() === "sp" ? `first+=${.65 + Ae * .05}` : `first+=${.65 + Ae * .075}`) }), _e.to(Q, { opacity: 1, duration: .5 }, getDeviceType() === "sp" ? "first+=1.5" : "first+=1.75"), _e.to(ye, { opacity: 0, duration: 1 }, "first+=2.5"), _e.to(ee, { opacity: 0, duration: .5 }, "first+=1.75"), _e.to(Ee, { scale: 1, duration: 1 }, getDeviceType() === "sp" ? "first+=1.25" : "first+=1.5"), _e.to(ke, { opacity: 1, duration: .5, onComplete: () => { pe || (pe = !0, gsapWithCSS.effects.inTitle(Ce.chars, { stagger: .075 })) } }, getDeviceType() === "sp" ? "first+=2.25" : "first+=2.5"), _e.to({}, { duration: .5 }), ScrollTrigger$1.create({ trigger: F, start: "top top", end: () => `bottom ${window.innerHeight}`, pin: G, pinSpacing: !0, anticipatePin: 1, invalidateOnRefresh: !(getDeviceType() === "sp" && touchOnly()) }) } serviceDirection() { const F = document.querySelector("[data-service-title]"), G = document.querySelector("[data-service-text-en]"), Y = splitText(G, "lines"), X = splitText(Y.lines, "lines"), K = document.querySelector("[data-service-text-ja]"), J = splitText(K, "lines"), Z = splitText(J.lines, "lines"), Q = document.querySelectorAll("[data-service-item]"), ee = document.querySelector("[data-service-image]"); let te = null; ee && (te = lottie.loadAnimation({ container: ee, renderer: "canvas", loop: !0, autoplay: !1, animationData: serviceData })), wrapSpecificText(G, ["four", "both", "digital experiences"], "font-noto italic"), gsapWithCSS.effects.setText(Z.lines), X.lines.forEach(ne => { const re = ne.cloneNode(!0); re.style.position = "absolute", re.classList.add("top-0", "left-0", "z-[-1]", "text-gray-600", "mix-blend-difference", "w-fit", "h-fit"), ne.parentNode && ne.parentNode.appendChild(re), ne.setAttribute("data-mask-text", "") }), gsapWithCSS.effects.setImageMaskToRight("[data-mask-text]"), gsapWithCSS.timeline({ scrollTrigger: { trigger: F, start: "top center+=25%" } }).to({}, { onStart: () => { gsapWithCSS.effects.inScrambleText(F, { text: "{SERVICE}" }) } }, "<"), gsapWithCSS.timeline({ scrollTrigger: { trigger: K, start: "top center+=35%" } }).inText(Z.lines, { stagger: .15 }), Q.forEach((ne, re) => { const fe = ne.querySelector("[data-service-item-title]"), ae = splitText(fe, "chars"), he = ne.querySelector("[data-service-item-text]"), le = splitText(he, "lines"), ce = splitText(le.lines, "lines"), ue = ne.querySelector("[data-service-item-number]"), me = ne.querySelectorAll("[data-service-item-line]"); gsapWithCSS.effects.setTitle(ae.chars, { y: "100%" }), gsapWithCSS.effects.setText(ce.lines, { y: "100%" }), gsapWithCSS.effects.setLine(me); const ge = gsapWithCSS.timeline({ scrollTrigger: { trigger: fe, start: getDeviceType() === "sp" ? "top center+=25%" : "top center+=35%" } }); ge.inText(ae.chars, { stagger: .05 }, "show"), ge.to({}, { onStart: () => { re === 0 && te?.play(), gsapWithCSS.effects.inScrambleText(ue, { text: `${String(re + 1).padStart(2, "0")}` }) } }, "<"), ge.inLine(me, { stagger: .3 }, "show"), ge.inText(ce.lines, { stagger: .05 }, "show+=0.6") }), gsapWithCSS.timeline({ scrollTrigger: { trigger: G, start: "top-=100% bottom", end: "bottom center+=25%", scrub: 1.8 } }).inImageMask("[data-mask-text]", { duration: 2, stagger: .15, ease: "power1.inOut" }) } worksDirection() { const F = document.querySelector("[data-works-title]"), G = document.querySelectorAll("[data-works-item]"), Y = document.querySelectorAll("[data-works-bg]"); ScrollTrigger$1.create({ trigger: F, start: "top center+=25%", once: !0, onEnter: () => { gsapWithCSS.effects.inScrambleText(F, { text: "{WORKS}" }) } }), G.forEach((X, K) => { const J = Y[K], Z = J.querySelectorAll("[data-works-bg-title]"), Q = splitText(Z, "chars"), ee = X.querySelector("[data-works-title-en]"), te = new OneLineSplit({ target: ee }), oe = X.querySelectorAll("[data-works-category]"), ie = X.querySelector("[data-works-image-wrap]"), se = X.querySelectorAll("[data-works-image]"), ne = 60, re = 5e3, fe = Z[0].offsetWidth, ae = re / ne, he = fe / ae, le = -he / 2; Z[0].style.setProperty("--slide-duration", `${he}s`), Z[1].style.setProperty("--slide-duration", `${he}s`), Z[0].style.setProperty("--slide-delay", `${le}s`), Z[1].style.setProperty("--slide-delay", `${le}s`), gsapWithCSS.set(ee, { autoAlpha: 0 }), gsapWithCSS.effects.setImageMask(ie), gsapWithCSS.effects.setImage(se); const ce = gsapWithCSS.timeline({ scrollTrigger: { trigger: ie, start: "top center+=25%" } }); if (ce.inImageMask(ie, "show"), ce.inImage(se, "show"), te.lines.forEach((me, ge) => { me.dataset.worksTitleEnLine = me.innerHTML, me.innerHTML = "", ce.inScrambleText(me, { text: me.dataset.worksTitleEnLine, revealDelay: .5 * ge }, "show") }), ce.set(ee, { autoAlpha: 1 }, "show+=0.01"), oe.forEach((me, ge) => { ce.inScrambleText(me, { text: me.dataset.worksCategory, revealDelay: ge * .5 }, "show"), ce.set(me, { autoAlpha: 1 }, "<0.01") }), getDeviceType() === "sp" || touchOnly()) return; const ue = me => { gsapWithCSS.to(J, { opacity: me ? 1 : 0, duration: .6, onStart: () => { me && (J.dataset.worksBgTitle = "true", Z[0]?.classList.add("animate-slideFirst"), Z[1]?.classList.add("animate-slideLast")) }, onComplete: () => { me || (gsapWithCSS.set(Q.chars, { y: "100%" }), J.dataset.worksBgTitle = "false", Z[0]?.classList.remove("animate-slideFirst"), Z[1]?.classList.remove("animate-slideLast"), X.style.pointerEvents = "auto") } }), me && gsapWithCSS.fromTo(Q.chars, { y: "100%" }, { y: "0", duration: 1.8, ease: CustomEase.create("custom", "M0,0 C0,0.573 0.092,0.778 0.176,0.866 0.26,0.954 0.394,1 1,1 "), stagger: .04, overwrite: !0 }) }; X.addEventListener("mouseenter", () => { J.dataset.worksBgTitle !== "true" && ue(!0) }), X.addEventListener("mouseleave", () => { J.dataset.worksBgTitle !== "false" && (ue(!1), X.style.pointerEvents = "none") }) }) } contactDirection() { const F = document.querySelector("[data-contact-title]"), G = document.querySelector("[data-contact-circle-wrap]"), Y = document.querySelectorAll("[data-contact-circle]"); let X = null; if (F && (X = lottie.loadAnimation({ container: F, renderer: "canvas", loop: !1, autoplay: !1, animationData: contactData })), gsapWithCSS.timeline({ scrollTrigger: { trigger: F, start: "top center+=25%", onEnter: () => { if (X && (X.play(), getDeviceType() === "sp" || touchOnly())) { const J = gsapWithCSS.timeline({ repeat: -1 }); J.fromTo(Y, { width: "0" }, { width: "100%", duration: 8.5, ease: "power1.out", stagger: 1 }), J.fromTo(Y, { opacity: 1 }, { opacity: 0, duration: 1, stagger: 1, overwrite: "auto" }, "-=8.5"); return } } } }), getDeviceType() === "sp" || touchOnly()) return; const K = J => { J ? (gsapWithCSS.set(G, { opacity: 1 }), gsapWithCSS.fromTo(Y, { width: "0" }, { width: "200%", duration: 10, ease: "power1.out", stagger: .6, overwrite: !0 }), gsapWithCSS.fromTo(Y, { opacity: 1 }, { opacity: 0, duration: 1, stagger: .6, delay: 2 })) : gsapWithCSS.to(G, { opacity: 0, duration: .6, onComplete: () => { F && (F.style.pointerEvents = "auto") } }) }; F && (F.addEventListener("mouseenter", () => { K(!0) }), F.addEventListener("mouseleave", () => { F && (F.style.pointerEvents = "none"), K(!1) })) } }; gsapWithCSS.registerPlugin(ScrollTrigger$1, CustomEase); let App$7 = class { constructor() { } init() { if ($$1("[data-container='profile']") === null) return; const F = document.querySelector("[data-profile-image-wrap]"), G = document.querySelector("[data-profile-image]"), Y = document.querySelector("[data-profile-copy]"), X = splitText(Y, "lines"), K = splitText(X.lines, "lines"), J = document.querySelector("[data-profile-title]"), Z = splitText(J, "chars"), Q = document.querySelector("[data-profile-title-arrow]"), ee = document.querySelector("[data-profile-text-en]"), te = splitText(ee, "lines"), oe = splitText(te.lines, "lines"), ie = document.querySelector("[data-profile-text-ja]"), se = new OneLineSplit({ target: ie }), ne = splitText(se.lines, "lines"), re = document.querySelector("[data-profile-job]"), fe = splitText("[data-profile-item-title]", "lines"), ae = splitText(fe.lines, "chars"), he = splitText("[data-profile-item-description]", "lines"), le = splitText(he.lines, "lines"), ce = document.querySelectorAll("[data-profile-item-line]"); gsapWithCSS.effects.setText(K.lines), gsapWithCSS.effects.setTitle(Z.chars), gsapWithCSS.set(Q, { transformOrigin: "top right", scale: 0 }), gsapWithCSS.effects.setText(oe.lines), gsapWithCSS.effects.setText(ne.lines), gsapWithCSS.effects.setTitle(ae.chars), gsapWithCSS.effects.setText(le.lines), gsapWithCSS.effects.setLine(ce), wrapSpecificText(Y, ["Unforgettable", "heart", "blue flame"], "font-noto italic"), gsapWithCSS.set(F, { maskImage: "linear-gradient(to bottom, black 0%, black 100%)", webkitMaskImage: "linear-gradient(to bottom, black 0%, black 100%)", maskPosition: "100% bottom", webkitMaskPosition: "100% bottom", maskRepeat: "no-repeat", webkitMaskRepeat: "no-repeat", maskSize: "100% 0%", webkitMaskSize: "100% 0%", transformOrigin: "top left" }), gsapWithCSS.set(G, { scale: 1.8 }); const ue = gsapWithCSS.timeline(); ue.inText(K.lines, { stagger: .1 }, getDeviceType() === "sp" ? "in+=0.25" : "in"), ue.to(F, { maskSize: "100% 100%", webkitMaskSize: "100% 100%", duration: 1.4, ease: "expo.out" }, "in+=0.2"), ue.to(G, { scale: 1, duration: 3, ease: "power3.out" }, "in"), ue.inTitle(Z.chars, {}, getDeviceType() === "sp" ? "in" : "in+=0.4"), ue.to(Q, { scale: 1, duration: 1.6, ease: "expo.out" }, "in+=1"); const me = gsapWithCSS.timeline({ scrollTrigger: { trigger: ee, start: "top center+=25%" } }); me.inText(oe.lines, { stagger: getDeviceType() === "sp" ? .05 : .075 }, "show"), me.inText(ne.lines, { stagger: getDeviceType() === "sp" ? .05 : .075 }, getDeviceType() === "sp" ? "show+=0.5" : "show+=0.35"); const ge = gsapWithCSS.timeline({ scrollTrigger: { trigger: ce[0], start: "top center+=35%" } }); if (ge.inLine(ce, "show"), ge.inTitle(ae.chars, { duration: 1.6, stagger: .04 }, getDeviceType() === "sp" ? "show+=0.2" : "show+=0.25"), ge.inText(le.lines, { stagger: .1, delay: getDeviceType() === "sp" ? .5 : .25 }, getDeviceType() === "sp" ? "show+=0.3" : "show+=0.75"), getDeviceType() === "sp" || touchOnly()) return; gsapWithCSS.timeline({ scrollTrigger: { trigger: re, start: "top bottom", end: "bottom top", scrub: !0 } }).to(re, { x: () => getDeviceType() === "sp" ? "-100%" : "-50%", ease: getDeviceType() === "sp" ? "power2.out" : "linear" }) } }; gsapWithCSS.registerPlugin(ScrollTrigger$1, CustomEase); class Works { constructor() { } init() { if (!$$1("[data-container='works']") && !$$1("[data-container='works-private']")) return; const F = splitText("[data-parts-title]", "chars"), G = splitText("[data-parts-filter-title]", "lines"), Y = splitText(G.lines, "lines"), X = splitText("[data-parts-filter-text]", "lines"), K = splitText(X.lines, "lines"), J = document.querySelectorAll("[data-works-item]"); gsapWithCSS.effects.setTitle(F.chars), gsapWithCSS.effects.setText(Y.lines), gsapWithCSS.effects.setText(K.lines), (getDeviceType() !== "sp" || !touchOnly()) && gsapWithCSS.set(J, { opacity: 0 }); const Z = gsapWithCSS.timeline(); Z.inTitle(F.chars, "show"), Z.inText(Y.lines, { stagger: .2 }, "show+=0.5"), Z.inText(K.lines, { stagger: .05 }, "show+=0.5"), (getDeviceType() !== "sp" || !touchOnly()) && Z.to(J, { opacity: 1, duration: 1, stagger: { each: .1 } }, "show+=1.25"), $$("[data-works-item]").forEach(he => { const le = he.querySelector("[data-works-title]"); if (!le) return; const ce = new OneLineSplit({ target: le }), ue = he.querySelectorAll("[data-works-category]"); if (ce.lines.forEach(Se => { Se.dataset.worksTitleLine = Se.innerHTML, Se.innerHTML = "" }), he.addEventListener("mouseenter", () => { getDeviceType() === "sp" || touchOnly() || (ce.lines.forEach((Se, ke) => { gsapWithCSS.effects.inScrambleText(Se, { text: Se.dataset.worksTitleLine, revealDelay: .3 * ke }, "show") }), ue.forEach((Se, ke) => { gsapWithCSS.effects.inScrambleText(Se, { text: Se.dataset.worksCategory, revealDelay: .6 * ke }, "show") })) }), he.addEventListener("mouseleave", Se => { if (getDeviceType() === "sp" || touchOnly()) return; Se.currentTarget.querySelector("[data-works-title]") && ce.lines.forEach(Ee => { Ee.innerHTML = "" }), ue.forEach(Ee => { Ee.innerHTML = "" }) }), getDeviceType() !== "sp" || !touchOnly()) return; const me = he.querySelector("[data-works-item-image-wrap]"), ge = he.querySelector("[data-works-item-image]"); gsapWithCSS.effects.setImageMask(me), gsapWithCSS.effects.setImage(ge); const ve = gsapWithCSS.timeline({ scrollTrigger: { trigger: he, start: "top center+=25%", once: !0 } }); ce.lines.forEach((Se, ke) => { ve.add(() => { gsapWithCSS.effects.inScrambleText(Se, { text: Se.dataset.worksTitleLine, revealDelay: .3 * ke }, "show") }) }), ue.forEach((Se, ke) => { ve.add(() => { gsapWithCSS.effects.inScrambleText(Se, { text: Se.dataset.worksCategory, revealDelay: .6 * ke }, "show") }) }), ve.inImageMask(me, "show"), ve.inImage(ge, "show") }); const Q = { type: "ALL", category: "ALL" }, ee = () => { const he = gsapWithCSS.timeline(); he.to("[data-works-list]", { duration: .5, opacity: 0 }), he.call(() => { const le = [], ce = $$("[data-works-item]"); ce.forEach(ue => { ue.style.display = "none" }), ce.forEach(ue => { const me = ue.dataset.worksType || "ALL", ge = ue.dataset.worksCategory ? ue.dataset.worksCategory.split(",") : ["ALL"], ve = Q.type === "ALL" || Q.type === me, Se = Q.category === "ALL" || ge.includes(Q.category.trim()); ve && Se && (ue.style.display = "", le.push(ue)) }), le.forEach(ue => { ue.classList.remove("col-span-2", "row-span-2") }), le.forEach((ue, me) => { ((me + 1) % 9 === 2 || (me + 1) % 9 === 4) && ue.classList.add("col-span-2", "row-span-2") }) }), he.to("[data-works-list]", { duration: .5, opacity: 1 }) }, te = () => { $$("[data-parts-filter-button]").forEach(he => { const le = he.dataset.partsFilterButton?.toLowerCase(), ce = he.textContent.trim(); le === "type" && ce === Q.type || le === "category" && ce === Q.category ? he.setAttribute("data-current", "") : he.removeAttribute("data-current") }) }, oe = he => { const le = he.dataset.partsFilterButton?.toLowerCase(), ce = he.textContent ? he.textContent.trim() : ""; le === "type" ? Q.type = ce : le === "category" && (Q.category = ce), te(), ee() }; if ($$("[data-parts-filter-button]").forEach(he => { he.addEventListener("click", () => oe(he)) }), getDeviceType() !== "sp" || !touchOnly()) return; let ie = !1; const se = CustomEase.create("custom", "M0,0 C0.154,0.052 0.249,0.347 0.302,0.521 0.448,1 0.744,1 1,1 "), ne = () => { if (ie) return; ie = !0, gsapWithCSS.set("[data-parts-filter]", { pointerEvents: "auto" }), gsapWithCSS.set("[data-parts-filter-overlay]", { pointerEvents: "auto" }); const he = gsapWithCSS.timeline(); he.to("[data-parts-filter-overlay]", { opacity: .8, duration: .6 }), he.to("[data-parts-filter]", { opacity: 1, y: 0, duration: .8, ease: se }, "<") }, re = () => { if (!ie) return; ie = !1, gsapWithCSS.set("[data-parts-filter]", { pointerEvents: "none" }), gsapWithCSS.set("[data-parts-filter-overlay]", { pointerEvents: "none" }); const he = gsapWithCSS.timeline(); he.to("[data-parts-filter]", { opacity: 0, y: "15%", duration: .8, ease: se }), he.to("[data-parts-filter-overlay]", { opacity: 0, duration: .6, delay: .2 }, "<") }; $$1("[data-parts-filter-button-open]").addEventListener("click", ne), $$1("[data-parts-filter-button-close]").addEventListener("click", re); const fe = document.querySelectorAll("[data-parts-filter-button]"), ae = document.querySelectorAll("[data-parts-filter-button-open]"); ScrollTrigger$1.create({ trigger: "footer", start: () => "top bottom", invalidateOnRefresh: !0, onEnter: () => { ae && ae.length >= 3 && (gsapWithCSS.to([ae[0], ae[2], ae[3]], { opacity: 0, duration: .5 }), gsapWithCSS.to(ae[1], { opacity: 0, duration: .5 })) }, onLeaveBack: () => { ae && ae.length >= 3 && (gsapWithCSS.to([ae[0], ae[2], ae[3]], { opacity: 1, duration: .5 }), gsapWithCSS.to(ae[1], { opacity: .1, duration: .5 })) } }), fe && fe.forEach(he => { he.addEventListener("click", () => { setTimeout(() => { ScrollTrigger$1.refresh() }, 1e3) }) }) } } gsapWithCSS.registerPlugin(ScrollTrigger$1); let App$6 = class { constructor() { } init() { if ($$1("[data-container='works-id']") === null) return; const F = splitText("[data-detail-title-en]", "lines"), G = splitText(F.lines, "chars"), Y = $$1("[data-detail-title-ja]"), X = splitText("[data-detail-title]", "lines"), K = splitText("[data-detail-text]", "lines"), J = splitText(K.lines, "lines"), Z = splitText("[data-detail-credit] p", "lines"), Q = splitText(Z.lines, "lines"), ee = new OneLineSplit({ target: "[data-detail-description] p" }), te = splitText(ee.lines, "lines"), oe = document.querySelector("[data-detail-thumbnail-wrap]"), ie = document.querySelector("[data-detail-thumbnail]"); gsapWithCSS.effects.setTitle(G.chars), gsapWithCSS.effects.setText(X.lines), gsapWithCSS.effects.setText(J.lines), gsapWithCSS.effects.setText(te.lines), gsapWithCSS.effects.setText(Q.lines), gsapWithCSS.effects.setImageMask(oe), gsapWithCSS.effects.setImage(ie); const se = gsapWithCSS.timeline(); se.inTitle(G.chars, { stagger: .05 }, "show"), Y && se.inScrambleText(Y, { text: Y.dataset.detailTitleJa }, "show+=0.5"), se.inImageMask(oe, { duration: 2.5 }, Y ? "show+=1" : "show+=0.5"), se.inImage(ie, Y ? "show+=1" : "show+=0.5"); const ne = gsapWithCSS.timeline({ scrollTrigger: { trigger: "[data-detail-thumbnail-wrap]", start: "bottom center" } }); ne.inTitle(X.lines, { duration: 2, ease: "power2.inOut", stagger: 0 }, "show"), ne.inTitle(J.lines, { duration: 2, ease: "power2.inOut", stagger: .05 }, "show+=0.025"), ne.inTitle(Q.lines, { duration: 2, ease: "power2.inOut", stagger: .05 }, "show+=0.025"), ne.inTitle(te.lines, { duration: 2, ease: "power2.inOut" }, "show+=0.025") } }; gsapWithCSS.registerPlugin(ScrollTrigger$1, ScrambleTextPlugin, SplitText); let App$5 = class { constructor() { } init() { if ($$1("[data-container='contact']") === null) return; const F = splitText("[data-parts-title]", "chars"), G = splitText("[data-contact-item-title]", "lines"), Y = splitText(G.lines, "chars"), X = splitText("[data-contact-item-description]", "lines"), K = splitText(X.lines, "lines"), J = document.querySelectorAll("[data-contact-item-line]"), Z = splitText("[data-contact-text]", "lines"), Q = splitText(Z.lines, "lines"); gsapWithCSS.effects.setTitle(F.chars), gsapWithCSS.effects.setTitle(Y.chars), gsapWithCSS.effects.setText(K.lines), gsapWithCSS.effects.setLine(J), gsapWithCSS.effects.setText(Q.lines); const ee = gsapWithCSS.timeline(); ee.inTitle(F.chars, "show"), ee.inLine(J, { stagger: .25 }, "show"), ee.inTitle(Y.chars, { duration: 1.6, stagger: .04 }, getDeviceType() === "sp" ? "show+=0.2" : "show+=0.25"), ee.inText(K.lines, { stagger: .1, delay: getDeviceType() === "sp" ? .5 : .25 }, getDeviceType() === "sp" ? "show+=0.3" : "show+=0.75"), gsapWithCSS.timeline({ scrollTrigger: { trigger: "[data-contact-text]", start: "top center+=25%" } }).inText(Q.lines, { stagger: .1 }) } }; gsapWithCSS.registerPlugin(ScrollTrigger$1); let App$4 = class { constructor() { } init() { if (!$$1("[data-404]")) return; const F = splitText("[data-404-title]", "chars"), G = splitText("[data-404-title-sub]", "chars"), Y = splitText("[data-404-text-en]", "lines"), X = splitText("[data-404-text-ja]", "lines"); gsapWithCSS.effects.setTitle(F.chars), gsapWithCSS.effects.setTextSerif(G.chars), gsapWithCSS.effects.setText([...Y.lines, X.lines]); const K = gsapWithCSS.timeline(); K.inText(F.chars, { stagger: .15 }, "show"), K.inTextSerif(G.chars, "show+=0.25"), K.inText([...Y.lines, X.lines], "show+=0.6") } }, App$3 = class { constructor() { } init() { $$1("[data-loaded]") || this.setScrollProgress() } changeMode() { $$1("[data-header-mode]").addEventListener("click", () => { const F = gsapWithCSS.timeline(); F.set("[data-parts-transition-mode]", { backgroundColor: getMode() === "dark" ? "#000" : "#fff" }), F.to("[data-parts-transition-mode]", { pointerEvents: "auto", opacity: 1, duration: .6, ease: "power1.out" }), F.to("[data-header-mode-button]", { left: getMode() === "dark" ? "-27rem" : "27rem", duration: .6, ease: "expo.out" }, "<"), F.call(() => { document.documentElement.classList.toggle("dark"), getMode() === "light" ? setColorVariables("#000", "#fff") : setColorVariables("#fff", "#000") }), F.to("[data-parts-transition-mode]", { opacity: 0, pointerEvents: "none", duration: .6, ease: "power1.out", delay: .2 }) }) } setScrollProgress() { const F = document.querySelector("[data-header-progress-number]"), G = () => { const Y = window.scrollY, X = window.innerHeight, K = document.documentElement.scrollHeight, J = Y / (K - X) * 100; F && (F.textContent = `${J.toFixed(0)}`) }; window.addEventListener("scroll", this.throttle(G, 100)) } throttle(F, G) { let Y = Date.now() - G; return function () { Y + G < Date.now() && (Y = Date.now(), F()) } } }; gsapWithCSS.registerPlugin(ScrollTrigger$1, SplitText, CustomEase); let App$2 = class { menuToggle; menu; menuDark; itemName; snsName; snsArrow; customEase; itemNameSplit; itemNameSplitChild; snsNameSplit; snsNameSplitChild; constructor() { this.menuToggle = !1, this.menu = $$("[data-menu]"), this.menuDark = $$1("[data-menu-dark]"), this.itemNameSplit = splitText("[data-menu-item-name]", "lines"), this.itemNameSplitChild = splitText(this.itemNameSplit.lines, "lines"), this.snsNameSplit = splitText("[data-menu-sns-name]", "lines"), this.snsNameSplitChild = splitText(this.snsNameSplit.lines, "lines"), this.customEase = CustomEase.create("custom", "M0,0 C0.154,0.052 0.249,0.347 0.302,0.521 0.448,1 0.744,1 1,1 ") } init() { $$1("[data-loaded]") || this.menuDirection() } menuDirection() { if (this.menuToggle) return; this.menuToggle = !0; const F = document.querySelector("[data-header-open]"), G = document.querySelector("[data-menu-close]"); this.setMenu(), F?.addEventListener("click", () => { this.openMenu() }), G?.addEventListener("click", () => { this.closeMenu() }) } setMenu() { gsapWithCSS.set(this.itemNameSplitChild.lines, { y: "100%", overwrite: !0 }), gsapWithCSS.set(this.snsNameSplitChild.lines, { y: "100%", overwrite: !0 }) } openMenu() { scrollSet("stop"), this.menu && this.menu[0] && this.menu[0].setAttribute("data-menu", "open"); const F = gsapWithCSS.timeline(); this.setMenu(), F.to(this.menu, { x: "0", pointerEvents: "auto", duration: 1, ease: this.customEase }, "open"), F.to([this.menuDark, this.menu], { x: "0", pointerEvents: "auto", duration: 1, ease: this.customEase }, "open"), F.inTitle(this.itemNameSplitChild.lines, { stagger: .05 }, "open+=0.5"), F.inText(this.snsNameSplitChild.lines, { stagger: .05 }, "open+=1") } closeMenu() { scrollSet("start"), this.menu && this.menu[0] && this.menuDark && this.menu[0].setAttribute("data-menu", "close"); const F = gsapWithCSS.timeline(); F.to(this.menu, { x: "100%", pointerEvents: "none", duration: 1, ease: this.customEase }, "close"), F.to(this.menuDark, { x: "100%", pointerEvents: "none", duration: 1, ease: this.customEase }, "close") } }; gsapWithCSS.registerPlugin(ScrambleTextPlugin); let App$1 = class { constructor() { } init() { if ($$1("[data-loaded]")) return; const F = document.querySelector("[data-mouse]"), G = document.querySelector("[data-mouse-contents]"); let Y = 0, X = 0, K = 0, J = 0, Z = !1; const Q = .01, ee = oe => oe === 1 ? 1 : 1 - Math.pow(2, -10 * oe); document.addEventListener("mousemove", oe => { if (getDeviceType() !== "sp" && !touchOnly() && (Y = oe.clientX, X = oe.clientY, !Z)) { Z = !0; const ie = sessionStorage.getItem("visited") ? .5 : 6.5; gsapWithCSS.to(G, { scale: 1, duration: 1, delay: ie, ease: "power3.inOut" }) } }); const te = () => { K = lerp$1(K, Y, Q, ee), J = lerp$1(J, X, Q, ee), F && (F.style.transform = `translate(${K}px, ${J}px)`), requestAnimationFrame(te) }; te() } }; const ledger = new WeakMap; function editLedger(z, F, G, Y) { if (!z && !ledger.has(F)) return !1; const X = ledger.get(F) ?? new WeakMap; ledger.set(F, X); const K = X.get(G) ?? new Set; X.set(G, K); const J = K.has(Y); return z ? K.add(Y) : K.delete(Y), J && z } function safeClosest(z, F) { let G = z.target; if (G instanceof Text && (G = G.parentElement), G instanceof Element && z.currentTarget instanceof Element) { const Y = G.closest(F); if (Y && z.currentTarget.contains(Y)) return Y } } function delegate(z, F, G, Y = {}) { const { signal: X, base: K = document } = Y; if (X?.aborted) return; const { once: J, ...Z } = Y, Q = K instanceof Document ? K.documentElement : K, ee = !!(typeof Y == "object" ? Y.capture : Y), te = se => { const ne = safeClosest(se, String(z)); if (ne) { const re = Object.assign(se, { delegateTarget: ne }); G.call(Q, re), J && (Q.removeEventListener(F, te, Z), editLedger(!1, Q, G, oe)) } }, oe = JSON.stringify({ selector: z, type: F, capture: ee }); editLedger(!0, Q, G, oe) || Q.addEventListener(F, te, Z), X?.addEventListener("abort", () => { editLedger(!1, Q, G, oe) }) } function lexer(z) { for (var F = [], G = 0; G < z.length;) { var Y = z[G]; if (Y === "*" || Y === "+" || Y === "?") { F.push({ type: "MODIFIER", index: G, value: z[G++] }); continue } if (Y === "\\") { F.push({ type: "ESCAPED_CHAR", index: G++, value: z[G++] }); continue } if (Y === "{") { F.push({ type: "OPEN", index: G, value: z[G++] }); continue } if (Y === "}") { F.push({ type: "CLOSE", index: G, value: z[G++] }); continue } if (Y === ":") { for (var X = "", K = G + 1; K < z.length;) { var J = z.charCodeAt(K); if (J >= 48 && J <= 57 || J >= 65 && J <= 90 || J >= 97 && J <= 122 || J === 95) { X += z[K++]; continue } break } if (!X) throw new TypeError("Missing parameter name at ".concat(G)); F.push({ type: "NAME", index: G, value: X }), G = K; continue } if (Y === "(") { var Z = 1, Q = "", K = G + 1; if (z[K] === "?") throw new TypeError('Pattern cannot start with "?" at '.concat(K)); for (; K < z.length;) { if (z[K] === "\\") { Q += z[K++] + z[K++]; continue } if (z[K] === ")") { if (Z--, Z === 0) { K++; break } } else if (z[K] === "(" && (Z++, z[K + 1] !== "?")) throw new TypeError("Capturing groups are not allowed at ".concat(K)); Q += z[K++] } if (Z) throw new TypeError("Unbalanced pattern at ".concat(G)); if (!Q) throw new TypeError("Missing pattern at ".concat(G)); F.push({ type: "PATTERN", index: G, value: Q }), G = K; continue } F.push({ type: "CHAR", index: G, value: z[G++] }) } return F.push({ type: "END", index: G, value: "" }), F } function parse(z, F) { F === void 0 && (F = {}); for (var G = lexer(z), Y = F.prefixes, X = Y === void 0 ? "./" : Y, K = F.delimiter, J = K === void 0 ? "/#?" : K, Z = [], Q = 0, ee = 0, te = "", oe = function (Se) { if (ee < G.length && G[ee].type === Se) return G[ee++].value }, ie = function (Se) { var ke = oe(Se); if (ke !== void 0) return ke; var Ce = G[ee], Ee = Ce.type, De = Ce.index; throw new TypeError("Unexpected ".concat(Ee, " at ").concat(De, ", expected ").concat(Se)) }, se = function () { for (var Se = "", ke; ke = oe("CHAR") || oe("ESCAPED_CHAR");)Se += ke; return Se }, ne = function (Se) { for (var ke = 0, Ce = J; ke < Ce.length; ke++) { var Ee = Ce[ke]; if (Se.indexOf(Ee) > -1) return !0 } return !1 }, re = function (Se) { var ke = Z[Z.length - 1], Ce = Se || (ke && typeof ke == "string" ? ke : ""); if (ke && !Ce) throw new TypeError('Must have text between two parameters, missing text after "'.concat(ke.name, '"')); return !Ce || ne(Ce) ? "[^".concat(escapeString(J), "]+?") : "(?:(?!".concat(escapeString(Ce), ")[^").concat(escapeString(J), "])+?") }; ee < G.length;) { var fe = oe("CHAR"), ae = oe("NAME"), he = oe("PATTERN"); if (ae || he) { var le = fe || ""; X.indexOf(le) === -1 && (te += le, le = ""), te && (Z.push(te), te = ""), Z.push({ name: ae || Q++, prefix: le, suffix: "", pattern: he || re(le), modifier: oe("MODIFIER") || "" }); continue } var ce = fe || oe("ESCAPED_CHAR"); if (ce) { te += ce; continue } te && (Z.push(te), te = ""); var ue = oe("OPEN"); if (ue) { var le = se(), me = oe("NAME") || "", ge = oe("PATTERN") || "", ve = se(); ie("CLOSE"), Z.push({ name: me || (ge ? Q++ : ""), pattern: me && !ge ? re(le) : ge, prefix: le, suffix: ve, modifier: oe("MODIFIER") || "" }); continue } ie("END") } return Z } function match(z, F) { var G = [], Y = pathToRegexp(z, G, F); return regexpToFunction(Y, G, F) } function regexpToFunction(z, F, G) { G === void 0 && (G = {}); var Y = G.decode, X = Y === void 0 ? function (K) { return K } : Y; return function (K) { var J = z.exec(K); if (!J) return !1; for (var Z = J[0], Q = J.index, ee = Object.create(null), te = function (ie) { if (J[ie] === void 0) return "continue"; var se = F[ie - 1]; se.modifier === "*" || se.modifier === "+" ? ee[se.name] = J[ie].split(se.prefix + se.suffix).map(function (ne) { return X(ne, se) }) : ee[se.name] = X(J[ie], se) }, oe = 1; oe < J.length; oe++)te(oe); return { path: Z, index: Q, params: ee } } } function escapeString(z) { return z.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1") } function flags(z) { return z && z.sensitive ? "" : "i" } function regexpToRegexp(z, F) { if (!F) return z; for (var G = /\((?:\?<(.*?)>)?(?!\?)/g, Y = 0, X = G.exec(z.source); X;)F.push({ name: X[1] || Y++, prefix: "", suffix: "", modifier: "", pattern: "" }), X = G.exec(z.source); return z } function arrayToRegexp(z, F, G) { var Y = z.map(function (X) { return pathToRegexp(X, F, G).source }); return new RegExp("(?:".concat(Y.join("|"), ")"), flags(G)) } function stringToRegexp(z, F, G) { return tokensToRegexp(parse(z, G), F, G) } function tokensToRegexp(z, F, G) { G === void 0 && (G = {}); for (var Y = G.strict, X = Y === void 0 ? !1 : Y, K = G.start, J = K === void 0 ? !0 : K, Z = G.end, Q = Z === void 0 ? !0 : Z, ee = G.encode, te = ee === void 0 ? function (ke) { return ke } : ee, oe = G.delimiter, ie = oe === void 0 ? "/#?" : oe, se = G.endsWith, ne = se === void 0 ? "" : se, re = "[".concat(escapeString(ne), "]|$"), fe = "[".concat(escapeString(ie), "]"), ae = J ? "^" : "", he = 0, le = z; he < le.length; he++) { var ce = le[he]; if (typeof ce == "string") ae += escapeString(te(ce)); else { var ue = escapeString(te(ce.prefix)), me = escapeString(te(ce.suffix)); if (ce.pattern) if (F && F.push(ce), ue || me) if (ce.modifier === "+" || ce.modifier === "*") { var ge = ce.modifier === "*" ? "?" : ""; ae += "(?:".concat(ue, "((?:").concat(ce.pattern, ")(?:").concat(me).concat(ue, "(?:").concat(ce.pattern, "))*)").concat(me, ")").concat(ge) } else ae += "(?:".concat(ue, "(").concat(ce.pattern, ")").concat(me, ")").concat(ce.modifier); else { if (ce.modifier === "+" || ce.modifier === "*") throw new TypeError('Can not repeat "'.concat(ce.name, '" without a prefix and suffix')); ae += "(".concat(ce.pattern, ")").concat(ce.modifier) } else ae += "(?:".concat(ue).concat(me, ")").concat(ce.modifier) } } if (Q) X || (ae += "".concat(fe, "?")), ae += G.endsWith ? "(?=".concat(re, ")") : "$"; else { var ve = z[z.length - 1], Se = typeof ve == "string" ? fe.indexOf(ve[ve.length - 1]) > -1 : ve === void 0; X || (ae += "(?:".concat(fe, "(?=").concat(re, "))?")), Se || (ae += "(?=".concat(fe, "|").concat(re, ")")) } return new RegExp(ae, flags(G)) } function pathToRegexp(z, F, G) { return z instanceof RegExp ? regexpToRegexp(z, F) : Array.isArray(z) ? arrayToRegexp(z, F, G) : stringToRegexp(z, F, G) } function i$1() { return i$1 = Object.assign ? Object.assign.bind() : function (z) { for (var F = 1; F < arguments.length; F++) { var G = arguments[F]; for (var Y in G) ({}).hasOwnProperty.call(G, Y) && (z[Y] = G[Y]) } return z }, i$1.apply(null, arguments) } const s$2 = (z, F) => String(z).toLowerCase().replace(/[\s/_.]+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+|-+$/g, "") || F || "", n$4 = ({ hash: z } = {}) => window.location.pathname + window.location.search + (z ? window.location.hash : ""), o$2 = (z, F = {}) => { const G = i$1({ url: z = z || n$4({ hash: !0 }), random: Math.random(), source: "swup" }, F); window.history.pushState(G, "", z) }, r$4 = (z = null, F = {}) => { z = z || n$4({ hash: !0 }); const G = i$1({}, window.history.state || {}, { url: z, random: Math.random(), source: "swup" }, F); window.history.replaceState(G, "", z) }, a$2 = (z, F, G, Y) => { const X = new AbortController; return Y = i$1({}, Y, { signal: X.signal }), delegate(z, F, G, Y), { destroy: () => X.abort() } }; class l extends URL { constructor(F, G = document.baseURI) { super(F.toString(), G), Object.setPrototypeOf(this, l.prototype) } get url() { return this.pathname + this.search } static fromElement(F) { const G = F.getAttribute("href") || F.getAttribute("xlink:href") || ""; return new l(G) } static fromUrl(F) { return new l(F) } } const h = (z, F) => {
    try { return match(z, F) } catch (G) {
        throw new Error(`[swup] Error parsing path "${String(z)}":
${String(G)}`)
    }
}; class c extends Error { constructor(F, G) { super(F), this.url = void 0, this.status = void 0, this.aborted = void 0, this.timedOut = void 0, this.name = "FetchError", this.url = G.url, this.status = G.status, this.aborted = G.aborted || !1, this.timedOut = G.timedOut || !1 } } async function u(z, F = {}) { var G; z = l.fromUrl(z).url; const { visit: Y = this.visit } = F, X = i$1({}, this.options.requestHeaders, F.headers), K = (G = F.timeout) != null ? G : this.options.timeout, J = new AbortController, { signal: Z } = J; F = i$1({}, F, { headers: X, signal: Z }); let Q, ee = !1, te = null; K && K > 0 && (te = setTimeout(() => { ee = !0, J.abort("timeout") }, K)); try { Q = await this.hooks.call("fetch:request", Y, { url: z, options: F }, (fe, { url: ae, options: he }) => fetch(ae, he)), te && clearTimeout(te) } catch (fe) { throw ee ? (this.hooks.call("fetch:timeout", Y, { url: z }), new c(`Request timed out: ${z}`, { url: z, timedOut: ee })) : fe?.name === "AbortError" || Z.aborted ? new c(`Request aborted: ${z}`, { url: z, aborted: !0 }) : fe } const { status: oe, url: ie } = Q, se = await Q.text(); if (oe === 500) throw this.hooks.call("fetch:error", Y, { status: oe, response: Q, url: ie }), new c(`Server error: ${ie}`, { status: oe, url: ie }); if (!se) throw new c(`Empty response: ${ie}`, { status: oe, url: ie }); const { url: ne } = l.fromUrl(ie), re = { url: ne, html: se }; return !Y.cache.write || F.method && F.method !== "GET" || z !== ne || this.cache.set(re.url, re), re } class d { constructor(F) { this.swup = void 0, this.pages = new Map, this.swup = F } get size() { return this.pages.size } get all() { const F = new Map; return this.pages.forEach((G, Y) => { F.set(Y, i$1({}, G)) }), F } has(F) { return this.pages.has(this.resolve(F)) } get(F) { const G = this.pages.get(this.resolve(F)); return G && i$1({}, G) } set(F, G) { G = i$1({}, G, { url: F = this.resolve(F) }), this.pages.set(F, G), this.swup.hooks.callSync("cache:set", void 0, { page: G }) } update(F, G) { F = this.resolve(F); const Y = i$1({}, this.get(F), G, { url: F }); this.pages.set(F, Y) } delete(F) { this.pages.delete(this.resolve(F)) } clear() { this.pages.clear(), this.swup.hooks.callSync("cache:clear", void 0, void 0) } prune(F) { this.pages.forEach((G, Y) => { F(Y, G) && this.delete(Y) }) } resolve(F) { const { url: G } = l.fromUrl(F); return this.swup.resolveUrl(G) } } const p = (z, F = document) => F.querySelector(z), m = (z, F = document) => Array.from(F.querySelectorAll(z)), w = () => new Promise(z => { requestAnimationFrame(() => { requestAnimationFrame(() => { z() }) }) }); function f(z) { return !!z && (typeof z == "object" || typeof z == "function") && typeof z.then == "function" } function g(z, F = []) { return new Promise((G, Y) => { const X = z(...F); f(X) ? X.then(G, Y) : G(X) }) } function y(z, F) { const G = z?.closest(`[${F}]`); return G != null && G.hasAttribute(F) ? G?.getAttribute(F) || !0 : void 0 } class k { constructor(F) { this.swup = void 0, this.swupClasses = ["to-", "is-changing", "is-rendering", "is-popstate", "is-animating", "is-leaving"], this.swup = F } get selectors() { const { scope: F } = this.swup.visit.animation; return F === "containers" ? this.swup.visit.containers : F === "html" ? ["html"] : Array.isArray(F) ? F : [] } get selector() { return this.selectors.join(",") } get targets() { return this.selector.trim() ? m(this.selector) : [] } add(...F) { this.targets.forEach(G => G.classList.add(...F)) } remove(...F) { this.targets.forEach(G => G.classList.remove(...F)) } clear() { this.targets.forEach(F => { const G = F.className.split(" ").filter(Y => this.isSwupClass(Y)); F.classList.remove(...G) }) } isSwupClass(F) { return this.swupClasses.some(G => F.startsWith(G)) } } class b { constructor(F, G) { this.id = void 0, this.state = void 0, this.from = void 0, this.to = void 0, this.containers = void 0, this.animation = void 0, this.trigger = void 0, this.cache = void 0, this.history = void 0, this.scroll = void 0, this.meta = void 0; const { to: Y, from: X, hash: K, el: J, event: Z } = G; this.id = Math.random(), this.state = 1, this.from = { url: X ?? F.location.url, hash: F.location.hash }, this.to = { url: Y, hash: K }, this.containers = F.options.containers, this.animation = { animate: !0, wait: !1, name: void 0, native: F.options.native, scope: F.options.animationScope, selector: F.options.animationSelector }, this.trigger = { el: J, event: Z }, this.cache = { read: F.options.cache, write: F.options.cache }, this.history = { action: "push", popstate: !1, direction: void 0 }, this.scroll = { reset: !0, target: void 0 }, this.meta = {} } advance(F) { this.state < F && (this.state = F) } abort() { this.state = 8 } get done() { return this.state >= 7 } } function S(z) { return new b(this, z) } class E { constructor(F) { this.swup = void 0, this.registry = new Map, this.hooks = ["animation:out:start", "animation:out:await", "animation:out:end", "animation:in:start", "animation:in:await", "animation:in:end", "animation:skip", "cache:clear", "cache:set", "content:replace", "content:scroll", "enable", "disable", "fetch:request", "fetch:error", "fetch:timeout", "history:popstate", "link:click", "link:self", "link:anchor", "link:newtab", "page:load", "page:view", "scroll:top", "scroll:anchor", "visit:start", "visit:transition", "visit:abort", "visit:end"], this.swup = F, this.init() } init() { this.hooks.forEach(F => this.create(F)) } create(F) { this.registry.has(F) || this.registry.set(F, new Map) } exists(F) { return this.registry.has(F) } get(F) { const G = this.registry.get(F); if (G) return G; console.error(`Unknown hook '${F}'`) } clear() { this.registry.forEach(F => F.clear()) } on(F, G, Y = {}) { const X = this.get(F); if (!X) return console.warn(`Hook '${F}' not found.`), () => { }; const K = i$1({}, Y, { id: X.size + 1, hook: F, handler: G }); return X.set(G, K), () => this.off(F, G) } before(F, G, Y = {}) { return this.on(F, G, i$1({}, Y, { before: !0 })) } replace(F, G, Y = {}) { return this.on(F, G, i$1({}, Y, { replace: !0 })) } once(F, G, Y = {}) { return this.on(F, G, i$1({}, Y, { once: !0 })) } off(F, G) { const Y = this.get(F); Y && G ? Y.delete(G) || console.warn(`Handler for hook '${F}' not found.`) : Y && Y.clear() } async call(F, G, Y, X) { const [K, J, Z] = this.parseCallArgs(F, G, Y, X), { before: Q, handler: ee, after: te } = this.getHandlers(F, Z); await this.run(Q, K, J); const [oe] = await this.run(ee, K, J, !0); return await this.run(te, K, J), this.dispatchDomEvent(F, K, J), oe } callSync(F, G, Y, X) { const [K, J, Z] = this.parseCallArgs(F, G, Y, X), { before: Q, handler: ee, after: te } = this.getHandlers(F, Z); this.runSync(Q, K, J); const [oe] = this.runSync(ee, K, J, !0); return this.runSync(te, K, J), this.dispatchDomEvent(F, K, J), oe } parseCallArgs(F, G, Y, X) { return G instanceof b || typeof G != "object" && typeof Y != "function" ? [G, Y, X] : [void 0, G, Y] } async run(F, G = this.swup.visit, Y, X = !1) { const K = []; for (const { hook: J, handler: Z, defaultHandler: Q, once: ee } of F) if (G == null || !G.done) { ee && this.off(J, Z); try { const te = await g(Z, [G, Y, Q]); K.push(te) } catch (te) { if (X) throw te; console.error(`Error in hook '${J}':`, te) } } return K } runSync(F, G = this.swup.visit, Y, X = !1) { const K = []; for (const { hook: J, handler: Z, defaultHandler: Q, once: ee } of F) if (G == null || !G.done) { ee && this.off(J, Z); try { const te = Z(G, Y, Q); K.push(te), f(te) && console.warn(`Swup will not await Promises in handler for synchronous hook '${J}'.`) } catch (te) { if (X) throw te; console.error(`Error in hook '${J}':`, te) } } return K } getHandlers(F, G) { const Y = this.get(F); if (!Y) return { found: !1, before: [], handler: [], after: [], replaced: !1 }; const X = Array.from(Y.values()), K = this.sortRegistrations, J = X.filter(({ before: oe, replace: ie }) => oe && !ie).sort(K), Z = X.filter(({ replace: oe }) => oe).filter(oe => !0).sort(K), Q = X.filter(({ before: oe, replace: ie }) => !oe && !ie).sort(K), ee = Z.length > 0; let te = []; if (G && (te = [{ id: 0, hook: F, handler: G }], ee)) { const oe = Z.length - 1, { handler: ie, once: se } = Z[oe], ne = re => { const fe = Z[re - 1]; return fe ? (ae, he) => fe.handler(ae, he, ne(re - 1)) : G }; te = [{ id: 0, hook: F, once: se, handler: ie, defaultHandler: ne(oe) }] } return { found: !0, before: J, handler: te, after: Q, replaced: ee } } sortRegistrations(F, G) { var Y, X; return ((Y = F.priority) != null ? Y : 0) - ((X = G.priority) != null ? X : 0) || F.id - G.id || 0 } dispatchDomEvent(F, G, Y) { if (G != null && G.done) return; const X = { hook: F, args: Y, visit: G || this.swup.visit }; document.dispatchEvent(new CustomEvent("swup:any", { detail: X, bubbles: !0 })), document.dispatchEvent(new CustomEvent(`swup:${F}`, { detail: X, bubbles: !0 })) } parseName(F) { const [G, ...Y] = F.split("."); return [G, Y.reduce((X, K) => i$1({}, X, { [K]: !0 }), {})] } } const C = z => { if (z && z.charAt(0) === "#" && (z = z.substring(1)), !z) return null; const F = decodeURIComponent(z); let G = document.getElementById(z) || document.getElementById(F) || p(`a[name='${CSS.escape(z)}']`) || p(`a[name='${CSS.escape(F)}']`); return G || z !== "top" || (G = document.body), G }, U = "transition", P = "animation"; async function $({ selector: z, elements: F }) { if (z === !1 && !F) return; let G = []; if (F) G = Array.from(F); else if (z && (G = m(z, document.body), !G.length)) return void console.warn(`[swup] No elements found matching animationSelector \`${z}\``); const Y = G.map(X => function (K) { const { type: J, timeout: Z, propCount: Q } = function (ee) { const te = window.getComputedStyle(ee), oe = x(te, `${U}Delay`), ie = x(te, `${U}Duration`), se = A(oe, ie), ne = x(te, `${P}Delay`), re = x(te, `${P}Duration`), fe = A(ne, re), ae = Math.max(se, fe), he = ae > 0 ? se > fe ? U : P : null; return { type: he, timeout: ae, propCount: he ? he === U ? ie.length : re.length : 0 } }(K); return !(!J || !Z) && new Promise(ee => { const te = `${J}end`, oe = performance.now(); let ie = 0; const se = () => { K.removeEventListener(te, ne), ee() }, ne = re => { re.target === K && ((performance.now() - oe) / 1e3 < re.elapsedTime || ++ie >= Q && se()) }; setTimeout(() => { ie < Q && se() }, Z + 1), K.addEventListener(te, ne) }) }(X)); Y.filter(Boolean).length > 0 ? await Promise.all(Y) : z && console.warn(`[swup] No CSS animation duration defined on elements matching \`${z}\``) } function x(z, F) { return (z[F] || "").split(", ") } function A(z, F) { for (; z.length < F.length;)z = z.concat(z); return Math.max(...F.map((G, Y) => H(G) + H(z[Y]))) } function H(z) { return 1e3 * parseFloat(z) } function V(z, F = {}, G = {}) { if (typeof z != "string") throw new Error("swup.navigate() requires a URL parameter"); if (this.shouldIgnoreVisit(z, { el: G.el, event: G.event })) return void window.location.assign(z); const { url: Y, hash: X } = l.fromUrl(z), K = this.createVisit(i$1({}, G, { to: Y, hash: X })); this.performNavigation(K, F) } async function I(z, F = {}) { if (this.navigating) { if (this.visit.state >= 6) return z.state = 2, void (this.onVisitEnd = () => this.performNavigation(z, F)); await this.hooks.call("visit:abort", this.visit, void 0), delete this.visit.to.document, this.visit.state = 8 } this.navigating = !0, this.visit = z; const { el: G } = z.trigger; F.referrer = F.referrer || this.location.url, F.animate === !1 && (z.animation.animate = !1), z.animation.animate || this.classes.clear(); const Y = F.history || y(G, "data-swup-history"); typeof Y == "string" && ["push", "replace"].includes(Y) && (z.history.action = Y); const X = F.animation || y(G, "data-swup-animation"); var K, J; typeof X == "string" && (z.animation.name = X), z.meta = F.meta || {}, typeof F.cache == "object" ? (z.cache.read = (K = F.cache.read) != null ? K : z.cache.read, z.cache.write = (J = F.cache.write) != null ? J : z.cache.write) : F.cache !== void 0 && (z.cache = { read: !!F.cache, write: !!F.cache }), delete F.cache; try { await this.hooks.call("visit:start", z, void 0), z.state = 3; const Z = this.hooks.call("page:load", z, { options: F }, async (ee, te) => { let oe; return ee.cache.read && (oe = this.cache.get(ee.to.url)), te.page = oe || await this.fetchPage(ee.to.url, te.options), te.cache = !!oe, te.page }); Z.then(({ html: ee }) => { z.advance(5), z.to.html = ee, z.to.document = new DOMParser().parseFromString(ee, "text/html") }); const Q = z.to.url + z.to.hash; if (z.history.popstate || (z.history.action === "replace" || z.to.url === this.location.url ? r$4(Q) : (this.currentHistoryIndex++, o$2(Q, { index: this.currentHistoryIndex }))), this.location = l.fromUrl(Q), z.history.popstate && this.classes.add("is-popstate"), z.animation.name && this.classes.add(`to-${s$2(z.animation.name)}`), z.animation.wait && await Z, z.done || (await this.hooks.call("visit:transition", z, void 0, async () => { if (!z.animation.animate) return await this.hooks.call("animation:skip", void 0), void await this.renderPage(z, await Z); z.advance(4), await this.animatePageOut(z), z.animation.native && document.startViewTransition ? await document.startViewTransition(async () => await this.renderPage(z, await Z)).finished : await this.renderPage(z, await Z), await this.animatePageIn(z) }), z.done)) return; await this.hooks.call("visit:end", z, void 0, () => this.classes.clear()), z.state = 7, this.navigating = !1, this.onVisitEnd && (this.onVisitEnd(), this.onVisitEnd = void 0) } catch (Z) { if (!Z || Z != null && Z.aborted) return void (z.state = 8); z.state = 9, console.error(Z), this.options.skipPopStateHandling = () => (window.location.assign(z.to.url + z.to.hash), !0), window.history.back() } finally { delete z.to.document } } const L = async function (z) { await this.hooks.call("animation:out:start", z, void 0, () => { this.classes.add("is-changing", "is-animating", "is-leaving") }), await this.hooks.call("animation:out:await", z, { skip: !1 }, (F, { skip: G }) => { if (!G) return this.awaitAnimations({ selector: F.animation.selector }) }), await this.hooks.call("animation:out:end", z, void 0) }, q = function (z) { var F; const G = z.to.document; if (!G) return !1; const Y = ((F = G.querySelector("title")) == null ? void 0 : F.innerText) || ""; document.title = Y; const X = m('[data-swup-persist]:not([data-swup-persist=""])'), K = z.containers.map(J => { const Z = document.querySelector(J), Q = G.querySelector(J); return Z && Q ? (Z.replaceWith(Q.cloneNode(!0)), !0) : (Z || console.warn(`[swup] Container missing in current document: ${J}`), Q || console.warn(`[swup] Container missing in incoming document: ${J}`), !1) }).filter(Boolean); return X.forEach(J => { const Z = J.getAttribute("data-swup-persist"), Q = p(`[data-swup-persist="${Z}"]`); Q && Q !== J && Q.replaceWith(J) }), K.length === z.containers.length }, R = function (z) { const F = { behavior: "auto" }, { target: G, reset: Y } = z.scroll, X = G ?? z.to.hash; let K = !1; return X && (K = this.hooks.callSync("scroll:anchor", z, { hash: X, options: F }, (J, { hash: Z, options: Q }) => { const ee = this.getAnchorElement(Z); return ee && ee.scrollIntoView(Q), !!ee })), Y && !K && (K = this.hooks.callSync("scroll:top", z, { options: F }, (J, { options: Z }) => (window.scrollTo(i$1({ top: 0, left: 0 }, Z)), !0))), K }, T = async function (z) { if (z.done) return; const F = this.hooks.call("animation:in:await", z, { skip: !1 }, (G, { skip: Y }) => { if (!Y) return this.awaitAnimations({ selector: G.animation.selector }) }); await w(), await this.hooks.call("animation:in:start", z, void 0, () => { this.classes.remove("is-animating") }), await F, await this.hooks.call("animation:in:end", z, void 0) }, N = async function (z, F) { if (z.done) return; z.advance(6); const { url: G } = F; this.isSameResolvedUrl(n$4(), G) || (r$4(G), this.location = l.fromUrl(G), z.to.url = this.location.url, z.to.hash = this.location.hash), await this.hooks.call("content:replace", z, { page: F }, (Y, { }) => { if (this.classes.remove("is-leaving"), Y.animation.animate && this.classes.add("is-rendering"), !this.replaceContent(Y)) throw new Error("[swup] Container mismatch, aborting"); Y.animation.animate && (this.classes.add("is-changing", "is-animating", "is-rendering"), Y.animation.name && this.classes.add(`to-${s$2(Y.animation.name)}`)) }), await this.hooks.call("content:scroll", z, void 0, () => this.scrollToContent(z)), await this.hooks.call("page:view", z, { url: this.location.url, title: document.title }) }, O = function (z) { var F; if (F = z, !!F?.isSwupPlugin) { if (z.swup = this, !z._checkRequirements || z._checkRequirements()) return z._beforeMount && z._beforeMount(), z.mount(), this.plugins.push(z), this.plugins } else console.error("Not a swup plugin instance", z) }; function D(z) { const F = this.findPlugin(z); if (F) return F.unmount(), F._afterUnmount && F._afterUnmount(), this.plugins = this.plugins.filter(G => G !== F), this.plugins; console.error("No such plugin", F) } function M(z) { return this.plugins.find(F => F === z || F.name === z || F.name === `Swup${String(z)}`) } function W(z) { if (typeof this.options.resolveUrl != "function") return console.warn("[swup] options.resolveUrl expects a callback function."), z; const F = this.options.resolveUrl(z); return F && typeof F == "string" ? F.startsWith("//") || F.startsWith("http") ? (console.warn("[swup] options.resolveUrl needs to return a relative url"), z) : F : (console.warn("[swup] options.resolveUrl needs to return a url"), z) } function B(z, F) { return this.resolveUrl(z) === this.resolveUrl(F) } const j = { animateHistoryBrowsing: !1, animationSelector: '[class*="transition-"]', animationScope: "html", cache: !0, containers: ["#swup"], hooks: {}, ignoreVisit: (z, { el: F } = {}) => !(F == null || !F.closest("[data-no-swup]")), linkSelector: "a[href]", linkToSelf: "scroll", native: !1, plugins: [], resolveUrl: z => z, requestHeaders: { "X-Requested-With": "swup", Accept: "text/html, application/xhtml+xml" }, skipPopStateHandling: z => { var F; return ((F = z.state) == null ? void 0 : F.source) !== "swup" }, timeout: 0 }; class _ { get currentPageUrl() { return this.location.url } constructor(F = {}) { var G, Y; this.version = "4.8.1", this.options = void 0, this.defaults = j, this.plugins = [], this.visit = void 0, this.cache = void 0, this.hooks = void 0, this.classes = void 0, this.location = l.fromUrl(window.location.href), this.currentHistoryIndex = void 0, this.clickDelegate = void 0, this.navigating = !1, this.onVisitEnd = void 0, this.use = O, this.unuse = D, this.findPlugin = M, this.log = () => { }, this.navigate = V, this.performNavigation = I, this.createVisit = S, this.delegateEvent = a$2, this.fetchPage = u, this.awaitAnimations = $, this.renderPage = N, this.replaceContent = q, this.animatePageIn = T, this.animatePageOut = L, this.scrollToContent = R, this.getAnchorElement = C, this.getCurrentUrl = n$4, this.resolveUrl = W, this.isSameResolvedUrl = B, this.options = i$1({}, this.defaults, F), this.handleLinkClick = this.handleLinkClick.bind(this), this.handlePopState = this.handlePopState.bind(this), this.cache = new d(this), this.classes = new k(this), this.hooks = new E(this), this.visit = this.createVisit({ to: "" }), this.currentHistoryIndex = (G = (Y = window.history.state) == null ? void 0 : Y.index) != null ? G : 1, this.enable() } async enable() { var F; const { linkSelector: G } = this.options; this.clickDelegate = this.delegateEvent(G, "click", this.handleLinkClick), window.addEventListener("popstate", this.handlePopState), this.options.animateHistoryBrowsing && (window.history.scrollRestoration = "manual"), this.options.native = this.options.native && !!document.startViewTransition, this.options.plugins.forEach(Y => this.use(Y)); for (const [Y, X] of Object.entries(this.options.hooks)) { const [K, J] = this.hooks.parseName(Y); this.hooks.on(K, X, J) } ((F = window.history.state) == null ? void 0 : F.source) !== "swup" && r$4(null, { index: this.currentHistoryIndex }), await w(), await this.hooks.call("enable", void 0, void 0, () => { const Y = document.documentElement; Y.classList.add("swup-enabled"), Y.classList.toggle("swup-native", this.options.native) }) } async destroy() { this.clickDelegate.destroy(), window.removeEventListener("popstate", this.handlePopState), this.cache.clear(), this.options.plugins.forEach(F => this.unuse(F)), await this.hooks.call("disable", void 0, void 0, () => { const F = document.documentElement; F.classList.remove("swup-enabled"), F.classList.remove("swup-native") }), this.hooks.clear() } shouldIgnoreVisit(F, { el: G, event: Y } = {}) { const { origin: X, url: K, hash: J } = l.fromUrl(F); return X !== window.location.origin || !(!G || !this.triggerWillOpenNewWindow(G)) || !!this.options.ignoreVisit(K + J, { el: G, event: Y }) } handleLinkClick(F) { const G = F.delegateTarget, { href: Y, url: X, hash: K } = l.fromElement(G); if (this.shouldIgnoreVisit(Y, { el: G, event: F })) return; if (this.navigating && X === this.visit.to.url) return void F.preventDefault(); const J = this.createVisit({ to: X, hash: K, el: G, event: F }); F.metaKey || F.ctrlKey || F.shiftKey || F.altKey ? this.hooks.callSync("link:newtab", J, { href: Y }) : F.button === 0 && this.hooks.callSync("link:click", J, { el: G, event: F }, () => { var Z; const Q = (Z = J.from.url) != null ? Z : ""; F.preventDefault(), X && X !== Q ? this.isSameResolvedUrl(X, Q) || this.performNavigation(J) : K ? this.hooks.callSync("link:anchor", J, { hash: K }, () => { r$4(X + K), this.scrollToContent(J) }) : this.hooks.callSync("link:self", J, void 0, () => { this.options.linkToSelf === "navigate" ? this.performNavigation(J) : (r$4(X), this.scrollToContent(J)) }) }) } handlePopState(F) { var G, Y, X, K; const J = (G = (Y = F.state) == null ? void 0 : Y.url) != null ? G : window.location.href; if (this.options.skipPopStateHandling(F) || this.isSameResolvedUrl(n$4(), this.location.url)) return; const { url: Z, hash: Q } = l.fromUrl(J), ee = this.createVisit({ to: Z, hash: Q, event: F }); ee.history.popstate = !0; const te = (X = (K = F.state) == null ? void 0 : K.index) != null ? X : 0; te && te !== this.currentHistoryIndex && (ee.history.direction = te - this.currentHistoryIndex > 0 ? "forwards" : "backwards", this.currentHistoryIndex = te), ee.animation.animate = !1, ee.scroll.reset = !1, ee.scroll.target = !1, this.options.animateHistoryBrowsing && (ee.animation.animate = !0, ee.scroll.reset = !0), this.hooks.callSync("history:popstate", ee, { event: F }, () => { this.performNavigation(ee) }) } triggerWillOpenNewWindow(F) { return !!F.matches('[download], [target="_blank"]') } } function r$3() { return r$3 = Object.assign ? Object.assign.bind() : function (z) { for (var F = 1; F < arguments.length; F++) { var G = arguments[F]; for (var Y in G) Object.prototype.hasOwnProperty.call(G, Y) && (z[Y] = G[Y]) } return z }, r$3.apply(this, arguments) } const n$3 = z => String(z).split(".").map(F => String(parseInt(F || "0", 10))).concat(["0", "0"]).slice(0, 3).join("."); let e$3 = class { constructor() { this.isSwupPlugin = !0, this.swup = void 0, this.version = void 0, this.requires = {}, this.handlersToUnregister = [] } mount() { } unmount() { this.handlersToUnregister.forEach(F => F()), this.handlersToUnregister = [] } _beforeMount() { if (!this.name) throw new Error("You must define a name of plugin when creating a class.") } _afterUnmount() { } _checkRequirements() { return typeof this.requires != "object" || Object.entries(this.requires).forEach(([F, G]) => { if (!function (Y, X, K) { const J = function (Z, Q) { var ee; if (Z === "swup") return (ee = Q.version) != null ? ee : ""; { var te; const oe = Q.findPlugin(Z); return (te = oe?.version) != null ? te : "" } }(Y, K); return !!J && ((Z, Q) => Q.every(ee => { const [, te, oe] = ee.match(/^([\D]+)?(.*)$/) || []; var ie, se; return ((ne, re) => { const fe = { "": ae => ae === 0, ">": ae => ae > 0, ">=": ae => ae >= 0, "<": ae => ae < 0, "<=": ae => ae <= 0 }; return (fe[re] || fe[""])(ne) })((se = oe, ie = n$3(ie = Z), se = n$3(se), ie.localeCompare(se, void 0, { numeric: !0 })), te || ">=") }))(J, X) }(F, G = Array.isArray(G) ? G : [G], this.swup)) { const Y = `${F} ${G.join(", ")}`; throw new Error(`Plugin version mismatch: ${this.name} requires ${Y}`) } }), !0 } on(F, G, Y = {}) { var X; G = !(X = G).name.startsWith("bound ") || X.hasOwnProperty("prototype") ? G.bind(this) : G; const K = this.swup.hooks.on(F, G, Y); return this.handlersToUnregister.push(K), K } once(F, G, Y = {}) { return this.on(F, G, r$3({}, Y, { once: !0 })) } before(F, G, Y = {}) { return this.on(F, G, r$3({}, Y, { before: !0 })) } replace(F, G, Y = {}) { return this.on(F, G, r$3({}, Y, { replace: !0 })) } off(F, G) { return this.swup.hooks.off(F, G) } }; function o$1() { return o$1 = Object.assign ? Object.assign.bind() : function (z) { for (var F = 1; F < arguments.length; F++) { var G = arguments[F]; for (var Y in G) Object.prototype.hasOwnProperty.call(G, Y) && (z[Y] = G[Y]) } return z }, o$1.apply(this, arguments) } const a$1 = { from: "(.*)", to: "(.*)", out: z => z(), in: z => z() }; let s$1 = class extends e$3 { constructor(F) { var G, Y; super(), G = this, this.name = "SwupJsPlugin", this.requires = { swup: ">=4" }, this.defaults = { animations: [], matchOptions: {} }, this.options = void 0, this.animations = [], this.awaitOutAnimation = async function (X, { skip: K }) { K || await G.findAndRunAnimation(X, "out") }, this.awaitInAnimation = async function (X, { skip: K }) { K || await G.findAndRunAnimation(X, "in") }, Array.isArray(F) && (F = { animations: F }), this.options = o$1({}, this.defaults, F), this.options.animations.push(a$1), this.animations = (Y = this.options.matchOptions, this.options.animations.map(X => function (K, J) { return o$1({}, K, { matchesFrom: h(K.from, J), matchesTo: h(K.to, J) }) }(X, Y))) } mount() { this.replace("animation:out:await", this.awaitOutAnimation, { priority: -1 }), this.replace("animation:in:await", this.awaitInAnimation, { priority: -1 }) } async findAndRunAnimation(F, G) { const Y = function (X, K) { return function (J, Z, Q, ee) { let te = 0; return J.reduceRight((ie, se) => { const ne = function (re, fe, ae, he) { let le = 0; const ce = re.matchesFrom(fe); return ce && (le += 1), re.matchesTo(ae) && (le += 1), ce && re.to === he && (le += 2), le }(se, Z, Q, ee); return ne >= te ? (te = ne, se) : ie }, null) }(X, K.from.url, K.to.url, K.animation.name) }(this.animations, F); if (Y) { const X = function (K, J, Z) { const Q = K.matchesFrom(J.from.url), ee = K.matchesTo(J.to.url); return { visit: J, direction: Z, from: { url: J.from.url, pattern: K.from, params: Q ? Q.params : {} }, to: { url: J.to.url, pattern: K.to, params: ee ? ee.params : {} } } }(Y, F, G); await function (K, J) { const { direction: Z } = J, Q = K[Z]; return Q ? new Promise(ee => { const te = Q(() => ee(), J); f(te) && te.then(ee) }) : (console.warn(`Missing animation function for '${Z}' phase`), Promise.resolve()) }(Y, X) } } }; function r$2() { return r$2 = Object.assign ? Object.assign.bind() : function (z) { for (var F = 1; F < arguments.length; F++) { var G = arguments[F]; for (var Y in G) Object.prototype.hasOwnProperty.call(G, Y) && (z[Y] = G[Y]) } return z }, r$2.apply(this, arguments) } const n$2 = z => String(z).split(".").map(F => String(parseInt(F || "0", 10))).concat(["0", "0"]).slice(0, 3).join("."); let e$2 = class { constructor() { this.isSwupPlugin = !0, this.swup = void 0, this.version = void 0, this.requires = {}, this.handlersToUnregister = [] } mount() { } unmount() { this.handlersToUnregister.forEach(F => F()), this.handlersToUnregister = [] } _beforeMount() { if (!this.name) throw new Error("You must define a name of plugin when creating a class.") } _afterUnmount() { } _checkRequirements() { return typeof this.requires != "object" || Object.entries(this.requires).forEach(([F, G]) => { if (!function (Y, X, K) { const J = function (Z, Q) { var ee; if (Z === "swup") return (ee = Q.version) != null ? ee : ""; { var te; const oe = Q.findPlugin(Z); return (te = oe?.version) != null ? te : "" } }(Y, K); return !!J && ((Z, Q) => Q.every(ee => { const [, te, oe] = ee.match(/^([\D]+)?(.*)$/) || []; var ie, se; return ((ne, re) => { const fe = { "": ae => ae === 0, ">": ae => ae > 0, ">=": ae => ae >= 0, "<": ae => ae < 0, "<=": ae => ae <= 0 }; return (fe[re] || fe[""])(ne) })((se = oe, ie = n$2(ie = Z), se = n$2(se), ie.localeCompare(se, void 0, { numeric: !0 })), te || ">=") }))(J, X) }(F, G = Array.isArray(G) ? G : [G], this.swup)) { const Y = `${F} ${G.join(", ")}`; throw new Error(`Plugin version mismatch: ${this.name} requires ${Y}`) } }), !0 } on(F, G, Y = {}) { var X; G = !(X = G).name.startsWith("bound ") || X.hasOwnProperty("prototype") ? G.bind(this) : G; const K = this.swup.hooks.on(F, G, Y); return this.handlersToUnregister.push(K), K } once(F, G, Y = {}) { return this.on(F, G, r$2({}, Y, { once: !0 })) } before(F, G, Y = {}) { return this.on(F, G, r$2({}, Y, { before: !0 })) } replace(F, G, Y = {}) { return this.on(F, G, r$2({}, Y, { replace: !0 })) } off(F, G) { return this.swup.hooks.off(F, G) } }; function t() { return t = Object.assign ? Object.assign.bind() : function (z) { for (var F = 1; F < arguments.length; F++) { var G = arguments[F]; for (var Y in G) ({}).hasOwnProperty.call(G, Y) && (z[Y] = G[Y]) } return z }, t.apply(null, arguments) } function s(z) { return z.localName !== "title" && !z.matches("[data-swup-theme]") } function n$1(z, F) { return z.outerHTML === F.outerHTML } function r$1(z, F = []) { const G = Array.from(z.attributes); return F.length ? G.filter(({ name: Y }) => F.some(X => X instanceof RegExp ? X.test(Y) : Y === X)) : G } function o(z) { return z.matches("link[rel=stylesheet][href]") } class i extends e$2 { constructor(F = {}) { var G; super(), G = this, this.name = "SwupHeadPlugin", this.requires = { swup: ">=4.6" }, this.defaults = { persistTags: !1, persistAssets: !1, awaitAssets: !1, attributes: ["lang", "dir"], timeout: 3e3 }, this.options = void 0, this.updateHead = async function (Y, { page: { } }) { const { awaitAssets: X, attributes: K, timeout: J } = G.options, Z = Y.to.document, { removed: Q, added: ee } = function (te, oe, { shouldPersist: ie = () => !1 } = {}) { const se = Array.from(te.children), ne = Array.from(oe.children), re = (fe = se, ne.reduce((le, ce, ue) => (fe.some(me => n$1(ce, me)) || le.push({ el: ce, index: ue }), le), [])); var fe; const ae = function (le, ce) { return le.reduce((ue, me) => (ce.some(ge => n$1(me, ge)) || ue.push({ el: me }), ue), []) }(se, ne); ae.reverse().filter(({ el: le }) => s(le)).filter(({ el: le }) => !ie(le)).forEach(({ el: le }) => te.removeChild(le)); const he = re.filter(({ el: le }) => s(le)).map(le => { let ce = le.el.cloneNode(!0); return te.insertBefore(ce, te.children[(le.index || 0) + 1] || null), t({}, le, { el: ce }) }); return { removed: ae.map(({ el: le }) => le), added: he.map(({ el: le }) => le) } }(document.head, Z.head, { shouldPersist: te => G.isPersistentTag(te) }); if (G.swup.log(`Removed ${Q.length} / added ${ee.length} tags in head`), K != null && K.length && function (te, oe, ie = []) { const se = new Set; for (const { name: ne, value: re } of r$1(oe, ie)) te.setAttribute(ne, re), se.add(ne); for (const { name: ne } of r$1(te, ie)) se.has(ne) || te.removeAttribute(ne) }(document.documentElement, Z.documentElement, K), X) { const te = function (oe, ie = 0) { return oe.filter(o).map(se => function (ne, re = 0) { let fe; const ae = he => { ne.sheet ? he() : fe = setTimeout(() => ae(he), 10) }; return new Promise(he => { ae(() => he(ne)), re > 0 && setTimeout(() => { fe && clearTimeout(fe), he(ne) }, re) }) }(se, ie)) }(ee, J); te.length && (G.swup.log(`Waiting for ${te.length} assets to load`), await Promise.all(te)) } }, this.options = t({}, this.defaults, F), this.options.persistAssets && !this.options.persistTags && (this.options.persistTags = "link[rel=stylesheet], script[src], style") } mount() { this.before("content:replace", this.updateHead) } isPersistentTag(F) { const { persistTags: G } = this.options; return typeof G == "function" ? G(F) : typeof G == "string" && G.length > 0 ? F.matches(G) : !!G } } function r() { return r = Object.assign ? Object.assign.bind() : function (z) { for (var F = 1; F < arguments.length; F++) { var G = arguments[F]; for (var Y in G) Object.prototype.hasOwnProperty.call(G, Y) && (z[Y] = G[Y]) } return z }, r.apply(this, arguments) } const n = z => String(z).split(".").map(F => String(parseInt(F || "0", 10))).concat(["0", "0"]).slice(0, 3).join("."); let e$1 = class { constructor() { this.isSwupPlugin = !0, this.swup = void 0, this.version = void 0, this.requires = {}, this.handlersToUnregister = [] } mount() { } unmount() { this.handlersToUnregister.forEach(F => F()), this.handlersToUnregister = [] } _beforeMount() { if (!this.name) throw new Error("You must define a name of plugin when creating a class.") } _afterUnmount() { } _checkRequirements() { return typeof this.requires != "object" || Object.entries(this.requires).forEach(([F, G]) => { if (!function (Y, X, K) { const J = function (Z, Q) { var ee; if (Z === "swup") return (ee = Q.version) != null ? ee : ""; { var te; const oe = Q.findPlugin(Z); return (te = oe?.version) != null ? te : "" } }(Y, K); return !!J && ((Z, Q) => Q.every(ee => { const [, te, oe] = ee.match(/^([\D]+)?(.*)$/) || []; var ie, se; return ((ne, re) => { const fe = { "": ae => ae === 0, ">": ae => ae > 0, ">=": ae => ae >= 0, "<": ae => ae < 0, "<=": ae => ae <= 0 }; return (fe[re] || fe[""])(ne) })((se = oe, ie = n(ie = Z), se = n(se), ie.localeCompare(se, void 0, { numeric: !0 })), te || ">=") }))(J, X) }(F, G = Array.isArray(G) ? G : [G], this.swup)) { const Y = `${F} ${G.join(", ")}`; throw new Error(`Plugin version mismatch: ${this.name} requires ${Y}`) } }), !0 } on(F, G, Y = {}) { var X; G = !(X = G).name.startsWith("bound ") || X.hasOwnProperty("prototype") ? G.bind(this) : G; const K = this.swup.hooks.on(F, G, Y); return this.handlersToUnregister.push(K), K } once(F, G, Y = {}) { return this.on(F, G, r({}, Y, { once: !0 })) } before(F, G, Y = {}) { return this.on(F, G, r({}, Y, { before: !0 })) } replace(F, G, Y = {}) { return this.on(F, G, r({}, Y, { replace: !0 })) } off(F, G) { return this.swup.hooks.off(F, G) } }; function e() { return e = Object.assign ? Object.assign.bind() : function (z) { for (var F = 1; F < arguments.length; F++) { var G = arguments[F]; for (var Y in G) Object.prototype.hasOwnProperty.call(G, Y) && (z[Y] = G[Y]) } return z }, e.apply(this, arguments) } class a extends e$1 { constructor(F = {}) { super(), this.name = "SwupGaPlugin", this.requires = { swup: ">=4" }, this.defaults = { gaMeasurementId: null }, this.options = e({}, this.defaults, F) } mount() { this.on("page:view", this.trackPageView) } trackPageView() { const F = document.title, G = window.location.pathname + window.location.search; typeof window.gtag == "function" ? (this.trackPageViewInGtag({ title: F, url: G }), this.swup.log(`GA page view: ${G} (gtag.js)`)) : typeof window.ga == "function" ? (this.trackPageViewInGa({ title: F, url: G }), this.swup.log(`GA page view: ${G} (analytics.js)`)) : console.warn("Neither window.gtag nor window.ga are present on the page") } trackPageViewInGtag({ title: F, url: G }) { const { gaMeasurementId: Y } = this.options; Y ? window.gtag("config", Y, { page_title: F, page_path: G }) : console.error("The gaMeasurementId option is required for gtag.js") } trackPageViewInGa({ title: F, url: G }) { window.ga("set", "title", F), window.ga("set", "page", G), window.ga("send", "pageview") } } var version = "1.2.3"; function clamp(z, F, G) { return Math.max(z, Math.min(F, G)) } function lerp(z, F, G) { return (1 - G) * z + G * F } function damp(z, F, G, Y) { return lerp(z, F, 1 - Math.exp(-G * Y)) } function modulo(z, F) { return (z % F + F) % F } var Animate = class { isRunning = !1; value = 0; from = 0; to = 0; currentTime = 0; lerp; duration; easing; onUpdate; advance(z) { if (!this.isRunning) return; let F = !1; if (this.duration && this.easing) { this.currentTime += z; const G = clamp(0, this.currentTime / this.duration, 1); F = G >= 1; const Y = F ? 1 : this.easing(G); this.value = this.from + (this.to - this.from) * Y } else this.lerp ? (this.value = damp(this.value, this.to, this.lerp * 60, z), Math.round(this.value) === this.to && (this.value = this.to, F = !0)) : (this.value = this.to, F = !0); F && this.stop(), this.onUpdate?.(this.value, F) } stop() { this.isRunning = !1 } fromTo(z, F, { lerp: G, duration: Y, easing: X, onStart: K, onUpdate: J }) { this.from = this.value = z, this.to = F, this.lerp = G, this.duration = Y, this.easing = X, this.currentTime = 0, this.isRunning = !0, K?.(), this.onUpdate = J } }; function debounce(z, F) { let G; return function (...Y) { let X = this; clearTimeout(G), G = setTimeout(() => { G = void 0, z.apply(X, Y) }, F) } } var Dimensions = class { constructor(z, F, { autoResize: G = !0, debounce: Y = 250 } = {}) { this.wrapper = z, this.content = F, G && (this.debouncedResize = debounce(this.resize, Y), this.wrapper instanceof Window ? window.addEventListener("resize", this.debouncedResize, !1) : (this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize), this.wrapperResizeObserver.observe(this.wrapper)), this.contentResizeObserver = new ResizeObserver(this.debouncedResize), this.contentResizeObserver.observe(this.content)), this.resize() } width = 0; height = 0; scrollHeight = 0; scrollWidth = 0; debouncedResize; wrapperResizeObserver; contentResizeObserver; destroy() { this.wrapperResizeObserver?.disconnect(), this.contentResizeObserver?.disconnect(), this.wrapper === window && this.debouncedResize && window.removeEventListener("resize", this.debouncedResize, !1) } resize = () => { this.onWrapperResize(), this.onContentResize() }; onWrapperResize = () => { this.wrapper instanceof Window ? (this.width = window.innerWidth, this.height = window.innerHeight) : (this.width = this.wrapper.clientWidth, this.height = this.wrapper.clientHeight) }; onContentResize = () => { this.wrapper instanceof Window ? (this.scrollHeight = this.content.scrollHeight, this.scrollWidth = this.content.scrollWidth) : (this.scrollHeight = this.wrapper.scrollHeight, this.scrollWidth = this.wrapper.scrollWidth) }; get limit() { return { x: this.scrollWidth - this.width, y: this.scrollHeight - this.height } } }, Emitter = class { events = {}; emit(z, ...F) { let G = this.events[z] || []; for (let Y = 0, X = G.length; Y < X; Y++)G[Y]?.(...F) } on(z, F) { return this.events[z]?.push(F) || (this.events[z] = [F]), () => { this.events[z] = this.events[z]?.filter(G => F !== G) } } off(z, F) { this.events[z] = this.events[z]?.filter(G => F !== G) } destroy() { this.events = {} } }, LINE_HEIGHT = 100 / 6, listenerOptions = { passive: !1 }, VirtualScroll = class { constructor(z, F = { wheelMultiplier: 1, touchMultiplier: 1 }) { this.element = z, this.options = F, window.addEventListener("resize", this.onWindowResize, !1), this.onWindowResize(), this.element.addEventListener("wheel", this.onWheel, listenerOptions), this.element.addEventListener("touchstart", this.onTouchStart, listenerOptions), this.element.addEventListener("touchmove", this.onTouchMove, listenerOptions), this.element.addEventListener("touchend", this.onTouchEnd, listenerOptions) } touchStart = { x: 0, y: 0 }; lastDelta = { x: 0, y: 0 }; window = { width: 0, height: 0 }; emitter = new Emitter; on(z, F) { return this.emitter.on(z, F) } destroy() { this.emitter.destroy(), window.removeEventListener("resize", this.onWindowResize, !1), this.element.removeEventListener("wheel", this.onWheel, listenerOptions), this.element.removeEventListener("touchstart", this.onTouchStart, listenerOptions), this.element.removeEventListener("touchmove", this.onTouchMove, listenerOptions), this.element.removeEventListener("touchend", this.onTouchEnd, listenerOptions) } onTouchStart = z => { const { clientX: F, clientY: G } = z.targetTouches ? z.targetTouches[0] : z; this.touchStart.x = F, this.touchStart.y = G, this.lastDelta = { x: 0, y: 0 }, this.emitter.emit("scroll", { deltaX: 0, deltaY: 0, event: z }) }; onTouchMove = z => { const { clientX: F, clientY: G } = z.targetTouches ? z.targetTouches[0] : z, Y = -(F - this.touchStart.x) * this.options.touchMultiplier, X = -(G - this.touchStart.y) * this.options.touchMultiplier; this.touchStart.x = F, this.touchStart.y = G, this.lastDelta = { x: Y, y: X }, this.emitter.emit("scroll", { deltaX: Y, deltaY: X, event: z }) }; onTouchEnd = z => { this.emitter.emit("scroll", { deltaX: this.lastDelta.x, deltaY: this.lastDelta.y, event: z }) }; onWheel = z => { let { deltaX: F, deltaY: G, deltaMode: Y } = z; const X = Y === 1 ? LINE_HEIGHT : Y === 2 ? this.window.width : 1, K = Y === 1 ? LINE_HEIGHT : Y === 2 ? this.window.height : 1; F *= X, G *= K, F *= this.options.wheelMultiplier, G *= this.options.wheelMultiplier, this.emitter.emit("scroll", { deltaX: F, deltaY: G, event: z }) }; onWindowResize = () => { this.window = { width: window.innerWidth, height: window.innerHeight } } }, Lenis = class { _isScrolling = !1; _isStopped = !1; _isLocked = !1; _preventNextNativeScrollEvent = !1; _resetVelocityTimeout = null; __rafID = null; isTouching; time = 0; userData = {}; lastVelocity = 0; velocity = 0; direction = 0; options; targetScroll; animatedScroll; animate = new Animate; emitter = new Emitter; dimensions; virtualScroll; constructor({ wrapper: z = window, content: F = document.documentElement, eventsTarget: G = z, smoothWheel: Y = !0, syncTouch: X = !1, syncTouchLerp: K = .075, touchInertiaMultiplier: J = 35, duration: Z, easing: Q = me => Math.min(1, 1.001 - Math.pow(2, -10 * me)), lerp: ee = .1, infinite: te = !1, orientation: oe = "vertical", gestureOrientation: ie = "vertical", touchMultiplier: se = 1, wheelMultiplier: ne = 1, autoResize: re = !0, prevent: fe, virtualScroll: ae, overscroll: he = !0, autoRaf: le = !1, anchors: ce = !1, __experimental__naiveDimensions: ue = !1 } = {}) { window.lenisVersion = version, (!z || z === document.documentElement) && (z = window), this.options = { wrapper: z, content: F, eventsTarget: G, smoothWheel: Y, syncTouch: X, syncTouchLerp: K, touchInertiaMultiplier: J, duration: Z, easing: Q, lerp: ee, infinite: te, gestureOrientation: ie, orientation: oe, touchMultiplier: se, wheelMultiplier: ne, autoResize: re, prevent: fe, virtualScroll: ae, overscroll: he, autoRaf: le, anchors: ce, __experimental__naiveDimensions: ue }, this.dimensions = new Dimensions(z, F, { autoResize: re }), this.updateClassName(), this.targetScroll = this.animatedScroll = this.actualScroll, this.options.wrapper.addEventListener("scroll", this.onNativeScroll, !1), this.options.wrapper.addEventListener("scrollend", this.onScrollEnd, { capture: !0 }), this.options.anchors && this.options.wrapper === window && this.options.wrapper.addEventListener("click", this.onClick, !1), this.options.wrapper.addEventListener("pointerdown", this.onPointerDown, !1), this.virtualScroll = new VirtualScroll(G, { touchMultiplier: se, wheelMultiplier: ne }), this.virtualScroll.on("scroll", this.onVirtualScroll), this.options.autoRaf && (this.__rafID = requestAnimationFrame(this.raf)) } destroy() { this.emitter.destroy(), this.options.wrapper.removeEventListener("scroll", this.onNativeScroll, !1), this.options.wrapper.removeEventListener("scrollend", this.onScrollEnd, { capture: !0 }), this.options.wrapper.removeEventListener("pointerdown", this.onPointerDown, !1), this.options.anchors && this.options.wrapper === window && this.options.wrapper.removeEventListener("click", this.onClick, !1), this.virtualScroll.destroy(), this.dimensions.destroy(), this.cleanUpClassName(), this.__rafID && cancelAnimationFrame(this.__rafID) } on(z, F) { return this.emitter.on(z, F) } off(z, F) { return this.emitter.off(z, F) } onScrollEnd = z => { z instanceof CustomEvent || (this.isScrolling === "smooth" || this.isScrolling === !1) && z.stopPropagation() }; dispatchScrollendEvent = () => { this.options.wrapper.dispatchEvent(new CustomEvent("scrollend", { bubbles: this.options.wrapper === window, detail: { lenisScrollEnd: !0 } })) }; setScroll(z) { this.isHorizontal ? this.options.wrapper.scrollTo({ left: z, behavior: "instant" }) : this.options.wrapper.scrollTo({ top: z, behavior: "instant" }) } onClick = z => { const G = z.composedPath().find(Y => Y instanceof HTMLAnchorElement && (Y.getAttribute("href")?.startsWith("#") || Y.getAttribute("href")?.startsWith("/#") || Y.getAttribute("href")?.startsWith("./#"))); if (G) { const Y = G.getAttribute("href"); if (Y) { const X = typeof this.options.anchors == "object" && this.options.anchors ? this.options.anchors : void 0; this.scrollTo(`#${Y.split("#")[1]}`, X) } } }; onPointerDown = z => { z.button === 1 && this.reset() }; onVirtualScroll = z => { if (typeof this.options.virtualScroll == "function" && this.options.virtualScroll(z) === !1) return; const { deltaX: F, deltaY: G, event: Y } = z; if (this.emitter.emit("virtual-scroll", { deltaX: F, deltaY: G, event: Y }), Y.ctrlKey || Y.lenisStopPropagation) return; const X = Y.type.includes("touch"), K = Y.type.includes("wheel"); this.isTouching = Y.type === "touchstart" || Y.type === "touchmove"; const J = F === 0 && G === 0; if (this.options.syncTouch && X && Y.type === "touchstart" && J && !this.isStopped && !this.isLocked) { this.reset(); return } const Q = this.options.gestureOrientation === "vertical" && G === 0 || this.options.gestureOrientation === "horizontal" && F === 0; if (J || Q) return; let ee = Y.composedPath(); ee = ee.slice(0, ee.indexOf(this.rootElement)); const te = this.options.prevent; if (ee.find(fe => fe instanceof HTMLElement && (typeof te == "function" && te?.(fe) || fe.hasAttribute?.("data-lenis-prevent") || X && fe.hasAttribute?.("data-lenis-prevent-touch") || K && fe.hasAttribute?.("data-lenis-prevent-wheel")))) return; if (this.isStopped || this.isLocked) { Y.preventDefault(); return } if (!(this.options.syncTouch && X || this.options.smoothWheel && K)) { this.isScrolling = "native", this.animate.stop(), Y.lenisStopPropagation = !0; return } let ie = G; this.options.gestureOrientation === "both" ? ie = Math.abs(G) > Math.abs(F) ? G : F : this.options.gestureOrientation === "horizontal" && (ie = F), (!this.options.overscroll || this.options.infinite || this.options.wrapper !== window && (this.animatedScroll > 0 && this.animatedScroll < this.limit || this.animatedScroll === 0 && G > 0 || this.animatedScroll === this.limit && G < 0)) && (Y.lenisStopPropagation = !0), Y.preventDefault(); const se = X && this.options.syncTouch, re = X && Y.type === "touchend" && Math.abs(ie) > 5; re && (ie = this.velocity * this.options.touchInertiaMultiplier), this.scrollTo(this.targetScroll + ie, { programmatic: !1, ...se ? { lerp: re ? this.options.syncTouchLerp : 1 } : { lerp: this.options.lerp, duration: this.options.duration, easing: this.options.easing } }) }; resize() { this.dimensions.resize(), this.animatedScroll = this.targetScroll = this.actualScroll, this.emit() } emit() { this.emitter.emit("scroll", this) } onNativeScroll = () => { if (this._resetVelocityTimeout !== null && (clearTimeout(this._resetVelocityTimeout), this._resetVelocityTimeout = null), this._preventNextNativeScrollEvent) { this._preventNextNativeScrollEvent = !1; return } if (this.isScrolling === !1 || this.isScrolling === "native") { const z = this.animatedScroll; this.animatedScroll = this.targetScroll = this.actualScroll, this.lastVelocity = this.velocity, this.velocity = this.animatedScroll - z, this.direction = Math.sign(this.animatedScroll - z), this.isStopped || (this.isScrolling = "native"), this.emit(), this.velocity !== 0 && (this._resetVelocityTimeout = setTimeout(() => { this.lastVelocity = this.velocity, this.velocity = 0, this.isScrolling = !1, this.emit() }, 400)) } }; reset() { this.isLocked = !1, this.isScrolling = !1, this.animatedScroll = this.targetScroll = this.actualScroll, this.lastVelocity = this.velocity = 0, this.animate.stop() } start() { this.isStopped && (this.reset(), this.isStopped = !1) } stop() { this.isStopped || (this.reset(), this.isStopped = !0) } raf = z => { const F = z - (this.time || z); this.time = z, this.animate.advance(F * .001), this.options.autoRaf && (this.__rafID = requestAnimationFrame(this.raf)) }; scrollTo(z, { offset: F = 0, immediate: G = !1, lock: Y = !1, duration: X = this.options.duration, easing: K = this.options.easing, lerp: J = this.options.lerp, onStart: Z, onComplete: Q, force: ee = !1, programmatic: te = !0, userData: oe } = {}) { if (!((this.isStopped || this.isLocked) && !ee)) { if (typeof z == "string" && ["top", "left", "start"].includes(z)) z = 0; else if (typeof z == "string" && ["bottom", "right", "end"].includes(z)) z = this.limit; else { let ie; if (typeof z == "string" ? ie = document.querySelector(z) : z instanceof HTMLElement && z?.nodeType && (ie = z), ie) { if (this.options.wrapper !== window) { const ne = this.rootElement.getBoundingClientRect(); F -= this.isHorizontal ? ne.left : ne.top } const se = ie.getBoundingClientRect(); z = (this.isHorizontal ? se.left : se.top) + this.animatedScroll } } if (typeof z == "number") { if (z += F, z = Math.round(z), this.options.infinite ? te && (this.targetScroll = this.animatedScroll = this.scroll) : z = clamp(0, z, this.limit), z === this.targetScroll) { Z?.(this), Q?.(this); return } if (this.userData = oe ?? {}, G) { this.animatedScroll = this.targetScroll = z, this.setScroll(this.scroll), this.reset(), this.preventNextNativeScrollEvent(), this.emit(), Q?.(this), this.userData = {}, requestAnimationFrame(() => { this.dispatchScrollendEvent() }); return } te || (this.targetScroll = z), this.animate.fromTo(this.animatedScroll, z, { duration: X, easing: K, lerp: J, onStart: () => { Y && (this.isLocked = !0), this.isScrolling = "smooth", Z?.(this) }, onUpdate: (ie, se) => { this.isScrolling = "smooth", this.lastVelocity = this.velocity, this.velocity = ie - this.animatedScroll, this.direction = Math.sign(this.velocity), this.animatedScroll = ie, this.setScroll(this.scroll), te && (this.targetScroll = ie), se || this.emit(), se && (this.reset(), this.emit(), Q?.(this), this.userData = {}, requestAnimationFrame(() => { this.dispatchScrollendEvent() }), this.preventNextNativeScrollEvent()) } }) } } } preventNextNativeScrollEvent() { this._preventNextNativeScrollEvent = !0, requestAnimationFrame(() => { this._preventNextNativeScrollEvent = !1 }) } get rootElement() { return this.options.wrapper === window ? document.documentElement : this.options.wrapper } get limit() { return this.options.__experimental__naiveDimensions ? this.isHorizontal ? this.rootElement.scrollWidth - this.rootElement.clientWidth : this.rootElement.scrollHeight - this.rootElement.clientHeight : this.dimensions.limit[this.isHorizontal ? "x" : "y"] } get isHorizontal() { return this.options.orientation === "horizontal" } get actualScroll() { const z = this.options.wrapper; return this.isHorizontal ? z.scrollX ?? z.scrollLeft : z.scrollY ?? z.scrollTop } get scroll() { return this.options.infinite ? modulo(this.animatedScroll, this.limit) : this.animatedScroll } get progress() { return this.limit === 0 ? 1 : this.scroll / this.limit } get isScrolling() { return this._isScrolling } set isScrolling(z) { this._isScrolling !== z && (this._isScrolling = z, this.updateClassName()) } get isStopped() { return this._isStopped } set isStopped(z) { this._isStopped !== z && (this._isStopped = z, this.updateClassName()) } get isLocked() { return this._isLocked } set isLocked(z) { this._isLocked !== z && (this._isLocked = z, this.updateClassName()) } get isSmooth() { return this.isScrolling === "smooth" } get className() { let z = "lenis"; return this.isStopped && (z += " lenis-stopped"), this.isLocked && (z += " lenis-locked"), this.isScrolling && (z += " lenis-scrolling"), this.isScrolling === "smooth" && (z += " lenis-smooth"), z } updateClassName() { this.cleanUpClassName(), this.rootElement.className = `${this.rootElement.className} ${this.className}`.trim() } cleanUpClassName() { this.rootElement.className = this.rootElement.className.replace(/lenis(-\w+)?/g, "").trim() } }; gsapWithCSS.registerPlugin(ScrollTrigger$1, ScrollToPlugin, ScrambleTextPlugin, DrawSVGPlugin); class App { appArray; swup; MenuComponent; headerComponent; menuComponent; mouseStalkerComponent; common; indexPage; profilePage; worksPage; worksIdPage; contactPage; errorPage; constructor() { this.appArray = [], this.init(), this.headerComponent = new App$3, this.appArray.push(this.headerComponent), this.menuComponent = new App$2, this.appArray.push(this.menuComponent), this.mouseStalkerComponent = new App$1, this.appArray.push(this.mouseStalkerComponent), this.common = new App$9, this.appArray.push(this.common), this.indexPage = new App$8, this.appArray.push(this.indexPage), this.profilePage = new App$7, this.appArray.push(this.profilePage), this.worksPage = new Works, this.appArray.push(this.worksPage), this.worksIdPage = new App$6, this.appArray.push(this.worksIdPage), this.contactPage = new App$5, this.appArray.push(this.contactPage), this.errorPage = new App$4, this.appArray.push(this.errorPage), this.allInit(), $$1("body").getAttribute("data-loaded") || $$1("body").setAttribute("data-loaded", "") } allInit() { this.appArray.forEach(F => { F.init() }) } init() { ScrollTrigger$1.config({ ignoreMobileResize: !0 }), registerEffects(), this.scrollInit(), this.pageTransition(), this.breakpointReload() } scrollInit() { const F = G => 1 - Math.pow(1 - G, 4); window.lenis = new Lenis({ duration: 1.3, easing: F, autoRaf: !0 }) } pageTransition() { const F = document.querySelector("[data-parts-transition-text]"), G = document.querySelectorAll("[data-line-vertical]"), Y = { from: "(.*)", to: "(.*)", out: X => { $$1("[data-menu]").getAttribute("data-menu") === "open" && this.menuComponent?.closeMenu(), gsapWithCSS.set("[data-parts-transition-circle], [data-parts-transition-text]", { display: "block" }), gsapWithCSS.set("[data-parts-transition-circle] svg ellipse", { drawSVG: "0%" }); const K = [""], J = K[Math.floor(Math.random() * K.length)]; F && (F.innerHTML = "", F.innerHTML = J); const Z = splitText(F, "chars"); gsapWithCSS.effects.setTitle(Z.chars); const Q = gsapWithCSS.timeline(); Q.to("[data-container]", { opacity: 0, pointerEvents: "none", duration: .8, onComplete: () => { scrollSet("stop"); const ee = document.querySelector("[data-mouse]"), te = document.querySelector("[data-mouse-bg]"), oe = document.querySelector("[data-mouse-text]"); ee && ee.getAttribute("data-mouse") === "true" && (gsapWithCSS.effects.inScrambleText(oe, { text: "＋" }), gsapWithCSS.to(te, { scale: 1, duration: .8, ease: "expo.out", overwrite: !0 })) } }, "in"), Q.set("[data-parts-transition-cover]", { opacity: 0, duration: .4 }, "in"), $$1('[data-container="index"]') && Q.to("[data-parts-transition-bg]", { opacity: 1, duration: .8 }, "in"), Q.to("header", { opacity: 0, duration: .8 }, "in"), Q.to(G, { y: "-100%", duration: .8, ease: "power1.inOut" }, "in"), Q.to("[data-parts-transition-circle] svg ellipse", { drawSVG: "0% 100%", duration: 1.2, ease: "power1.out", onStart: () => { setColorVariables(getMode() === "dark" ? "#ffffff" : "#000000", getMode() === "dark" ? "#000000" : "#ffffff") } }, "in+=0.75"), Q.inTitle(Z.chars, { stagger: "0.05" }, "in+=0.75"), Q.to("[data-parts-transition-circle] svg ellipse", { drawSVG: "100% 100%", duration: 1.8, ease: "power3.inOut", overwrite: "auto" }, "in+=2"), Q.to(Z.chars, { ease: "power3.inOut", y: "-110%", duration: .8, overwrite: "auto" }, getDeviceType() === "sp" ? "in+=3.35" : "in+=3.15"), Q.add(() => { ScrollTrigger$1.getAll().forEach(ee => { ee.kill() }), X() }, getDeviceType() === "sp" ? "in+=3.9" : "in+=3.6") }, in: X => { const K = $$1('[data-container="index"]'); K || this.allInit(), scrollSet("start"); const J = gsapWithCSS.timeline({}); K || J.set("[data-container]", { opacity: 1, pointerEvents: "auto", duration: .8 }, "in+=3"), K && (J.fromTo("[data-container]", { opacity: 0 }, { opacity: 1, pointerEvents: "auto", duration: 1, onComplete: () => { K && this.allInit() } }, "in"), J.set("[data-parts-transition-bg]", { opacity: 0 }, "in+=1")), J.to(G, { y: "0", duration: 2, ease: "power3.out", stagger: .35 }, K ? "in+=1" : "in"), J.to("header", { opacity: 1, duration: .8 }, "in"), J.call(() => { X() }) } }; new _({ containers: ["[data-container]"], plugins: [new s$1({ animations: [Y] }), new i({ persistTags: X => { const K = X.tagName === "LINK" && X.getAttribute("rel") === "canonical", J = X.tagName === "META" && X.getAttribute("property") === "og:type"; return !K && !J } }), new a({ gaMeasurementId: "G-6VQ3TFKJ0W" })], animateHistoryBrowsing: !0, cache: !1 }) } breakpointReload() { let F = window.innerWidth; window.addEventListener("resize", () => { const G = F; F = window.innerWidth, F < 767 && G >= 767 && location.reload(), F >= 767 && G < 767 && location.reload() }) } } window.addEventListener("load", () => { new App });
